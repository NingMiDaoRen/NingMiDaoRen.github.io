---
title: 快速排序
date: 2020-04-01 15:15:49
tags: [算法,排序]
categories: [计算机基础]
copyright: true
description:
---

<meta name="referrer" content="no-referrer" />  

<!--more-->



# 快速排序



## 算法核心思路

### 排序流程

1. 快速排序首先选择一个分界值**pivot**
2. 通过pivot将数组分成左右两个部分，将小于等于pivot的数放到pivot的左边，将大于pivot的数放在数组的右边
3. 此时，数组被分成了两个子部分，对于左侧子数组可以选出一个pivot，然后按照数值大小分成两个部分，右侧子数组同理
4. 重复上述步骤，当子数组中元素个数为1时，整个数组也就有序了

### 排序步骤

设，待排序数组为，A[0].....A[n-1],我们选择第一个数作为pivot，将所有比它小的数放到它的左侧，所有比他大的数放到它的右侧，这个过程叫做**一趟快速排序**。

一趟快速排序的算法是：

1. 设两个变量 i , j ,排序开始时，i = 0，j= n-1
2. 以第一个数组元素为pivot，即**pivot** = A[0]
3. j 从右向左扫描，找出第一个小于pivot的值**A[j]**, **A[j]**和**A[i]**交换
4. i 从左向右扫描，找出第一个大于pivot的**A[i]**, **A[i]**和**A[j]**交换
5. 重复3,4直到 i = j,即3中A[j]不小于**pivot**,4中A[i]不大于**pivot**

![](https://images.gitee.com/uploads/images/2020/0401/164957_5dad99c6_5550632.gif)

自制动图有水印，木得办法。上述动图是一趟快排，我在下面粘了一个从Leetcode上找到的动图，它的pivot是取的数组最后一位。我的是首位，两种取法对结果没有影响，甚至你还可以随机取值当pivot.

![](https://pic.leetcode-cn.com/e5e0dbdf33e6f9a40b467b61f36b740d2dc197cd5b92760a92dab7be36a1da90-quick-sort.gif)

## 代码实现

```c++
#include<iostream>
#include<vector>

using namespace std;

void quick_sort(vector<int>&nums,int low,int high);
void print_array(vector<int> arr);

int main()
{
	vector<int> nums = {2,3,4,5,1,6,7,8,9,0};
	quick_sort(nums,0,nums.size()-1);
	print_array(nums);
	
	return 0;
}

void quick_sort(vector<int>&nums,int low,int high)
{
	if(low>=high) return;
	int i = low,j = high+1;
	int pivot = nums[low];
	while(true)
	{	
		while(nums[--j] > pivot)//从右向左找比pivot小的数 
		{
			if(j == low) break;
		}
		while(nums[++i] < pivot)//从左到右找比pivot大的数 
		{
			if(i == high) break;
		}
		if(i>=j) break;//此时pivot左边的都比它小，右边的都比它大
		swap(nums[i],nums[j]);
	}
	swap(nums[low],nums[j]);
    /*
    	因为j每次都在找一个比pivot小的数，把pivot换到一个比pivot小的数的位置上，
    	即，设 x = nums[j],x<pivot,swap(x,pivot), => x,..,pivot,...
    */
	quick_sort(nums,low,j-1);
	quick_sort(nums,j+1,high);
}

void print_array(vector<int> arr)
{
	vector<int>::iterator it = arr.begin();
	for(;it!=arr.end();it++)
	{
		cout << *it << " ";
	}
	cout << endl;
	
}

```



时间复杂度：O(nlogn)

排序稳定性：不稳定