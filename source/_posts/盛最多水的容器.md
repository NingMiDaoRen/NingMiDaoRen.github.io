---
title: 盛最多水的容器
date: 2020-02-22 20:37:17
tags: [编程技巧,数组]
categories: [计算机基础]
copyright: true
description:
---

<meta name="referrer" content="no-referrer" />  
<!--more-->

# 盛最多水的容器

## 题目描述

给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器，且 n 的值至少为 2。


## 测试用例
示例:

输入: [1,8,6,2,5,4,8,3,7]
输出: 49

![示例图片](https://images.gitee.com/uploads/images/2020/0222/203751_41e4e7a2_5550632.jpeg)
图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/container-with-most-water
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



## 题目翻译
> 已知：
>
> 一个长度为n的数组height
>
> > 数据含义:
> >
> > 1. 数组里的值：板的高度
> > 2. 数组下标 i【从0开始】：代表第i+1块木板
> >
> > > 目的：
> > >
> > > 找到两块板之间盛水的最大值【最大矩形面积】
>
> 坑：无



## 解题思路

首先简单分析一下，发现最无脑的方式就是，把所有木板可能的组合方式下的容量【面积】全部算一遍.，找出最大值....

**暴力法**

```c++
#include<iostream>
#include<vector>

using namespace std;
int maxArea(vector<int>& height);
int main()
{
	
	vector<int> height = {1,8,6,2,5,4,8,3,7};
	cout << "暴力>: " << maxArea(height) << endl;
	return 0;
}

//暴力法
int maxArea(vector<int>& height) 
{
	int area;
	int max_area = -1;
	for(int i = 0;i<height.size();i++)
	{
		for(int j = i+1;j<height.size();j++)
		{
			area = abs(i-j)*min(height[i],height[j]);	
			if(area>max_area)
			{
				max_area = area;
			}
		}	
	} 
	return max_area;
}

```

时间复杂度：O(n²)

了解到此题有兜底解法之后，咱们现在稍微思考一下，**盛水的容量到底是由什么决定的**。

我们都知道此题中，水的容量就是**矩形面积**，决定矩形面积的参数就两个**长**和**宽**。

换到此题中，就是**两块木板的绝对距离**和**两块板中高度较小的那个**。那么自然是距离越远，最低高度越高，储水量越大。

那么，不妨设i = 0 这块板为第一块板，j = height.size()-1 为第二块板，这样我们就得到了这样一个公式：
$$
Area = |i - j|*min( height[i] , height[j] )
$$
遵循这个公式把整个数组扫描一遍，就能比较出最大值了。

**双指针法**

```c++
#include<iostream>
#include<vector>

using namespace std;
int maxArea2(vector<int>& height);
int main()
{
	
	vector<int> height = {1,8,6,2,5,4,8,3,7};
	cout << "双指针>: " << maxArea2(height) << endl;
	return 0;
}

//双指针
int maxArea2(vector<int>& height) 
{
	int start = 0,rear = height.size()-1;
	int area = 0,max_area = -1;
	while(start < rear)
	{
		area = abs(start-rear)*min(height[start],height[rear]);
		if(area > max_area)
		{
			max_area = area;
		}
		if(height[start] < height[rear])
		{
			start++; 
		}
		else
		{
			rear--;
		}
	}
    return max_area;
} 
```

时间复杂度：O(n)