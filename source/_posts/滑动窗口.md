---
title: 滑动窗口
declare: true
date: 2020-04-22 15:10:58
tags: [算法]
categories: [算法]
toc: true
---

<meta name="referrer" content="no-referrer" />  

<!--more-->

# 滑动窗口

什么是滑动窗口算法？我们举个最简单的例子。

给定一个长度为 n  的数组  arr ，让你求其中 k 个数加和的最大值。

假如这个数组长这样：

```java
int arr [] = {100,200,300,400,600,400,800};
```

让你求 3 个数加和的最大值。你可能会想到：

经典的暴力破解法

```java
public class Demo1
{
	
	public static void main(String[] args)
	{
		// TODO Auto-generated method stub
		int arr [] = {100,200,300,400,600,400,800};
		System.out.println(subMax(arr,3));
		
	}
	
	public static int subMax(int arr[],int k) {
		int ans = -1;
		for(int i = 0;i<arr.length-k+1;i++) {
			int curSum = 0;
			for(int j = 0;j<k;j++) {
				curSum += arr[i+j];
			}
			ans = Math.max(ans, curSum);
		}
		return ans;
	}
}
```

时间复杂度：O(n²)

排序取巧法：

```java
import java.util.Arrays;

public class Demo1
{
	
	public static void main(String[] args)
	{
		// TODO Auto-generated method stub
		int arr [] = {100,200,300,400,600,400,800};
		System.out.println(subMax2(arr,3));
	}
	
	public static int subMax2(int arr[],int k) {
		int ans = 0;
		Arrays.sort(arr);
		for(int i = arr.length-1;i>=arr.length-k;i--) { 
			ans += arr[i];
		}
		return ans;
	}

}

```

时间复杂度：O(n+m)

现在，让我们换一种思路，假设 k 为 2，我们把长度为 2 的子数组看成一个窗口

![](https://pic1.zhimg.com/50/v2-88b10c0bfe1fcffd2f97eb778c795f72_hd.jpg)

如上图所示，我们可以分出 3 个**窗口**，现在我们要做的就是观察每个窗口中的和，通过一次遍历我们就能得出数组 k个数字加和的最大值。

第二个窗口 = 第一个窗口值 - 移出窗口的值

```java
public class Demo1
{
	public static void main(String[] args)
	{
		// TODO Auto-generated method stub
		int arr [] = {100,200,300,400,600,400,800};
		System.out.println(subMax3(arr,3));	
	}
	
	public static int subMax3(int arr[],int k) {
		if(arr.length<0) return -1;
		
		int maxSum = 0;
		for(int i = 0;i<k;i++) {
			//第一个窗口的值
			maxSum+=arr[i];
		}
		int sum = maxSum;
		for(int i = k;i<arr.length;i++) {
			//新窗口的值 = 第一个窗口的和 + 新进窗口的值 - 移出窗口的值
			sum += (arr[i]-arr[i-k]);
			maxSum = Math.max(maxSum,sum);
		}
		return maxSum;
	}
}

```

时间复杂度：O(n)