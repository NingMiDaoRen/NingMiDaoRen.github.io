---
title: 并查集
declare: true
toc: true
date: 2020-05-01 15:34:55
tags: [数据结构与算法]
categories: [计算机基础]
---

<meta name="referrer" content="no-referrer" />  

<!--more-->



# 并查集(Union-find)

[TOC]



## Part 1 提出问题

并查集是的逻辑结构是集合类型，

并查集是用来解决**动态连通性**的问题的，不知道什么是连通性，没关系，我们通过一个例子来具体说明问题

![](https://images.gitee.com/uploads/images/2020/0501/155235_ed4c3717_5550632.png )

上图我们给定了 10 个对象，通过执行方法 **union(O1,O2)** ，将两个对象**连接**到一起，通过**connected()** 方法，判断两个对象是否**直接或间接地连接在一起**。

比如，connected(0，7)，我们给出的答案就是 false，connected(8，9) 我们给出的答案就是 true

执行如下一系列操作之后，原图会变成这样：

union(5,0)

union(7,2)

union(6,1)

union(1,0)

![](https://images.gitee.com/uploads/images/2020/0501/160102_b4531d33_5550632.png)

## 1.1 动态连通性

那么，我们如何定义 *p*  与 *q* 是连通的呢？我们认为连通性是一种 *等价关系*，也就意味着：

1. 自反性(Reflexive)：*p* 和 *p* 自己是连通的
2. 对称性(Symmetric)：*p* 和 *q* 连通，那么，*q* 和  *p* 也连通
3. 传递性(Transitive)：*p* 和 *q* 连通，*q* 和 *r* 也连通，那么，*p* 和  *r* 也连通

![](https://images.gitee.com/uploads/images/2020/0501/160811_ac702a4e_5550632.png )

当我们有了等价关系之后，我们可以将每一种连通情况都放在一个集合中，集合中的任意两个元素相互连通，我们管这些集合叫做**连通分量**，如上图，我们就有 3 个连通分量。



## 1.2 Union-find 算法的API

基于上述分析，我们会构建如下的API：

```java
public class UF
{
    
    public UF(int N);
    public void union(int p,int q);//连接操作
    public int find(int p);//找对象p
    public boolean connected(int p,int q);//判断是否连通

}
```



## 1.3 快速查询 Quick Find

我们让对象的索引值和其编号保持相同，采用一个整型数组来表示连通性。

假设有10个对象，那他们的编号和数组下标值相同，从0……9

由于自己和自己是连通的，所以，初始化数组时，这个数组长这样：

```java
private int id[] = {0,1,2,3,4,5,6,7,8,9};
```

我们进行union操作时，取出 *q* 中存的 id 值，赋值给 *p* 的 id 值，如果有和  *p* 重复得id 值的对象，**一律替换成q中所存的id** 。

```java
int qid = id[q];
int pid = id[p];
for(int i = 0;i<id.length;i++){
    if(id[i] == pid){
        id[i] = qid;
    }
}
```

直接展示代码：

```java
package MyDataStructure;

public class UF {
	private int [] id;
	public UF() {} ;
	
	public UF(int N) {
		for(int i = 0;i<N;i++) {
			id[i] = i;
		}
	}
	
	public void union(int p,int q) {
		int pid = id[p];
		int qid = id[q];
		for(int i = 0;i<id.length;i++) {
			if(id[i] == pid) {
				id[i] = qid;
			}
		}
	}
	
	public boolean connected(int p,int q) {
		return id[p] == id[q];
	}
	
	public int find(int p) {
		return id[p];
	}
}

```

时间复杂度分析：

initialize()：O(n)

union() ：O(n)

connected() ：O(1)



## 1.4 快速合并 Quick Union

由于快速查找算法中，合并操作时间复杂度过高，我们将其进行优化，得到了快速合并算法，具体内容如下：

![](https://images.gitee.com/uploads/images/2020/0501/170746_b2c5c02b_5550632.png )

我们依旧使用一个整型数组来存储连通关系，但是，数组中值的含义发生了改变：

**每个对象对应的数组值，代表了该对象的父节点**

我们认为，初始状态每个对象自己都是一棵树的根节点。

对于connected(p,q)，我们只需要查找，两个对象的根节点是否相同即可

对于union(p,q)，我们只需要找出p，q的父节点，将 p 的父节点处的数组值改成 q 的父节点值即可。

如上图所示，现在我要连接 3 和 5 ，那么我们就需要**找出它们各自的父节点 9，6**，将 id[9] 中原本的 9 改成5

的父节点值 6 即可。

**id[9] 表示，对于第 9 个对象，它的父节点是对象 6**

```java
package MyDataStructure;

public class QuickUnionUF {
	private int [] id;
	public QuickUnionUF(){};
	public QuickUnionUF(int N) {
		for(int i = 0;i<N;i++) {
			id[i] = i;
		}
	}
	
	private int root(int i) {
		while(id[i] != i) {
			i = id[i];
		}
		return i;
	}
	
	public boolean connected(int p,int q) {
		if(root(p) == root(q))
		{
			return true;
		}
		return false;
	}
    
	/*
	 * 将p对象的树根改成q对象的树根
	 * */
	public void union(int p,int q) {
		int pRoot = root(p);
		int qRoot = root(q);
		id[pRoot] = qRoot; 
	}
	
	public int find(int p) {
		return root(p);
	}
}

```

