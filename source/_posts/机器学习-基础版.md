---
title: 机器学习-基础版
declare: true
toc: true
date: 2020-04-10 13:37:29
tags: [机器学习]
categories: [机器学习]
---



<meta name="referrer" content="no-referrer" />  

<!--more-->

# 机器学习-基础版

[TOC]

## Part 1 序



### 1.1 本人学习机器学习的初衷

我学机器学习的初衷是因为手头有个推荐系统的项目，刚开始我觉得推荐算法是数据挖掘的内容，然而数据挖掘挖着挖着我就感觉有些不太对劲。数据挖掘它是一门综合性极强的学科，综合了统计学，机器学习等等学科。为了学好数据挖掘，同时我又对机器学习充满好奇，这就导致我无论如何都要学习且学好这门课程。

在此，感谢吴恩达老师的机器学习教程！！！



### 1.2 机器学习的应用场景

> Google的网页搜索

> 垃圾邮件的筛除

> **Data Mining**

> Biology

...

当一个机械造物，它自己会行走，飞行的时候，作为它的创造者，你是否能感受到人工智能的魅力？这门课程就是让你学会如何教育**愚笨的电脑**学会学习，并模拟人脑。



### 1.3 什么是机器学习

**Definition 1：** Field of study that gives computers the ability to learn without explicitly programmed.

关键点：在没有明确地编程的条件下，让电脑学会学习。

下面的定义是一个家喻户晓的定义，推荐理解原句

**Definition 2:**  A computer program is said to *learn* from experience E with respect to some task T and some performance measure P, if its performance on T , as measured by P,improves with experience E.

对于一个邮件过滤系统，E代表：观察你所标记的垃圾邮件，T代表：分类垃圾邮件，P代表：分类的准确率 



## Part 2 机器学习的分类

### 2.1 监督学习(Supervised Learning)

我有一个朋友想卖掉他的房子，他不知道市场价格是多少，想让电脑帮他预测一下值

![](https://images.gitee.com/uploads/images/2020/0410/181016_87637a55_5550632.png)

绿色的字代表了我朋友房子的面积，那么通过机器学习，就可能给出如下两种结果：

![](https://images.gitee.com/uploads/images/2020/0410/181116_5b7c5762_5550632.png)

![](https://images.gitee.com/uploads/images/2020/0410/181142_79f0966c_5550632.png)

第一张图预测结果是145万元，第二张图预测结果是115万元。由此可知，由于我们用于**拟合(fit)**的函数不同导致了最后结果的不同。这个例子是监督学习的经典例子。

我们通过事先给算法一个**包含正确答案数据集**，而目的是给出更多正确的答案。像是这种预测类的问题，我们把它们称作**回归问题(Regression)**。

下面还有一个恶性肿瘤预测的例子：

![](https://images.gitee.com/uploads/images/2020/0410/181936_e80890f9_5550632.png)

蓝色代表良性肿瘤，红色代表恶性肿瘤(Malignant),横坐标是肿瘤大小。我们现在的任务是对粉色箭头所指的进行**分类(Classification)**.分类问题中，可能分类的结果不止两个【手写数字识别】。

在这个例子中，只有肿瘤大小这一个**属性(特征)**，但是在其他的机器学习中可能存在很多个特征，例如肿瘤细胞的形状，肿瘤的厚度，...

有时我们要处理的特征可能很多，甚至用到无穷多个特征，这就需要**支持向量机(Support Vector Machine)**这一算法了。



#### 总结

监督学习(Supervised Learning)，给算法一个正确结果的数据集。目的是解决下列问题

解决的问题：

> 回归问题：预测一个**连续值**的输出
>
> 分类问题：预测**离散值**的输出





### 2.2 无监督学习(Unsupervised Learning)

如果说监督学习的最大特点是，在训练模型的时侯，**明显地标记出每个训练数据的“正确答案”**。

![](https://images.gitee.com/uploads/images/2020/0410/211434_2c945803_5550632.png)

那无监督学习最大的特点是：**训练模型时，不标注每条数据的含义，让电脑自己分簇(Cluster)**。

![](https://images.gitee.com/uploads/images/2020/0410/211634_8934882d_5550632.png)

无监督学习通过**聚类算法，鸡尾酒会算法(Cocktail Party Algorithm)等等**对数据集进行分簇，进而找到数据的类型结构。



<br>

## Part 3 线性回归(Linear Regression)-机器学习的第一步



### 3.1 什么是线性回归

在上面我们讲述的房价预测就是监督学习中的回归问题，我们给定一个训练集，这个训练集里面包括了，**(房子面积，出售价格)**，然后我们需要在连续的面积([0,n])中任意取一个面积，来预测出售价格。

![](https://images.gitee.com/uploads/images/2020/0411/104115_8c256e08_5550632.png)

对于训练集我们有着如下的规定：

**m**：训练集中数据样例的个数

**x**：特征 / 输入值

**y**：目标值 / 输出值

**(x,y)**： 一组训练样例
$$
(x^{i},y^{i})：第 i 个训练用例
$$




![](https://images.gitee.com/uploads/images/2020/0411/104255_3adfe843_5550632.png)

把这整个过程可以简化成：

![](https://images.gitee.com/uploads/images/2020/0411/105303_53c034fe_5550632.png)

![](https://images.gitee.com/uploads/images/2020/0411/105416_bc3aa140_5550632.png)

最终发现，重点在于找到其中的假设函数 *h* ，这个函数我们可以用一次函数来对训练集进行拟合，由于这个函数是线性的，问题又是回归问题，所以我们称这个模型为**线性回归模型**。





### 3.2 如何实现线性回归模型



#### 3.2.1 代价函数(Cost Function)

![](https://images.gitee.com/uploads/images/2020/0411/111704_cb4d6e42_5550632.png)



找到了函数 *h* 我们也就能开始预测了。所谓找出函数 *h*，在本质上就是在找，**模型参数** θ0，θ1。不同的模型参数当然会导致函数h的不同。

![](https://images.gitee.com/uploads/images/2020/0411/112049_e046b14b_5550632.png)

模型想要准确，就需要
$$
\frac{1}{2m}\sum_{i = 0} ^m(h_\theta (x^{(i)}) - y^{(i)} )^2
$$
尽量小
$$
h_\theta (x^i) 是第i个训练值的预测值，y^i是真实值
$$
整个式子描述了预测之和真实值之间的**偏差程度**，把它当作一个函数
$$
J(\theta_{0},\theta_{1}) = \frac{1}{2m}\sum_{i = 0} ^m(h_\theta (x^{(i)}) - y^{(i)} )^2
$$
这个东西的数学定义叫做**均方根误差**，存在的意义在于表示**预测值和真实值**的偏差**(而不是平均值和样本值的偏差)**

[均方根误差科普](https://baike.baidu.com/item/均方根误差/3498959?fr=aladdin)

我们现在要做的就是
$$
minimize( J(\theta_{0},\theta_{1}) )
$$
我们称
$$
J(\theta_{0},\theta_{1})
$$
为**代价函数** or **均方根误差(MSE)函数**

当代价函数最小时，我们就找出了最合适的模型参数，进而确定了线性函数 h

#### 3.2.2 代价函数和预测函数的关系

前面讲的太快，现在我们来慢慢分析，它们之间的关系。

![](https://images.gitee.com/uploads/images/2020/0412/173247_a4edf54d_5550632.png)

PPT画图，不准请见谅。

数据集共有3条数据，其中它们的值我已可视化在图上。我们为了方便说明，把假设函数 *h* 设为：
$$
h_\theta(x) = \theta_1 x
$$
那么，它的代价函数就变成了：
$$
J(\theta_{1}) = \frac{1}{2m}\sum_{i = 0} ^m(h_\theta (x^i) - y^i )^2
$$
![](https://images.gitee.com/uploads/images/2020/0412/191019_85f9a9fd_5550632.png)

> 假设函数：h(x) 是关于 房子面积 x 的函数【其中带有参数θ】
>
> 代价函数：J(θ1) 关于模型参数 θ1 的函数



当 θ1 = 1 时，我们预测函数的曲线长这样：

![](https://images.gitee.com/uploads/images/2020/0412/173308_373271f7_5550632.png)

此时算一下代价函数
$$
J(\theta_{1}) = \frac{1}{2m}\sum_{i = 0} ^m(h_\theta (x^i) - y^i )^2
$$

$$
J(\theta_{1}) = \frac{1}{2m}\sum_{i = 0} ^m(\theta_1x^i - y^i )^2
$$

$$
J(\theta_{1}) = \frac{1}{2m}\sum_{i = 0} ^m(1*x^i - y^i )^2
$$

$$
J(\theta_{1}) = \frac{1}{2*3}[(0-0)+(0-0)+(0-0)] = 0
$$

画出代价函数 J(θ1)的图像：

![](https://images.gitee.com/uploads/images/2020/0412/174153_a5c42b7d_5550632.png)

之后，我们设 θ1 为不同的值，-0.5，0.5，1.5，2.5 .... 画出它的预测函数图像和代价函数图像。

这是当θ取不同值时的预测函数：

![](https://images.gitee.com/uploads/images/2020/0412/192116_c8df6788_5550632.png)

代价函数：

![](https://images.gitee.com/uploads/images/2020/0412/192726_9df1890f_5550632.png)

代价函数最终效果图：

![](https://images.gitee.com/uploads/images/2020/0412/192904_2a8fde0c_5550632.png)

回想一下，我们的目的是什么：
$$
minimize(J(\theta_{1}))
$$
找到出 θ。此时你会发现，**当代价函数取最小时，假设函数和测试集的拟合结果是最好的**。【θ = 1,预测函数和训练用例完全重合】



#### 3.2.3 等高线图(Contour plot)

现在让我们回到原来的问题上

![](https://images.gitee.com/uploads/images/2020/0412/194518_d3ab9478_5550632.png)

当预测函数有两个模型参数时，也就意味着**代价函数变成了关于 θ0 和 θ1 的二元函数**，它长成这样：

![](https://images.gitee.com/uploads/images/2020/0412/194913_8bfe06ea_5550632.png)

![](https://images.gitee.com/uploads/images/2020/0412/195124_f8eb9385_5550632.png)

右侧，就是代价函数的等高线图，如何理解呢？很简单，想象用一个横截面把上面的三维碗状图水平切一刀，你会发现一个剖面，碗状图和横切面相交的地方，**高度相同**，但是**对应着若干个不同的 θ0 和 θ1**，把高度相同，但θ不同的点整理到一起，就有了右侧的等高线图。其中每一个椭圆都代表一个高度。

![](https://images.gitee.com/uploads/images/2020/0412/200308_8e0969e7_5550632.png)

上图的红色标记处，代表了一组θ，对应着它的假设函数，如左面所示。

![](https://images.gitee.com/uploads/images/2020/0412/200436_383b6034_5550632.png)

我们又找了一组，这个点相对靠近了最小值，感觉假设函数拟合的结果没有刚才的那么离谱。

![](https://images.gitee.com/uploads/images/2020/0412/200645_a9fb9662_5550632.png)

这组，**已经离代价函数的最小值很近了，但是不是它最小值**，此时拟合的结果，比前两个都要好。

**如何自动且快速地找出代价函数最小值已经成为了一个至关重要的问题 ！**



#### 3.2.4 梯度下降(Gradient decent algorithm)

先把前面的过程梳理一下。

基于监督学习的过程，我们会产生一个含参数 θ 关于自变量 x 的假设函数
$$
h_\theta(x)
$$
为了想要预测结果相对准确，我们引入了代价函数，目的是确定最好的参数 θ ，进而确定假设函数。

而代价函数
$$
J(\theta) = \frac{1}{2m}\sum_{i = 0} ^m(h_\theta (x^i) - y^i )^2
$$
是一个关于参数 θ 的 n 元函数，只有参数 θ 未知，当代价函数取得最小值时，**预测值和真实值之间的偏差最小，即假设函数拟合的结果就越好**，如何求出 θ 就变成现在的主要矛盾了。

之前，介绍了等高线图，当图中的椭圆最小，接近于一个点时，代价函数是最小的，参数是最优的，假设函数是拟合程度最好的【不考虑过拟合】

下面，我们就看看，如何自动地快速地求出 n 元参数 θ。为了方便讨论，我们就先把代价函数看成只有2个自变量的函数，当然，它可以是一个 n 元函数。

现在我们有：
$$
J(\theta_{0},\theta_{1}) 或者是 J(\theta_{0},\theta_{1},...)
$$
欲求：
$$
min_{\theta_{0}{\theta_{1}}} =J(\theta_{0},\theta_{1})
$$
梯度下降的过程：

> 1. 任意初始化这2个参数的值：θ0 = 0，θ1 = 0
> 2. **同时**改变这两个参数的值，减小代价函数 J(θ0，θ1) 的值
> 3. 一直取到最小

我们先直观的感受一下，梯度下降算法是怎么工作的。

![](https://images.gitee.com/uploads/images/2020/0418/092557_1977b276_5550632.png)

这是两座山峰，啊，不对，是代价函数的图像，最下面是两个参数，高度是函数值。不过，我们先把它看成山峰，草堆，什么的，体验一下梯度下降算法是怎么玩的。

假设，你任取一个点，如下图加号所示位置。你站在这个点上：

![](https://images.gitee.com/uploads/images/2020/0418/092954_1eab65a5_5550632.png)

现在，你想要快速下山，环顾周围 360° 你发现沿着这个方向走是最好的，于是你走了一步：

![](https://images.gitee.com/uploads/images/2020/0418/093354_986eeacc_5550632.png)

站在这个点上，你像刚才一样，环顾四周，选择方向，再迈一步一步又一步：

![](https://images.gitee.com/uploads/images/2020/0418/093511_4540ed0a_5550632.png )

恭喜你，此时走到了这条曲线的**局部最低点**，如果你的初始值换成另外一个值，可能结果就会变成这样：

![](https://images.gitee.com/uploads/images/2020/0418/093724_255fa791_5550632.png)

这就是，梯度下降的直观感受，下面让我们直接进入正题。

![](https://images.gitee.com/uploads/images/2020/0418/093958_d6660863_5550632.png)

梯度下降算法要做的，就是一直重复里面的式子直到收敛

莫慌，先解释一下，这堆参数都是啥。

> 1. :=   >>> 它是赋值号，和MySQL一样，赋值号不用 = ， = 用于等值判断
>
> 2. θj  >>> 它就是代价函数的那些参数，在这个例子中就是 θ0 和 θ1
>
> 3. α >>> Learning Rate，学习率**【α>0】**，它越大相当于你下山迈的步子越大，它小，相当于迈着小碎布下山。它决定了学习效率，关于它的制订规则以后再讲。
>
> 4. 关于当前 θ 的偏导数项
>    $$
>    \frac{\partial J(\theta_{0},\theta_{1})}{\partial\theta_j} (j = 0,1)
>    $$

最后还有一个细节，我们要更新这两个 θ ，它们是**同时更新**的，而不是顺序更新的

![](https://images.gitee.com/uploads/images/2020/0418/095424_506023b9_5550632.png)

左侧是正确的梯度下降，右侧你会发现，顺序计算时，到 temp1 时，θ0 已经变了，函数也就变了，这就会造成一些奇奇怪怪的结果。

在下一节中，咱们来感受一下这个公式中各个部分的意义。

#### 3.2.5 梯度下降总结

为了方便描述，依旧假设代价函数是关于参数 θ 的一元函数。
$$
J(\theta_{1})
$$
我们按照梯度下降算法，我们要求的式子就变成了：
$$
\theta_{1} := \theta_{1} -\alpha \frac{d}{d_{\theta_{1}}}
$$
由于这个代价函数是一元函数，在数学定义中就是导数。

假设我们有如下这样一个代价函数图像，现在我们要找到函数的最小值时，参数 θ 的值。根据梯度下降算法，假设 θ 初值为 橙色点位置。众所周知，一元函数导数的几何意义表示为该点处切线斜率。下图绿色虚线的切线为正值， θ1 - 正值 * 正值，总会使 θ1 减小的，最终找到局部最小值点。同理如果 θ 的初始值在函数左侧，那么切线斜率为负值，相当于在**原值绝对值**基础之上减小，直至局部最小值点。

![](https://images.gitee.com/uploads/images/2020/0501/121249_3050903e_5550632.png)

如果导数项(偏导数项)代表了下降的幅度【导数值越大，θ 减小或增加地越多】，那么**学习率**又有什么实质性的作用呢？

首先，**学习率**是一个正实数，无外乎就两种特殊的取值范围：[0,1],[1,正无穷]

> [0,1]：等于在导数项前乘了一个小数，使得算法收敛至局部最小时速度变慢
>
> [1,正无穷]：等于在导数项前乘了一个扩大项，使得收敛速度变快，但是可能出现以下问题

![](https://images.gitee.com/uploads/images/2020/0503/103820_428bfb81_5550632.png )



由于学习率过大，导致直接“超出”局部最小值，导致无法收敛。因为**收敛条件就是导数为零的时候**，**只有在局部最小值【一个点】处的导数为0**


<br>

### 3.3 线性回归模型算法实现

我们之前讲了，两大块内容：

1. 梯度下降算法
2. 线性回归模型

![](https://images.gitee.com/uploads/images/2020/0503/104619_64ca995f_5550632.png )

把梯度下降运用到代价函数中：

![](https://images.gitee.com/uploads/images/2020/0503/114419_25dce2fb_5550632.jpeg)

以上是我手推的过程，懒得看过程的，直接用结果也可以：

![](https://images.gitee.com/uploads/images/2020/0503/114604_b5ba2575_5550632.png)

我们刚刚写出的梯度下降算法，还有一个别名，叫做**“Batch”梯度下降算法**，**它每次计算都需要遍历整个训练集**。采用此梯度下降算法的结果，如下动图所示，左侧为假设函数，右侧为代价函数，右侧红黑色动点，代表每一步的参数收敛过程。

![](https://images.gitee.com/uploads/images/2020/0503/113817_d54c38b2_5550632.gif)

至此，恭喜你已经学会了第一个机器学习算法。由于采用迭代的方式进行参数更换过于耗时，我们需要更换参数迭代的方式，使用线性代数中的**正规方程组方法**优化算法效率。

<br>

## Part 4 线性代数-优化梯度下降算法



### 4.1 矩阵与向量

#### 4.1.1 矩阵 (Matrix)

矩阵，学过线性代数的人可能都知道是啥。为了方便理解，我们统一把矩阵理解成：

**一个长方形的数组**，矩阵名称通常用**大写字母**进行表示，小写字母通常用于表示矩阵内的元素或者是向量。
$$
A_{2×3} = \left[              
\begin{array}{lcr}     
a & b & c \\        
d & e & f 
\end{array}       
\right]
$$
这个矩阵是**2行3列**的，所以我们也管矩阵A叫做**一个2×3的矩阵**。矩阵中元素的访问如下：
$$
A_{11} = a,A_{12} = b
$$

#### 4.1.2 向量 (Vector)

只有一行的矩阵，我们成为行向量，同理，只有一列的向量我们成为列向量。在机器学习中我们默认使用列向量。
$$
y = \left[              
\begin{array}{lcr}     
a \\        
b\\
c\\
d\\
\end{array}       
\right]
$$
向量是有维度的，向量内部有几个元素，它就是几维向量，比如上面这个就是一个**4维(列)向量**。

我们有两种方式访问向量，一种是从1开始访问，另一种是从0开始访问，就像不同编程语言规定的数组第一个元素的下标一样。
$$
y_0 = a,y_1 = b...
$$

$$
y_1 = a,y_2 = b...
$$

在线性代数中我们使用以1为起点的向量访问法

在机器学习中，为了方便运算我们采用以0起点的向量访问法



### 4.2 矩阵运算



#### 4.2.1 加法和标量乘法

**同型(行数列数相同的)矩阵**对应位置相加即可
$$
A_{2×3} = \left[              
\begin{array}{lcr}     
1 & 2 & 3 \\        
2 & 3 & 0.5 
\end{array}       
\right]
$$

$$
B_{2×3} = \left[              
\begin{array}{lcr}     
3 & 2 & 1 \\        
1 & 4 & 0.5 
\end{array}       
\right]
$$

$$
A_{2×3} + B_{2×3} =\left[              
\begin{array}{lcr}     
4 & 4 & 4 \\        
3 & 7 & 1 
\end{array}       
\right]
$$

**矩阵数乘**：所有元素都成乘那个数即可
$$
3*A_{2×3} = 3*\left[              
\begin{array}{lcr}     
1 & 2 & 3 \\        
2 & 3 & 0.5 
\end{array}       
\right] =\left[              
\begin{array}{lcr}     
9 & 6 & 9 \\        
6 & 9 & 1.5 
\end{array}       
\right]
$$
减法和除法同理。

#### 4.2.2 矩阵向量乘法

在矩阵之间进行乘法之前，先看特例，**矩阵乘向量**
$$
A_{3×2} = \left[              
\begin{array}{lcr}     
1 & 3 \\        
4 & 0 \\
2 & 1
\end{array}       
\right]
$$

$$
y = \left[
\begin{array}{lcr}
1\\
5\\
\end{array}
\right]
$$

$$
z = A_{3×2}*y_2 = \left[
\begin{array}{lcr}
16\\
4\\
7
\end{array}
\right]
$$

$$
z_1 = A_{11} *y_1 + A_{12}*y_2\\
z_2 = A_{21} *y_1 + A_{22}*y_2\\
z_3 = A_{31} *y_1 + A_{32}*y_2
$$

通过观察得出，都是**第x行 * 向量的加和**,因为向量只有一列，所以就是**在对应位置，矩阵第x行*向量第1列加和**

#### 4.2.3 矩阵间乘法

矩阵相乘的前提必须是满足一下条件的矩阵
$$
C_{i×j} = A_{i×k} * B_{k×j}
$$
即**第一个矩阵的列数必须等于第二个矩阵的行数**

运算法则相当简单，**第一个矩阵的第 x 行 * 第二个矩阵的第 x 列，对应相乘再相加**
$$
A_{2×3} = \left[              
\begin{array}{lcr}     
1 & 3 & 2 \\        
4 & 0 & 1 
\end{array}       
\right]
$$

$$
B_{3×2} = \left[              
\begin{array}{lcr}     
1 & 3 \\        
0 & 1 \\
5 & 2
\end{array}       
\right]
$$

$$
C_{2×2} = A_{2×3} * B_{3×2} =\left[              
\begin{array}{lcr}     
11 & 10 \\        
9 & 14 \\
\end{array}       
\right]
$$

$$
C_{11} = A_{11} * B_{11} + A_{12}*B_{21} + A_{13} * B_{31}\\
=1*1 +3*0 + 2*5\\
=11
$$



```c++
int m1[100][10],m2[10][100];
for(int i = 0;i<n;i++)//第一个矩阵的行标
{
    for(int j = 0;j<k;j++)//第二个矩阵的列标
    {
        int sum = 0;
        for(int l = 0;l<m;l++)//对应位置相乘再相加
        {
            sum += m1[i][l]*m2[l][j];
        }
        ans[i][j] = sum;
    }
}
```

![](https://images.gitee.com/uploads/images/2020/0505/150018_b874198b_5550632.png)

通过矩阵乘法，我们可以快速地计算出在三种不同地假设函数下房价的预测值

#### 4.2.4 矩阵乘法性质

**矩阵间乘法不满足乘法交换律**：A*B != B * A

**矩阵间乘法满足乘法结合律**：（A * B）* C = A * （B * C）

在实数乘法中我们有一个特殊的单位元：**1**，因为 **1** 乘任何数都为那个数本身，同理在矩阵乘法中，我们存在**单位矩阵 E**，它保证了所有与它相乘的矩阵，还是那个矩阵本身
$$
E_{2×2} =\left[              
\begin{array}{lcr}     
1 & 0 \\        
0 & 1
\end{array}       
\right]
$$

$$
E_{3×3} =\left[              
\begin{array}{lcr}     
1 & 0 &0 \\        
0 & 1 &0 \\
0 & 0 &1
\end{array}       
\right]
$$

总之，单位矩阵就是**主对角线上值都为1，其余位置都为0的特殊矩阵**，而且单位矩阵行数和列数相等【方阵】，对于单位矩阵，我们可以对其进行交换。
$$
A_{3×3} * E = E * A_{3×3}
$$

#### 4.3.5 逆和转置

**矩阵的逆 (Inverse)**

在实数运算中我们会找到任意一个非零数的倒数，使得该数数乘其倒数的值为单位元 **1**
$$
3*\frac{1}{3} =3*3^{-1} =1\\
2*\frac{1}{2}=2*2^{-1} = 1\\
13*\frac{1}{13}=13*13^{-1} = 1\\
$$
同理，在矩阵运算中，我们也有这种性质，我们管这种矩阵叫做**逆矩阵**，它被记为：
$$
A^{-1}
$$
逆矩阵和该矩阵本身有着如下关系：
$$
A^{-1}A = AA^{-1} = E
$$


举个例子：
$$
A = \left[              
\begin{array}{lcr}     
3&4 \\        
2&16
\end{array}       
\right]
\\
A^{-1} = B =  \left[              
\begin{array}{lcr}     
0.4&-0.1 \\        
-0.05&0.075
\end{array}       
\right]
\\
AB = BA  =E
$$
我们把**零矩阵【矩阵元素全为零】**这类**没有逆**的矩阵称为**奇异矩阵**。

**矩阵的转置 (Transpose)**

矩阵的转置记作：
$$
A^{T}
$$
转置运算也很简单，就是**行列互换**例如：
$$
A = \left[              
\begin{array}{lcr}     
3&4&5 \\        
2&1&6
\end{array}       
\right]
\\
A^{T} = \left[              
\begin{array}{lcr}     
3 & 2\\
4 & 1\\
5 & 6\\
\end{array}       
\right]
$$

<br>

## Part 5 多元线性回归

之前关于房价预测，只通过一个特征值**面积**进行房价预测，而如今，我们需要不止一个特征进行预测，例如添加**卧室数量**，**房屋使用时间**，**层数**等等特征值，以确保准确性。比如：

![](https://images.gitee.com/uploads/images/2020/0508/192434_2b3e87e7_5550632.png)

我们规定以下字母的含义
$$
m:训练集训练数据总数\\
n:特征值的数量\\
x^{(i)}:训练集的第 i 条数据\\
x^{(i)}_j:训练集的第 i 条数据的第j个特征值
$$
以上图为例：
$$
x^{(2)} = \left[              
\begin{array}{lcr}     
1416\\
3\\
2\\
40\\
232
\end{array}       
\right]
\\
x^{(2)}_2 = 2
$$
由于我们的特征值数量变多了，所以原来的假设函数：
$$
h_\theta(x) = \theta_0+\theta_1 x
$$
已经不合适了，因为它只能包含一个自变量。

所以我们把假设函数写为通式就变成了：
$$
h_\theta(x) = \theta_0+\theta_1 x_1+...+\theta_n x_n
$$
由于这个式子太长了，我们简化其写法，改成向量相乘的形式：
$$
假设x_0恒等于1\\
\theta = \left[              
\begin{array}{lcr}     
\theta_0\\
\theta_1\\
\theta_2\\
.\\.\\.\\
\theta_n\\
\end{array}       
\right]
x = \left[              
\begin{array}{lcr}     
x_0\\
x_1\\
x_2\\
.\\.\\.\\
x_n\\
\end{array}       
\right]\\
h_\theta(x) = \theta^{T}x = \theta_0x_0+\theta_1 x_1+...+\theta_n x_n
$$

### 5.1 多元梯度下降法

我们如今要推导出n个θ的梯度下降算法，由于梯度下降是在求θ的偏导数，所以，我们所谓的多元指的就是多模型参数θ。之前我们推导的梯度下降算法，是单维度【面积】的梯度下降算法，而如今我们的维度增加了，1个x对应2个模型参数θ，2个x对应3个模型参数θ……换句话说，参数θ增加了。

我们讲新的假设函数带入，代价函数中：
$$
J(\theta) = \frac{1}{2m}\sum_{i = 0} ^m(h_\theta (x^i) - y^i )^2
$$
得到梯度下降算法：
$$
Repeat\{\\
\theta_j := \theta_j-\alpha\frac{\partial }{\partial\theta_j}J(\theta_0,\theta_1...\theta_n)\\
j = (0,1...n)\\
\}
$$
由于之前的假设：
$$
x^{i}_0 = 1
$$
我们可以对应单特征时，求模型参数偏导时的情况：

![](https://images.gitee.com/uploads/images/2020/0510/100856_5031c2c2_5550632.png)

如此，我们就得到了多元梯度下降算法



### 5.2 多元梯度下降-特征缩放

为了提高梯度下降的效率，我们才会进行特征缩放。我们以一个二元特征为例，进行说明：

![](https://images.gitee.com/uploads/images/2020/0510/103938_24e97ca1_5550632.png)

忽略参数θ0，我们假设只有两个参数θ1和θ2，上图是代价函数的等高线图。左图，表示的是两个特征值取值范围相差很大时，做出的代价函数图像。

> 特征值x1：房屋面积取值范围 [0,2000]feet²
>
> 特征值x2：卧室数量 [1,5] 

可以看到，由红线模拟的梯度下降算法过程，下降速度十分缓慢。而右图两个特征值**都除以了它们的最大值**，使得它们缩放到了相接近的**取值区间**，让等高线图的分部更加均匀，使得梯度下降时，使用更少的次数得出相同的结果。

一般来讲，只要让各个特征值的取值范围近似同就可以了，最好是缩放到[-1,1]之间：
$$
-1\leq x_i \leq1
$$
但是，缩放成以下结果我们也是可以接受的：
$$
0 \leq x_1\leq 3\\
-2\leq x_2 \leq 0.5
$$
说到底，我们是**通过缩放特征值取值范围的方式，减少梯度下降的计算次数，提高算法效率**

#### 5.2.1 均值归一化

这同样是一种缩放方式，比起粗暴地除以最大值不同，这种方法显得更优雅：
$$
μ:均值\\
σ:标准差\\
Z= \frac{x−μ}{σ}
$$
当然了，计算机科学不是纯粹的数学，我们没有必要那么精确，毕竟我们要解决实际问题，而一些实际问题多多少少没有那么严谨。事实上，我们可以用**极差(最大值-最小值)**来代替标准差。

把我们之前的例子拿过来，其实可以这样写：

![](https://images.gitee.com/uploads/images/2020/0510/110024_d9d39569_5550632.png )

这样我们就近似地把两个特征值的范围缩放成相同取值范围了。



### 5.3 多元梯度下降-学习率

为了提高梯度下降的效率，设置合适的学习率也是十分重要的。下面是代价函数收敛至局部最小的迭代次数和最小值的图像：

![](https://images.gitee.com/uploads/images/2020/0516/111407_b08b3f6f_5550632.png )

会发现，当迭代至300，400次时，代价函数已经相对收敛至最小值了，正常的算法会呈现出这样的关系曲线。而，有时往往会出现以下的关系曲线，这都是**学习率过大导致的,应当调小学习率**：

![](https://images.gitee.com/uploads/images/2020/0516/111816_196c60d7_5550632.png)

### 5.4 特征和多项式回归

特征，就是假设函数中的自变量，这一节讲的是**如何构造假设函数**，之前我们都是采用直线对训练集进行拟合，如今我们想用曲线来拟合数据，进而追求预测的准确性。

还是以房价为例：

![](https://images.gitee.com/uploads/images/2020/0516/112948_2d830849_5550632.png)

第一种特征的选择方式是这样的：

> 1. frontage：房子前的土地长
> 2. depth：土地纵深

第二种是将两种特征聚合成矩形面积，进而变成单一特征：

> 1. area = frontage*depth

特征的数量不同，自然假设函数的形式就不同。不过再怎么说，以上两种选择都还是没有脱离用直线拟合的命运，

小学二年级我们就学过**泰勒公式**，我们可以知道通过使用**高阶多项式**可以近似函数。

![](https://images.gitee.com/uploads/images/2020/0516/113549_6e81bd72_5550632.png)

同理，在机器学习中，如果你不想光用直线来做模型，我们也可以采用多项式进行建模。

![](https://images.gitee.com/uploads/images/2020/0516/113807_2fbfce19_5550632.png)

对于，**单一特征**，我们有如上图的两种假设函数。

只用到二次方，它还是个抛物线，有可能超出对称轴后导致值变小，说人话就是，**面积越大，房价越低**

三次方的函数图像和现实结果很像，所以我们采用三次函数进行拟合。
$$
x_1 = (size)\\
x_2 = (size)^2\\
x_3 = (size)^3\\
此时，如果size的取值为[0,1000]m^2\\
x_3 ∈ [0,10^9]
$$
此时，特征缩放的重要性就体现出来了。

而且对于这个问题，还有其它好多种建模方式，例如：

![](https://images.gitee.com/uploads/images/2020/0516/114543_f7bac632_5550632.png)

对于特征选择，现在我们的工作就是尽量贴合实际自由选择，尽量不再用直线拟合。在以后的内容中，有算法可以来自动选择特征。

### 5.5 正规方程 (Normal equation)

之前我们使用梯度下降算法，采用**迭代**的方式一步一步找最小值

![](https://images.gitee.com/uploads/images/2020/0517/182641_c964752f_5550632.png)

有没有一种方式可以直接算出参数 θ ，而不必迭代计算呢？

我们假设代价函数看成一个关于 θ 的二次函数：
$$
J(\theta) = a\theta^2+b\theta+c
$$
二次函数求最值问题，我们只需要令导数为零，求出驻点即可。对于含有 n 个特征的 n 元函数，我们只需要**对每个 θ 求偏导数令其为零，联立求解**，就能得出 θ 的最小值，这就是正规方程所做的事情。

![](https://images.gitee.com/uploads/images/2020/0517/183208_5642237f_5550632.png)

我们举一个例子来看看正规方程是如何运作的

![](https://images.gitee.com/uploads/images/2020/0517/183334_1e96ea2a_5550632.png)

假设训练集中只有 4 条数据 (m = 4) ，我们原来有4个代表房子的特征，再加一列 x0 恒等于 1。之后我们要做的就是计算
$$
\theta = (X^TX)^{-1}X^Ty
$$
参数就求出来了，不要问我为什么可以这么求。因为我也不会，工科啦，不要在意太多啦。

[正规方程]([https://baike.baidu.com/item/%E6%AD%A3%E8%A7%84%E6%96%B9%E7%A8%8B/10001812?fr=aladdin](https://baike.baidu.com/item/正规方程/10001812?fr=aladdin))

矩阵X的选取方式很简单，将每一行的特征当作矩阵的每一行，再在第一列前插入 1 即可，向量 y 就是依次的真实值。

正规方程和梯度下降都能求模型参数，那么它们各自有什么优缺点供我们参考选择呢？

**梯度下降算法**

> 缺点：
>
> > 1. 需要调整学习率 α
> > 2. 需要很多次迭代
> > 3. 需要进行特征缩放
>
> 优点：
>
> > 1. 无论有多少特征，都可以在有限的时间内计算出结果，例如 10 ^9 个特征

**正规方程**

> 缺点：
>
> > 1. 可以计算的特征数量有限，一般来说 < 10000 个特征我们都可以选择正规方程法，
> >
> > 因为计算矩阵转置非常耗时间。
> >
> > 2. 使用场景首先，正规方程不适用于一些其他的机器学习算法。
>
> 优点：
>
> > 1. 不需要学习率
> > 2. 不需要进行特征缩放
> > 3. 一次算出答案，无需迭代



#### 5.5.1 矩阵不可逆时的正规方程方法

在正规方程中：
$$
\theta = (X^TX)^{-1}X^Ty
$$
我们会计算
$$
(X^TX)^{-1}
$$
在小学二年级就学过的线性代数中，我们知道，有些矩阵是不可逆的，也叫做**奇异矩阵**。在这里我只想说一说造成这种现象的原因以及解决办法。

> **特征选择重复或线性相关**
>
> 例如，在预测房价时，我选择两个特征一个是 feet²，另一个是 m²，很显然，它们的意义在本质上都是描述描述面积，而且 1m = 1.38feet。这两个量线性相关，所以可能会出现问题。
>
> **特征值选择过多，训练集数目过少**
>
> 在一个m = 10 的训练集中，有1000个特征值，在加上 x_0 的话那就是一个 m×（n+1）的矩阵，此时也可能出现问题。

如果是第一种问题，删除任意一个特征就好，如果是第二种问题，要么删除一些无关紧要的特征，要么使用之后所学习的**正规化(regularization)**方法。


### 5.6 题外话-线性回归模型的数学原理

在实际工程应用中，我们总会出现这样一种情况**已知一些离散的观测点，想要求出一个整体的函数规律**。举个小例子：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0123/113908_c4026501_5550632.png "屏幕截图.png")

这乍一看这跟机器学习没什么关系，但回归数学，本质却是一样的。它们的目的都是对数据集拟合出一条曲线。对上述问题进行分析，不难发现，这是一个**数据规模为5条记录，假设函数为 l = θ0 + θ1*t，的线性回归模型 **。对于这样的问题我们往往这样处理：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0123/114347_94a711ef_5550632.png "屏幕截图.png")

接着，我们对Q求最小值，注意**此时Q是关于模型参数θ的函数，其它量已知。将其转换为多元函数求最值的问题。**对于这种问题，一般的数学做法就是**求偏导数，联立偏导数方程，求驻点**。

![输入图片说明](https://images.gitee.com/uploads/images/2021/0123/114921_79266689_5550632.png "屏幕截图.png")

这种方法在数学中叫做**最小二乘法**。而且很显然，当特征向量升维，假设函数复杂的时候，手算偏导数的方程组不现实，此时我们就分出来了两条路，一种是基于计算机的强大算力，对模型进行若干次迭代的**梯度下降法**，另一种是对方法本身进行优化，通过线性代数的方式得到的**正规方程组法**。

同时补充一下我对于梯度下降法这个名词的一些猜测，梯度在数学中，其实就是**多元函数偏导数所构成的向量**。由于此时我们不再计算梯度等于零时的值，那么我们只能尽量让其缩小了。这很可能就是梯度下降这个名词背后的故事。

<br>

## Part 6 Octave编程

讲了这么多，是不是也想上手写一个Demo验证一下所学，接下来我们就开始学习 Octave 进行机器学习的实践之旅吧。

### 6.1 基本数学运算

![](https://images.gitee.com/uploads/images/2020/0520/202201_ac4ea9e7_5550632.png)

同 C 语言

### 6.2 逻辑运算

同 C 语言

**注释为 %**

### 6.3 声明矩阵和向量

语法：

每一行用 “;” 隔开

```octave
matrix = [...;...;...]
```

```octave
y = 1:0.1:2 %以1开始步长为0.1到2的向量
```



![](https://images.gitee.com/uploads/images/2020/0520/203159_3e1c86d8_5550632.png )

![](https://images.gitee.com/uploads/images/2020/0520/203517_2846935b_5550632.png)

### 6.4 从文件中读写矩阵

现在我的硬盘上有如下两个文件：

![](https://images.gitee.com/uploads/images/2020/0523/193842_0cb13551_5550632.png )

我们的目的是把它们读入到Octave的工作内存中。第一步就要切换文件路径，**命令是 cd**，和Windows的路径切换语法一样。接着可以通过**ls**语法查看当前目录下的文件

![](https://images.gitee.com/uploads/images/2020/0523/194124_2fdeb6fa_5550632.png)

接着我们通过使用**load 文件名**的方式就可以导入到Octave中了。此时可以通过**who**，和**whos**命令查看Octave工作空间下的所有变量信息

![](https://images.gitee.com/uploads/images/2020/0523/194442_74e76c21_5550632.png)

其中 **who** 只查询变量名，**whos**可以查出变量的具体信息。

如果我们想单独查看变量的属性，**矩阵推荐使用size(...)，向量推荐使用length(...)命令**

![](https://images.gitee.com/uploads/images/2020/0523/194700_a25d3b5f_5550632.png )

它们会告诉你矩阵的形状和向量的维度。接着我们就要安排如何访问矩阵和修改元素了。

首先，**Octave中矩阵下标从 1 开始**，切记，切记。

![](https://images.gitee.com/uploads/images/2020/0523/195022_4fa7353c_5550632.png)

访问方式很简单：

``` 
矩阵名(下标,下标)
```

修改方式也很简单：

![](https://images.gitee.com/uploads/images/2020/0523/195243_bdc69b08_5550632.png)

之后就是存储了，我们的第一种写法是：

```
save 文件名.mat 
```


![](https://images.gitee.com/uploads/images/2020/0523/195849_92fc2b29_5550632.png)

![](https://images.gitee.com/uploads/images/2020/0523/195926_fb81e54f_5550632.png)

目录下会生成一个压缩的二进制文件

重新打开加载到工作内存中时和打开文件的语法一样

![](https://images.gitee.com/uploads/images/2020/0523/200202_26de6ab7_5550632.png )

第二种写法是存成人能看懂的方式

```
save hello.txt -ascii
```

![](https://images.gitee.com/uploads/images/2020/0523/200714_8dbda46a_5550632.png)

![](https://images.gitee.com/uploads/images/2020/0523/200752_4a56ba8d_5550632.png)

更多关于 save 命令的解释可以使用 **help 命令名**来具体查看，这里就不赘述了。

差点忘了，还有一个就是变量删除：

![](https://images.gitee.com/uploads/images/2020/0523/201043_627c28ba_5550632.png)

### 6.5 数据计算

#### 6.5.1 矩阵相关计算

![](https://images.gitee.com/uploads/images/2020/0524/161748_6a980835_5550632.png)

![](https://images.gitee.com/uploads/images/2020/0524/162104_546ca44b_5550632.png)

![](https://images.gitee.com/uploads/images/2020/0524/162111_a993cef8_5550632.png)

![](https://images.gitee.com/uploads/images/2020/0524/162118_bfbfcd98_5550632.png)

从上到下依次解释：

```octave
A' %A的转置
A. *E %A中对应元素与单位矩阵E相乘
% . 代表矩阵内的元素
```

![](https://images.gitee.com/uploads/images/2020/0524/163434_741ba5f2_5550632.png)

```octave
A = magic(9) %生成一个9*9的魔幻矩阵（每行每列，对角线的和都相等）
sum(A,1) %按列求和
sum(A,2) %按行求和
```

![](https://images.gitee.com/uploads/images/2020/0524/163813_822d997d_5550632.png)

```octave
sum(A.*E) %A中对应元素乘单位矩阵，即只保留对角线上的元素，并按列求和
sum(sum(A.*E)) %对角线的和
```

![](https://images.gitee.com/uploads/images/2020/0524/164110_1ebcd21d_5550632.png)

```octave
temp = pinv(A) %矩阵求逆
```



#### 6.5.2 常用函数

![](https://images.gitee.com/uploads/images/2020/0524/164800_9cd10783_5550632.png)

> rand(n)：生成一个 n*n的随机矩阵
>
> find(...)：返回符合条件的行和列

![](https://images.gitee.com/uploads/images/2020/0524/165102_c71c05a2_5550632.png)

> max()，min()：找每列的最大最小值
>
> A < 5：返回一个布尔矩阵表示判断结果

![](https://images.gitee.com/uploads/images/2020/0524/165432_a0c5962c_5550632.png)

> floor(...) ：向下取整
>
> ceil(...)：向下取整

![](https://images.gitee.com/uploads/images/2020/0524/165611_59874ae4_5550632.png)

> prod(...)：所有元素相乘



### 6.6 数据可视化

学会将各种函数可视化，有助于更直观地学习机器学习算法，在这一节中我们介绍Octave中数据可视化的方式。

![](https://images.gitee.com/uploads/images/2020/0525/202956_85b345b3_5550632.png)

```octave
clear
x = [0:0.01:0.98]; %生成一个初值为0，步长为0.01的到0.98的一维数组(向量)
y1 = sin(2*pi*4*x);%生成正弦函数
y2 = cos(2*pi*4*x);%生成余弦函数
plot(x,y1); %以x和y1为数据画图
```

这种画图方式只能保留一个函数的图像，$\color{red}{为了让两个函数同时存在}$我们可以这么做：

![](https://images.gitee.com/uploads/images/2020/0525/203656_70436049_5550632.png)

**hold on** 方法可以保留两个函数图像在同一个图里，但是没有横纵坐标，图例等等，就让人看得很难受。

![](https://images.gitee.com/uploads/images/2020/0525/204551_4eb151dc_5550632.png)

```octave
plot(x,y1)
hold on
plot(x,y2,'r')%顺带改个颜色
xlabel('time')%横坐标含义
ylabel('value')
legend('sin','cos') %给不同图像起名
title('myPlot') %给图像起标题
print -dpng 'myPlot.png' %存储图像为.png格式
close %关闭图像
```

既然可以把两个图像放到一张图中，自然也就可以分别呈现：

![](https://images.gitee.com/uploads/images/2020/0525/205058_4151c1a1_5550632.png)

```octave
figure(1);plot(x,y1,'g');
figure(2);plot(x,y2,'r');
```

我们还可以这样操作：

![](https://images.gitee.com/uploads/images/2020/0525/205419_32d18fa7_5550632.png)

```octave
subplot(1,2,1);
plot(x,y1);
subplot(1,2,2);
plot(x,y2);
```

我们还可以通过**axis**来调整x，y轴的单位长度：

![](https://images.gitee.com/uploads/images/2020/0525/205609_7552332d_5550632.png)



### 6.7 控制语句-if-for-while

```octave
v = zeros(10,1);%10维列向量
for i=1:10,
	v(i) = 2^i;
end;
```

![](https://images.gitee.com/uploads/images/2020/0528/202054_50285d83_5550632.png)

```octave
i = 1;
while i<=5,
	v(i) = 100;
	i++;
end;
```

![](https://images.gitee.com/uploads/images/2020/0528/202259_83b73d2f_5550632.png)

```octave
i = 1;
while true,
	v(i) = 999;
	i++;
	if i == 6,
		break;
	end;
end;
```

![](https://images.gitee.com/uploads/images/2020/0528/202745_44c28e81_5550632.png)

```octave
v = zeros(10,1);
v(2) = 10010;
if v(2) == 9999,
  disp('GoodBye World');
elseif v(2) == 10010,
  disp('Hello World');
else
  disp('There is no world');
end;
```

![](https://images.gitee.com/uploads/images/2020/0528/203730_230aeb89_5550632.png)

### 6.8 定义函数

Octave中定义函数很特殊，一个函数是一个.m文件，$\color{red}{调用函数时一定要看好文件路径}$,文件内基本语法是这样的：

```octave
function 返回值 = 函数名(参数1,参数2,...)
  方法体
```

Octave中可以一次返回多个值，这一点很特殊。

![](https://images.gitee.com/uploads/images/2020/0528/204214_c56a669a_5550632.png)

```octave
%addAndsub文件内容
function [x,y] = addAndsub(a,b)
  x = a+b;
  y = a-b;
```

![](https://images.gitee.com/uploads/images/2020/0528/205159_4d61dd50_5550632.png)

基于上面所学，让我们快速地写一个Demo来测试一下掌握语法情况。

我现在有一张图，我要根据这张图做出不同θ下的的代价函数

![](https://images.gitee.com/uploads/images/2020/0528/205644_3b350c6b_5550632.png) 

![](https://images.gitee.com/uploads/images/2020/0528/210654_60dc1132_5550632.png )

```octave
function J = costFunction(X,y,theta)
  % matrix vector thetaMatrix
  m = size(X,1);
  prediction = X * theta;
  sqrErrors = (prediction - y).^2;
  J = 1/(2*m) * sum(sqrErrors); 
endfunction %可加可不加
```

之前说过，x_0 恒等于 1，对吧。以本题为例，预测结果就是一个3维列向量对吧 [1;2;3]，它和真实值[1;2;3]没有偏差，所以代价函数返回值为 0

我们改变参数 θ，再测一组：

![](https://images.gitee.com/uploads/images/2020/0528/211208_5d28207f_5550632.png)
$$
J = \frac{1}{2*3}*(1^2+2^2+3^2) = 14 /6 = 2.33...
$$

### 6.9 向量化

向量化这个名词可能很陌生但是大家之前其实已经用过了，我们假设，假设函数为如下所示：
$$
h_\theta(x) = \sum_{j = 0} ^n\theta_jx_j
$$
我们可以把θ，x当作向量：
$$
\theta = \left[              
\begin{array}{lcr}     
\theta_0\\
\theta_1\\
\theta_2\\

\end{array}       
\right]
\\
x = \left[              
\begin{array}{lcr}     
x_0\\
x_1\\
x_2\\

\end{array}       
\right]
\\
$$
所以假设函数就可以写成：
$$
h_\theta(x) = \theta^Tx
$$
换成编程语言来对比两种方法实现的话，就是这样的结果：

```octave
%不采用向量化的结果
prediction = 0.0;
for i = 1:n+1,
  prediction += theta[i]*x[i];
endfor
%采用向量化的结果
prediction = theta'*x;
```

现在，让我们向量化一个更复杂的式子，还记得梯度下降算法吗？我们试试能不能把它也向量化。首先我们回顾一下2个参数的梯度的下降算法以及它们推导之后的结果：

![](https://images.gitee.com/uploads/images/2020/0503/104619_64ca995f_5550632.png)

![](https://images.gitee.com/uploads/images/2020/0503/114604_b5ba2575_5550632.png)

![](https://images.gitee.com/uploads/images/2020/0528/215232_f2a990c9_5550632.png)

这里罗列了**训练集数目为 m 的，具有n元参数θ的代价函数的梯度下降算法**的部分示意。接下来就来思考如何向量化吧。

![](https://images.gitee.com/uploads/images/2020/0528/221023_5a780998_5550632.png)
$$
x^{(1)} = \left[              
\begin{array}{lcr}     
x_0^{(1)} = 1\\
x_1^{(1)} = 2\\
x_2^{(1)} = 12\\
...
\end{array}       
\right]
$$


梯度下降的目的是最小化代价函数，找出所有的模型参数θ，所以：$\color{red}{θ可以构成一个列向量}$，而学习率α和m又是一个常数，**每一行特征值又可以看成一个特征列向量**，所以第一步我们可以把式子化简成：
$$
x^{(i)} = \left[              
\begin{array}{lcr}     
x_0^{(i)}\\
x_1^{(i)}\\
x_2^{(i)}\\

\end{array}       
\right]
\\\theta := \theta - \alpha*\frac{1}{m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x^{(i)}
\\向量 := 向量-数*数*求和(数*向量)
$$
由于数×向量还是向量，所以,再化简成：
$$
向量 := 向量-数*数*向量\\
向量 := 向量-数*向量\\
\theta := \theta -\alpha*\delta
$$
最终，我们就完成了一个梯度下降算法的向量化。

<br>

## Part 7 Logistic 回归算法

### 7.1 分类问题的引出

之前，我们学习了回归问题的一大经典算法，现在我们要开始学习**分类问题**的一大经典算法了。我们首先看几个分类问题的实例：

> 判定邮件是否为垃圾邮件
>
> 判定肿瘤是否为恶性肿瘤
>
> ...

这里我们的算法输出值**由连续的值变成了离散的值**，即：
$$
y∈\{0,1\}\\
0 =>负类\\
1=>正类
$$
当然了，分类问题可不只是只能分2类，当然可以分n类，为了方便学习，我们从二元分类开始学起。

![](https://images.gitee.com/uploads/images/2020/0531/194005_e45563bf_5550632.png)

这是一个**通过肿瘤大小对恶性肿瘤进行分类**的例子。

其中，**1 代表检查呈阳性(恶性肿瘤)，0 代表检查呈阴性(良性肿瘤)**

如果我们用我们之前的线性回归来解决这个问题，可能会得到这样一条假设函数：

![](https://images.gitee.com/uploads/images/2020/0531/194329_b1a5a254_5550632.png)

![](https://images.gitee.com/uploads/images/2020/0531/194412_9658376c_5550632.png)

我们可以假设分类器的输出阈值为**0.5**，这样看来，这个分类器是可以正确地区分肿瘤类型的。但是当训练集发生变化，我们可能会得到以下结果：

![](https://images.gitee.com/uploads/images/2020/0531/194721_444d5ad6_5550632.png)

这条蓝色的函数，是一条很糟糕的曲线，同样在0.5处的阈值，它却把阳性肿瘤分类成了阴性肿瘤。而且通过线性回归算法做分类问题，最后假设函数的输出值可能远大于1，或远小于0。

由此看出，**线性回归算法不能直接套用在分类算法上，由此我们要探究一种新的算法进行分类**。（当然不用自己探究，之后直接给出）



### 7.2 二元分类问题的假设函数

在线性回归中我们构建了假设函数:
$$
h_\theta(x) = \theta^Tx
$$
而且在之前的分析中我们得知，线性回归的假设函数不能直接作用于分类问题上，那么构建分类问题的假设函数就是现在的重要目标。

#### 7.2.1 Sigmoid function / Logistic function

分类问题采用假设函数的是**Sigmoid**函数(Logistic函数)

函数的定义长这样：
$$
h_\theta(x) = g(\theta^Tx)\\
g(u) = \frac{1}{1+e^{-u}}\\
h_\theta(x) = \frac{1}{1+e^{\theta^Tx}}
$$
![](https://images.gitee.com/uploads/images/2020/0604/192615_e1b69cf0_5550632.png)

Sigmoid函数的图像长成这个样子，通过它，我们就可以实现一个二元分类器了。

这个函数的函数值$\color{red}{永远在0，1之间}$，我们可以这样解释这个函数值：
$$
P(y=1|x,\theta):在特征向量为x，模型参数为\theta时，结果为1的概率\\
P(y=1|x,\theta)+P(y=0|x,\theta) = 1
$$
以判断肿瘤是否为恶为例：
$$
x = \left[              
\begin{array}{lcr}     
x_0\\
x_1
\end{array}       
\right]
=\left[              
\begin{array}{lcr}     
1\\
肿瘤大小
\end{array}       
\right]\\
h_\theta(x) = 0.7 \\
有70\%的概率是恶性肿瘤
$$

#### 7.2.2 分类问题的代价函数

![](https://images.gitee.com/uploads/images/2020/0605/174042_80c4ab72_5550632.png)

首先，我们来回顾一下分类问题中的已知条件，然后再捋一捋接下来要干什么。

到此为止介绍的机器学习算法无外乎都要经过4个步骤：

> 1. **构造假设函数**
>
> 2. **构造代价函数**
> 3. **梯度下降代价函数**
> 4. 模型参数回代

我们之前讨论过了**分类问题**为什么不能直接使用线性回归的假设函数，进而给出了分类问题专用的假设函数**Sigmoid函数**。现在我们要做的就是探寻分类问题的**代价函数**，我们学习的方式和之前类似，咱们先试试原来线性回归的代价函数行不行。
$$
h_\theta(x) = \frac{1}{1+e^{\theta^Tx}}\\
J_\theta(x) = \frac{1}{m}\sum_{i=1}^m\frac{1}{2}(h_\theta(x^{(i)})-y^{(i)})^2\\
$$
在这里，我们把1/2分配到求和号里面去了，这并不影响最终结果。

由于后面一串太长了，为了方便描述我们假设：
$$
Cost(h_\theta(x^{(i)}),y^{(i)}) = \frac{1}{2}(h_\theta(x^{(i)})-y^{(i)})^2
$$
把上标去掉：
$$
Cost(h_\theta(x),y) = \frac{1}{2}(h_\theta(x)-y)^2
$$

$$
J_\theta(x) =\frac{1}{m}Cost(h_\theta(x),y)
$$

现在，我们只要最小化这个代价函数，**理论上就可以得到模型参数θ了**，但是，天下没有这么好的事，事实上我们并不能对这个代价函数进行最小化，这是由于这个函数性质导致的。

由于假设函数h(x)，或者说sigmoid函数，不是一个**线性的函数**，导致整个cost的图像是一个**关于参数θ的非凸函数**，它可能长这样：

![](https://images.gitee.com/uploads/images/2020/0605/180821_2ad451fe_5550632.png)

我抱着严谨的态度(不信邪)，使用随机数随机生成了单特征值的参数θ为1的cost函数，结果它长成这样：

![](https://images.gitee.com/uploads/images/2020/0605/183832_d9fe636d_5550632.png)

咱们都玩过梯度下降算法，梯度下降算法需要一个初始值，然后它就会去找一个局部最小值，然而，对于上述图形而言，它们存在多个局部最小值。也就是说，直接用线性回归的假设函数是不行的。我们要找到一个**关于参数θ的凸函数**。也就是说要长成这样：

![](https://images.gitee.com/uploads/images/2020/0605/181212_7e574104_5550632.png )

庆幸的是，这种函数咱们也不用自己找，数学家已经帮咱们干完这活儿了。

![](https://images.gitee.com/uploads/images/2020/0605/183253_606eff6f_5550632.png )

我们分类问题的代价函数是这样一个二元分段函数，暂且不看函数的意思，我们先看看采用这种代价函数之后的结果图：

![](https://images.gitee.com/uploads/images/2020/0605/184033_b7099781_5550632.png)

和之前的基本条件一样，咱们可以明显地看出这个函数在最小值处有一个收敛的点，好像是1，是的，由于这个函数的θ我预设的就是1，参数θ跑出来是1也没有毛病。这证明了，采用这个函数当分类问题的代价函数是没有问题的。

我们再回头解释一下这个函数：
$$
Cost(h_\theta(x),y) = \left\{
\begin{aligned}
-log(h_\theta(x))\quad if\;y = 1\\
-log(1-h_\theta(x))\quad if\;y = 0\\
\end{aligned}
\right.
$$

$$
Cost(0.7,1)
$$

这个意思就是说，假设函数跑出来的结果是0.7，y = 1，0.7到1之间的代价值为 -log( h(x) )

我们来直观地感受一下，当 y = 1 时的函数图像吧。

![](https://images.gitee.com/uploads/images/2020/0605/185952_6f5ef4d1_5550632.png)

这个函数有个很有趣的性质，**当真实值y = 1 时，且假设函数的预测值为 1 时，函数值无限接近于 0**，这意味着，**预测值和真实值 y = 1之间不用付出代价**，同理如果对于一个真实值为 1 的输出，假设函数预测成了 0，**那么预测值和真实值之间的代价就是无穷大**。

看完了假设函数的其中一半，我们再看它的另外一半：
$$
Cost(h_\theta(x),y)=-log(1-h_\theta(x))\quad if\;y = 0\\
$$
![](https://images.gitee.com/uploads/images/2020/0605/190711_29986289_5550632.png )

当真实值为 0 时，你预测的结果要是 1，那么所付出的代价就是正无穷。

结合两个图像一起看，总结成一句话就是，$\color{red}{预测的越准，算法所付出的代价就越小}$。

#### 7.2.3 简化分类问题的代价函数

之前的代价函数张这样：
$$
J_\theta(x) =\frac{1}{m}Cost(h_\theta(x),y)\\
Cost(h_\theta(x),y) = \left\{
\begin{aligned}
-log(h_\theta(x))\quad if\;y = 1\\
-log(1-h_\theta(x))\quad if\;y = 0\\
\end{aligned}
\right.
$$
我们可以发现，函数Cost是一个分段函数，我们现在希望把分段函数整合成一个新的等价的代价函数，这里我们直接给出，然后证明其正确性：
$$
Cost(h_\theta(x),y) = -y*-log(h_\theta(x))-(1-y)*log(1-h_\theta(x))\\
J_\theta(x) =\frac{1}{m}Cost(h_\theta(x),y)\\
$$
由于我们的输出值只有两个，即y = 0,y = 1。那我们看看当y = 0时，Cost的值为：
$$
Cost(h_\theta(x),0)  = -0*-log(h_\theta(x))-(1-0)*log(1-h_\theta(x))\\
=-log(1-h_\theta(x))
$$
当y = 1 时：
$$
Cost(h_\theta(x),1) = -log(h_\theta(x))
$$
由此可见这个新的代价函数和原来的是等价的，那么按照套路我们就要对这个新的Logistic 回归的代价函数进行梯度下降了。

![](https://images.gitee.com/uploads/images/2020/0606/111059_66ef2190_5550632.png )

#### 7.2.4 Logistic Regression Gradient Descent

![](https://images.gitee.com/uploads/images/2020/0606/111237_2713c6f2_5550632.png)

在我给出答案之前，先呈上我的手推结果：

![](https://images.gitee.com/uploads/images/2020/0606/205910_e27d4578_5550632.png)

![](https://images.gitee.com/uploads/images/2020/0606/205941_f1d957aa_5550632.png )

然后我再直接给出正确的公式吧
$$
\theta_j := \theta_j - \alpha*\frac{1}{m}\sum_{i=1}^m(h_\theta(x^{(i)}-y^{(i)}))*x_j^{(i)}
$$
会惊奇的发现，逻辑回归算法的梯度下降结和线性回归算法的梯度下降值是一样的，然而由于假设函数的不同，注定导致它们不是同一种算法。

#### 7.2.5 高级优化-知道个名称就行了

在之前我们需要计算，代价函数 J(θ) 和 它的偏导数。这里有一些优化算法可以比梯度下降更快地完成工作。

![](https://images.gitee.com/uploads/images/2020/0611/184507_80ece889_5550632.png)

它们是：

1. 共轭梯度法(Gradient descent)
2. BFGS
3. L-BFGS

它们都比梯度下降收敛速度快，而且可以自动设置学习率。

由于这些严重超纲，这里只做简单的介绍，而不再深入讨论了。

 

### 7.3 多元分类问题

先说场景：

区分邮件是如下几类中的一个：

1. 家人
2. 公司
3. 同学
4. 朋友

区分鼻塞是如下类中的一个：

1. 感冒
2. 着凉
3. 流感

区分天气是如下类中的一个：

1. 晴天
2. 多云
3. 下雨
4. 大风

我们的类别由之前的2类，上升到了多类问题，但是其本质还是**监督机器学习**，那么它们的区别就会在训练集上有所体现：

![](https://images.gitee.com/uploads/images/2020/0611/190546_68646bab_5550632.png )

我们可以这样处理这个数据集，将它分成三块：

![](https://images.gitee.com/uploads/images/2020/0611/190708_66fbbd4a_5550632.png )

> 1. Class 1 和 其它的类分开
> 2. Class 2 和 其他的类分开
> 3. Class 3 和其它的类分开

在第一种情况中我们把Class 1看作正类，我们会有如下的假设函数：
$$
h^{(1)}(x)
$$
![](https://images.gitee.com/uploads/images/2020/0611/191013_7be127aa_5550632.png )
$$
h^{(i)}(x)=P(y=i|x,\theta)\,(y = 1,2,3)
$$
当 i = 1时，它代表了当特征向量为x，模型参数为θ时，$\color{red}{为Class 1 的概率}$。同理我们可以划分其它两个类，最终它们长这样：

![](https://images.gitee.com/uploads/images/2020/0611/191221_794cc28a_5550632.png)

那我们最终怎么确定是哪一类呢？
$$
i=max_i(h^{(i)}(x))
$$
咱们 n 个类都算一算，哪个类的概率最大，最后不就是它吗。

<br>

## Part 8 过拟合 (Overfitting)

### 8.1 什么是过拟合

我们用回归问题和分类问题来描述什么是过拟合

先看一张图：

![](https://images.gitee.com/uploads/images/2020/0612/194523_ecf1e02b_5550632.png )

这是房价预测的例子，从左到右我们可以看到三张图，它们的假设函数次数越来越高。

左面第一张图，只是通过一条直线来拟合数据集，这个结果并不是很好，它忽略了一些训练数据，随着面积的增加训练集应该是一个平滑的趋势，但是它并没有做到这一点。对于这样的机器学习模型，我们称它为**欠拟合 (underfit)**。

中间这张图，用二次函数来拟合数据集效果不错，这是我们想要的结果。

右面的这张图，这个假设函数**过分地让自己拟合数据集**，导致**泛化能力很差**。（泛化能力就是这个模型迁移到新问题上的能力）。

我们再看一个分类问题的例子：

![](https://images.gitee.com/uploads/images/2020/0612/195149_adf51773_5550632.png)

从左向右，依次是，**欠拟合**，合适的，**过拟合**的图像。

由于采用了高阶多项式去拟合函数，使得假设函数本身过度依赖训练集。

当特征值少的时候，我们还可以通过画假设函数图像的方式进行判断是否发生了过拟合或者欠拟合的现象。然而现实中的问题很复杂，我们不可能通过极少的特征来描述问题，对于一个 房价预测问题它的特征值有可能是这样的：

![](https://images.gitee.com/uploads/images/2020/0612/195717_b114d489_5550632.png )

试问 1个100 元函数，计算机要花多长时间进行绘图？

如何判断过拟合和欠拟和的问题我们以后会学习，现在要解决的是我们有哪些手段可以就解决过拟合的问题呢？

### 8.2 解决过拟合的途径

![](https://images.gitee.com/uploads/images/2020/0612/200001_33be60d2_5550632.png)

1. 减少特征的数量
   1. 人工选择保留哪些特征
   2. 通过选择算法自动选择特征
2. 正则化：保留所有特征，通过减小模型参数，保证模型的准确性。



### 8.3 正则化 (Regularization)

正则化的目的就是**在不舍弃特征值的前提下，让代价函数计算出最合适的模型参数θ**，如何做到这一点呢？我们来看个简单的引入例子。

![](https://images.gitee.com/uploads/images/2020/0613/195812_5b0347c6_5550632.png)

我们对θ~3~，θ~4~这两个模型参数设置**惩罚项**，简单来说就是故意让它们变大，由于要求代价函数的最小值，在惩罚项不变的前提下，快速地能让整个式子变小，只能通过缩小θ~3~，θ~4~这两个参数的值，算到最后，它们就基本缩小到零了。然后原来的高次多项式就会被简化成如下紫红色曲线的样子：

![](https://images.gitee.com/uploads/images/2020/0613/204738_bc778e83_5550632.png)

如果我们想让它变成一个通用的规则我们可以这样写我们的代价函数：

![](https://images.gitee.com/uploads/images/2020/0613/205101_874f23b1_5550632.png)

我们对每个参数都添加惩罚项，最终最小化的结果就是我们正则化之后的结果。

这里我们要注意两个地方：

1. **正则化参数λ**
2. 习惯上我们不对θ~0~ 进行正则化，即便带上它也不影响最终结果

![](https://images.gitee.com/uploads/images/2020/0613/205523_3315ed35_5550632.png)

正则化参数λ是干什么的呢？它有两个目标：

1. 对于前半部分(原来的代价函数)，让它更好的去拟合训练集
2. 对于后半部分，尽量让模型参数变小

它起到了一个平衡的作用，如果它选的太大，导致惩罚代价太大，使得所有模型参数都会趋向于零，也就是说在假设函数里就剩下x~0~了，即，一条直线，显然这是不合适的。



### 8.4  线性回归的正则化

![](https://images.gitee.com/uploads/images/2020/0617/205419_89407319_5550632.png)

这是我们新的代价函数，我们对它做完梯度下降的结果为：

![](https://images.gitee.com/uploads/images/2020/0617/205644_0e6805c4_5550632.png)

前项推导之前做过了，咱们只对新加的惩罚项求偏导数即可。我们把θ~j~给提出来。

![](https://images.gitee.com/uploads/images/2020/0617/210015_72996c2e_5550632.png )

你会发现后项不变，前项变成了一个很有意思的项：
$$
1-\alpha\frac{λ}{m}
$$
由于学习率通常很小而且数据集通常也很大，这就导致这个系数很接近于1，你可以把它当作0.999，这样的结果就带来了：**θ~j~距离0变小了，或者说它的平方范数小了（向量变短了）**。

我们之前还学过正规方程的方式来求模型参数。

原来的正规方程长这样：
$$
\theta = (X^TX)^{-1}X^Ty
$$


正则化的正规方程法长这样：

![](https://images.gitee.com/uploads/images/2020/0617/210632_73355f8c_5550632.png)

PS：当 λ > 0时，矩阵是一定可逆的。



### 8.5 Logistic 回归的正则化

再讲Logistic 回归的正则化之前，先看一下Logistic回归的假设函数模型：

![](https://images.gitee.com/uploads/images/2020/0606/111059_66ef2190_5550632.png )

![](https://images.gitee.com/uploads/images/2020/0619/184328_907290ae_5550632.png)

在处理分类问题时，我们有可能会采用高阶多项式作为sigmoid函数的参数导致过拟合的出现，如今，我们同样可以借鉴线性回归的方式，给分类问题的代价函数后面加一个惩罚项，然后对新的代价函数进行梯度下降。

![](https://images.gitee.com/uploads/images/2020/0619/184858_e5dd9465_5550632.png)

![](https://images.gitee.com/uploads/images/2020/0619/184956_0fd99a49_5550632.png)

梯度下降结果如上图所示。此处和线性回归的形式一样，**但是，它们不是一个东西**，$\color{red}{线性回归和Logistic回归的根本区别在于假设函数}$。

写成Octave函数的模式如下图：

![](https://images.gitee.com/uploads/images/2020/0619/185416_a254dffd_5550632.png )

<br>

## Part 9 机器学习实战-房价预测

为什么之前讲的那么快，因为我已经按捺不住做实验的心了。纸上得来终觉浅，绝知此事要躬行。以下是，我针对**线性回归模型**的一系列实验。不感兴趣的小伙伴可跳过这一章。

### 9.1 数据集来源以及数据集说明

#### 0x00 数据集的介绍

**波士顿房价数据集（Boston House Price Dataset）（下载地址：http://t.cn/RfHTAgY）**

CRIM：城镇人均犯罪率。

ZN：住宅用地超过 25000 sq.ft. 的比例。

INDUS：城镇非零售商用土地的比例。

CHAS：查理斯河空变量（如果边界是河流，则为1；否则为0）。

NOX：一氧化氮浓度。

RM：住宅平均房间数。

AGE：1940 年之前建成的自用房屋比例。

DIS：到波士顿五个中心区域的加权距离。

RAD：辐射性公路的接近指数。

TAX：每 10000 美元的全值财产税率。

PTRATIO：城镇师生比例。

B：1000（Bk-0.63）^ 2，其中 Bk 指代城镇中黑人的比例。

LSTAT：人口中地位低下者的比例。

MEDV：自住房的平均房价，以千美元计。

<br>

#### 0x01 数据集的类别和规模

正常数据集大小（506，13）

经过pandas数据处理后得到的训练集和测试集的大小为，均多加一列，x_0 = 1

训练集：（404，14）占总测试集的80%

测试集：（103，14）占总测试集的20%

<br>

### 9.2 实验设计

#### 0x00 概述

使用之前学过的所有关于线性回归的算法

> 1. 正规方程法预测
> 2. 无参数归一化的梯度下降预测
> 3. 采用z-score 特征归一化之后的梯度下降预测
> 4. 采用 max-min-scaling 特征归一化之后的梯度下降预测

2，3，4 来比较，学习率和迭代次数是否因**有无归一化而变化**。

3，4来比较，**不同归一化方法对同一训练集有无影响**。

输出：各种处理的结果图，真实值是离散的散点，结果是预测的函数。

#### 0x01 源代码

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt


DATA_SET_PATH = r"D:\ProgramLearning\Python\MachineLearning\dataset\housing.csv"
def get_data_frame(file_path = DATA_SET_PATH):
    return pd.read_csv(file_path,sep = ',')

def get_train_set(data_frame):
    feature_columns_list = ["CRIM", "ZN", "INDUS", "CHAS", "NOX", "RM", "AGE", "DIS", "RAD", "TAX", "PTRATIO", "B",
                            "LSTAT"]
    value_columns_list = ["MEDV"]
    train_data_frame = data_frame[1:int(data_frame.shape[0] * 0.8)]
    train_data_frame_x = pd.DataFrame(train_data_frame, columns=feature_columns_list)
    train_data_frame_y = pd.DataFrame(train_data_frame, columns=value_columns_list)
    train_data_frame_x.to_csv(r"..\dataset\FeatureX.csv", index=None)
    train_data_frame_y.to_csv(r"..\dataset\ValueY.csv", index=None)
    print("Generate training set successfully!")

def get_test_set(data_frame):
    feature_columns_list = ["CRIM", "ZN", "INDUS", "CHAS", "NOX", "RM", "AGE", "DIS", "RAD", "TAX", "PTRATIO", "B",
                            "LSTAT"]
    value_columns_list = ["MEDV"]
    test_data_frame = data_frame[int(data_frame.shape[0]*0.8)+1:]
    test_data_frame_x = pd.DataFrame(test_data_frame,columns=feature_columns_list)
    test_data_frame_y = pd.DataFrame(test_data_frame,columns=value_columns_list)
    test_data_frame_x.to_csv(r"..\dataset\testFeatureX.csv",index=None)
    test_data_frame_y.to_csv(r"..\dataset\testValueY.csv",index = None)
    print("Generate test set successfully!")

def get_matrix_x(data_frame):
    matrix = np.array(data_frame)
    ones_b = np.ones(data_frame.shape[0])
    new_matrix = np.c_[ones_b,matrix]
    return np.mat(new_matrix)

def get_vector_y(data_frame):
    return np.array(data_frame)

def data_set_info():
    # CRIM：城镇人均犯罪率。
    #
    # ZN：住宅用地超过 25000 sq.ft. 的比例。
    #
    # INDUS：城镇非零售商用土地的比例。
    #
    # CHAS：查理斯河空变量（如果边界是河流，则为1；否则为0）。
    #
    # NOX：一氧化氮浓度。
    #
    # RM：住宅平均房间数。
    #
    # AGE：1940 年之前建成的自用房屋比例。
    #
    # DIS：到波士顿五个中心区域的加权距离。
    #
    # RAD：辐射性公路的接近指数。
    #
    # TAX：每 10000 美元的全值财产税率。
    #
    # PTRATIO：城镇师生比例。
    #
    # B：1000（Bk-0.63）^ 2，其中 Bk 指代城镇中黑人的比例。
    #
    # LSTAT：人口中地位低下者的比例。
    #
    # MEDV：自住房的平均房价，以千美元计。
    pass

"""
一共有3种方式进行预测，
第一种：正规方程法
第二种：无归一化的梯度下降法，学习率:1e-14,迭代次数：150000
第三种：归一化的梯度下降法，学习率：，迭代次数
监督学习必要事项： 1.假设函数 hypothesis_function()
                  2.代价函数 cost_function()
                  3.初始化的模型参数 θ generate_init_theta() [梯度下降时用]

"""

def hypothesis_function(feature_x,theta):
    """
    h(x) = theta_0*x_0 + theta_1*x_1 +...+theta_n*x_n
    x_0 = 1
    向量化后，predict_vector_y = feature_x . theta
    :param feature_x: 
    :param theta: 
    :return: numpy.ndarray , n维列向量
    """
    predict_vector_y = feature_x.dot(theta)
    return predict_vector_y

def cost_function(feature_x,vector_y,theta):
    """
    J(θ) = (1/(2*m)) * ∑(i=1,m)(h(x) - y)²
    :param feature_x: 
    :param vector_y: 
    :param theta: 
    :return: 一个浮点数，值越小模型结果和真实值越贴近
    """
    m = feature_x.shape[0]
    sum_value = np.sum((hypothesis_function(feature_x,theta) - vector_y)**2)
    cost_value = (1/(2*m)) * sum_value
    return cost_value

def generate_init_theta(feature_x):
    """
    生成初始的模型参数
    :param feature_x: 
    :return: 类型为numpy.ndarray的值为 1 的 n维列向量
    """
    theta = np.ones(feature_x.shape[1])
    return theta

def normal_equation(feature_x,vector_y):
    """ 
    计算: theta = (X^TX)^{-1}X^Ty
    :param feature_x: 
    :param vector_y: 
    :return: 一个 n维的列向量，类型 numpy.ndarray  
    """
    #求 X^T . X
    matrix_temp = np.transpose(feature_x).dot(feature_x)
    #求 matrix_temp的伪逆
    matrix_temp_pinv = np.linalg.pinv(matrix_temp)
    # 求 X^T . y
    matrix_temp = np.transpose(feature_x).dot(vector_y)
    theta = matrix_temp_pinv.dot(matrix_temp)
    return theta

def gradient_decent(feature_x,vector_y,theta,alpha = 1e-7,iteration_times = 550000):
    """
    没有向量化的梯度下降算法：
    theta_x := theta_x - α * 1/m *Σ(i=1,m)[h(x^i) - y^i]*x^i
    :param feature_x: 
    :param vector_y: 
    :param theta: 
    :param alpha: 学习率，默认 1e-7
    :param iteration_times: 迭代次数，默认 210000
    :return: theta(n,1)
    设:矩阵feature_x_t = (feature_x^T),向量 vector_temp = (h(x) - y)，
    系数coefficient = alpha - (1/m)
    vector_temp: (m,1)
    feature_x:  (m,n)
    feature_x_t: (n,m) 
    向量化后的：theta := theta - coefficient * (feature_x_t.dot(vector_temp))
    """
    m = feature_x.shape[0]
    theta = theta.reshape((feature_x.shape[1],1))

    #迭代 iteration_times 次进行计算
    for cnt in range(iteration_times):
        if cnt % 1000 == 0:
            print("第%s次迭代的代价函数值为:%s"%(cnt,cost_function(feature_x,vector_y,theta)))
        # 系数 coefficient = alpha * (1/m)
        coefficient = alpha * (1 / m)
        # 向量 vector_temp = (h(x) - y)
        vector_temp = hypothesis_function(feature_x, theta).reshape((feature_x.shape[0], 1)) \
                      - vector_y
        # 矩阵 feature_x_t = (feature_x^T)
        feature_x_t = np.transpose(feature_x)
        theta -= (coefficient * (feature_x_t.dot(vector_temp)))
    print("迭代%s次后，最终的代价函数值为：%s"%
          (iteration_times,cost_function(feature_x,vector_y,theta)))
    return theta

#归一化
# z-score 归一化
def z_score(feature_x):
    """
    当原始训练数据可近似为正态分布时，效果最好
    对feature_x和vector_y做z_score均一化
    X = (X-μ)/σ
    :param feature_x: 
    :return: feature_x
    """
    col_avg = np.average(feature_x, axis=0)
    col_standard_deviation = np.std(feature_x, axis=0)
    col_avg = col_avg.reshape((feature_x.shape[1],1))
    col_standard_deviation = col_standard_deviation.reshape((feature_x.shape[1],1))
    for j in range(1,feature_x.shape[1]):
        if col_standard_deviation[j] == 0:
            col_standard_deviation[j] = 1e-30
        feature_x[:,j] = (feature_x[:,j] - col_avg[j])/col_standard_deviation[j]

    return feature_x

# max-min-scaling
def max_min_scaling(feature_x):
    """
    X = (X-min(X)) / (max(X) - min(X))
    :param feature_x: 
    :return: feature_x
    """
    feature_x_min = np.min(feature_x,axis=0)
    feature_x_max_min_range = np.max(feature_x,axis = 0) - feature_x_min
    feature_x_min = feature_x_min.reshape((feature_x.shape[1], 1))
    feature_x_max_min_range = feature_x_max_min_range.reshape((feature_x.shape[1], 1))

    for j in range(1,feature_x.shape[1]):
        if feature_x_max_min_range[j] == 0:
            feature_x_max_min_range[j] = 1e-30
        feature_x[:, j] = (feature_x[:, j] - feature_x_min[j]) / feature_x_max_min_range[j]

    return feature_x


#可视化
def draw_picture(test_set_x,test_set_y,ne_predict_y,gd_predict_y,z_score_gd_predict_y,mm_scaling_gd_predict_y):

    plt.rcParams['font.sans-serif'] = ['SimHei']
    plt.rcParams['axes.unicode_minus'] = False
    house_id_x = []
    for house_id in range(1,test_set_x.shape[0]+1):
        house_id_x.append(house_id)

    #形状转换
    ne_predict_y = ne_predict_y.tolist()
    gd_predict_y = gd_predict_y.tolist()
    z_score_gd_predict_y = z_score_gd_predict_y.tolist()
    mm_scaling_gd_predict_y = mm_scaling_gd_predict_y.tolist()

    fig,axes = plt.subplots(nrows = 2,ncols = 2)
    axes[0,0].scatter(house_id_x, test_set_y, label="真实值",color="red",s = 13)
    axes[0,0].set(title="正规方程组法")
    axes[0,0].plot(house_id_x, ne_predict_y, label="正规方程法")


    axes[0,1].set(title="无归一化的梯度下降法")
    axes[0, 1].scatter(house_id_x, test_set_y, label="真实值", color="red",s = 13)
    axes[0,1].plot(house_id_x,gd_predict_y,label = "梯度下降法")


    axes[1, 0].set(title="z-score的梯度下降法")
    axes[1, 0].scatter(house_id_x, test_set_y, label="真实值", color="red",s = 13)
    axes[1, 0].plot(house_id_x, z_score_gd_predict_y, label="z-score梯度下降法")


    axes[1, 1].set(title="max-min-scaling的梯度下降法")
    axes[1, 1].scatter(house_id_x, test_set_y, label="真实值", color="red",s = 13)
    axes[1, 1].plot(house_id_x, mm_scaling_gd_predict_y, label="max-min-scaling梯度下降法")

    plt.xlabel("房屋编号")
    plt.ylabel("预测价格1000$")
    plt.show()


def main():
    #生成训练集
    feature_x = get_matrix_x(get_data_frame(r"..\dataset\FeatureX.csv"))
    feature_x = feature_x.A #把特征值统一成ndarray类型方便处理
    vector_y = get_vector_y(get_data_frame(r"..\dataset\ValueY.csv"))
    #生成测试集
    test_set_x = get_matrix_x(get_data_frame(r"..\dataset\testFeatureX.csv"))
    test_set_y = get_vector_y(get_data_frame(r"..\dataset\testValueY.csv"))


    feature_x_copy = feature_x

    #梯度下降法(无归一化)的模型参数
    theta_gd = gradient_decent(feature_x,vector_y,generate_init_theta(feature_x))
    print("梯度下降法(无归一化)的模型参数:"+str(theta_gd.tolist()))

    #正规方程组法的模型参数
    theta_ne = normal_equation(feature_x,vector_y)
    print("正规方程组法的模型参数:" + str(theta_ne.tolist()))

    # #均值归一化后的特征矩阵和向量 z-score法
    z_score_feature_x= z_score(feature_x_copy)

    # 均值归一化后的特征矩阵和向量 max-min-scaling法
    mm_scaling_feature_x= max_min_scaling(feature_x)
    #梯度下降法(归一化后)的模型参数 max-min-scaling法
    mm_scaling_theta_gd = gradient_decent(mm_scaling_feature_x, vector_y, generate_init_theta(feature_x),
                                       alpha=1e-3, iteration_times=125000)
    print("梯度下降法(归一化后)的模型参数:(max-min-scaling法)" + str(mm_scaling_theta_gd.tolist()))

    # #梯度下降法(归一化后)的模型参数 z-score法
    z_score_theta_gd = gradient_decent(z_score_feature_x, vector_y, generate_init_theta(feature_x),
                                        alpha=1e-3, iteration_times=125000)
    # print("梯度下降法(归一化后)的模型参数:(z-score法)" + str(z_score_theta_gd.tolist()))

    #正规方程组的预测值
    ne_predict_y = hypothesis_function(test_set_x,theta_ne)
    #梯度下降法(无归一化)的预测值
    gd_predict_y = hypothesis_function(test_set_x,theta_gd)
    #梯度下降法(归一化后)的预测值 z-score法
    z_score_gd_predict_y = hypothesis_function(z_score(test_set_x),z_score_theta_gd)
    # 梯度下降法(归一化后)的预测值 max-min-scaling法
    mm_scaling_gd_predict_y = hypothesis_function(max_min_scaling(test_set_x), mm_scaling_theta_gd)



    draw_picture(test_set_x,test_set_y,ne_predict_y,gd_predict_y,z_score_gd_predict_y,mm_scaling_gd_predict_y)


main()
```



#### 0x02 实验结果及可视化展示

![输入图片说明](https://images.gitee.com/uploads/images/2020/0724/160141_e15ceb7a_5550632.png "屏幕截图.png")

据网上的资料显示，当我的样本服从正态分布的时候 z-score归一化的效果是最好的。从上面代码中可以看出**归一化对机器学习算法起着重要的作用**

普通的不进行任何归一化的梯度下降算法的参数：

alpha = 1e-7,iteration_times = 550000

两种归一化后的梯度下降算法的参数：

alpha=1e-3, iteration_times=125000

这些参数我还只是粗调，具体差异可能会更大。

这也证实了我的两个实验目的，**归一化对算法的影响明显**，**不同归一化算法对同一数据集效果不同**

<br>

### 9.3 踩到的坑

#### 0x00 多元梯度下降的向量化

当时鄙人为了给多元梯度下降向量化真是煞费苦心。

推导过程 (字很难看，请见谅)：

![输入图片说明](https://images.gitee.com/uploads/images/2020/0724/160407_f4d0bedd_5550632.png "屏幕截图.png")



#### 0x01 均值归一化

我一共犯了2个错误。

第一个错误，把真实值（标签）当作特征，将特征矩阵和真实值向量同时进行归一化，导致出错。

第二个错误，进行测试时，没有进行归一化就开始预测结果。我们归一化后训练出的模型参数，是基于归一化后的特征值训练出来的，而且特征值的取值范围是被约束的。而我不把测试集进行归一化，那么这个预测结果当然是不对的。



<br>

## Part 10 神经网络-新的征程

### 10.1 神经网络的引出

我们之前学习的机器学习算法，都是一般采用的线性函数作为假设函数，为了有一个直观的体验，我们来看一个分类的例子

![输入图片说明](https://images.gitee.com/uploads/images/2020/0725/111659_d12cff34_5550632.png "屏幕截图.png")

我们采用高阶的线性多项式代入sigmoid函数，以求得到好的分类效果

![输入图片说明](https://images.gitee.com/uploads/images/2020/0725/112410_374589d4_5550632.png "屏幕截图.png")

当整个算法只有2个特征值的时候，我们这样做高阶多项式看起来还不是很麻烦，但我们假设，这个分类问题是分出房子的类型（别墅，平房，贫民窟，……）那我们需要的特征值可能有：

> 房屋面积
>
> 卧室个数
>
> 卫生间数量
>
> 供水平均时间
>
> ……

如果，它有100个特征值，那么我们做出二次方的排列组合就是O(n^2^)量级，三次方就是O(n^3^)，从个数上看二次方的排列组合大概有5000种，三次方的排列组合大概有17000项。这种规模的数据计算机能不能算的出来暂且不论。我们看一个计算机视觉的例子。

![输入图片说明](https://images.gitee.com/uploads/images/2020/0725/113301_7b77bbe3_5550632.png "屏幕截图.png")

计算机视觉的主要工作就是教电脑识别图像，比如，我们给电脑提供的是一个 50 × 50 像素点的灰度图像（0，255），这个算法需要根据提供的像素亮度矩阵，告诉我们这是不是**一个车的门把手**

了解了大致原理之后，现在让我们看一个汽车识别的例子

![输入图片说明](https://images.gitee.com/uploads/images/2020/0725/113652_3ba93e1f_5550632.png "屏幕截图.png")

我们首先有一个带标签的数据集，用来辨别它是不是一辆车，然后还有一个训练集，我们最后需要根据训练出的模型来判断输入图片是不是一辆车。

假设我们取2个50×50像素的灰度图像最为特征值

![输入图片说明](https://images.gitee.com/uploads/images/2020/0725/114130_41d3f5fd_5550632.png "屏幕截图.png")

![输入图片说明](https://images.gitee.com/uploads/images/2020/0725/114203_ed8dbdc6_5550632.png "屏幕截图.png")

我们的目的就是训练出一条曲线来拟合这个图像

![输入图片说明](https://images.gitee.com/uploads/images/2020/0725/114237_cff5cccf_5550632.png "屏幕截图.png")

一个特征向量 x 的维数在灰度图像的表示就是2500

像x~i~ 和 x~j~ 的二次排列组合大概，需要3百万种吧……这电脑CPU肯定算不过来，而神经网络就是为解决这种问题诞生的。

### 10.2 神经元与大脑

程序拟真的终极目标就是做出人工大脑，实现真正意义上的人工智能。在目前的计算机科学中，我们如何模拟脑组织结构呢？

![输入图片说明](https://images.gitee.com/uploads/images/2020/0731/103340_5721abc5_5550632.png "屏幕截图.png")

上图是脑组织中的神经元，它有输入用的树突，和输出用的轴突。神经元之间通过神经递质，造成电位差进而进行信息传递【我的生物水平仅停留在高中的生物课的时期】

计算机中的神经元的逻辑模型：

![输入图片说明](https://images.gitee.com/uploads/images/2020/0731/103747_08fcca36_5550632.png "屏幕截图.png")

黄色颜色圆圈左侧是代表输入，黄色圆圈右侧为输出

当然了，上图中没有化出x~0~,因为它恒为1，在神经网络中我们称它为**偏置单元（Bias Unit）**

这一个系统也可以统称成**感知机 （Perceptron）**

总结一下就是，感知机（人工神经元）接收多个输入，输出1个信号，输入值会经过一个**非线性函数【激活函数（activation function）】**,最终决定其输出值。

在次之后，关于参数theta的模型也可能会称之为**权重(weights)**为theta的模型。

### 10.3 神经网络结构

神经网络就是把多个感知机按层叠加，连接在一起的集合

![输入图片说明](https://images.gitee.com/uploads/images/2020/0731/105015_5152e362_5550632.png "屏幕截图.png")

也可以画出x~0~

![输入图片说明](https://images.gitee.com/uploads/images/2020/0731/105129_c00cb1f7_5550632.png "屏幕截图.png")

在神经网络中，第一层叫**输入层(Input Layer)**，最后一层为**输出层(Output Layer)**，中间的层为**隐藏层(Hidden Layer)**。

输入层输入特征列向量（1xn）,隐藏层计算权重矩阵theta，输出层输出结果。

我们在来看一下下图一个简单的神经网络中的计算过程，即神经网络在干什么：

![输入图片说明](https://images.gitee.com/uploads/images/2020/0731/111952_e8b05490_5550632.png "屏幕截图.png")

首先明确术语及符号：
$$
a_i^{(j)}: 代表第 j 层的第i个感知机(人工神经元) 
\\Θ^{(j)}:为从第j层到第j+1层的权重矩阵(模型参数矩阵Θ)
$$
层数是从左向右，从一开始看的，**原来的模型参数从向量变成了矩阵**

![image-20200731115700887](C:\Users\micha\AppData\Roaming\Typora\typora-user-images\image-20200731115700887.png)

![输入图片说明](https://images.gitee.com/uploads/images/2020/0731/114323_8dae70c5_5550632.png "屏幕截图.png")

以上就是对上述神经网络的计算流程，看不懂吧，第一眼看不懂就对了，我来给大家掰扯掰扯。

首先，毋庸置疑的，x~0~ = 1

其次，我们的模型参数由**向量变成了一个矩阵**

看输入层，我们输入的就是一个(1x4)的特征列向量，对于第二层的第一个神经元来说，它需要计算**从第1层到第2层(这里直接是输出层)权重矩阵的第一行的线性运算再带入Sigmoid函数**

说人话就是，**把第一层的权重矩阵的第一行拿出来，和每个特征值做线性运算，再带入激活函数Sigmoid函数中**

这样易得，我们的模型参数是一个(4x3)的矩阵【4个特征值，1层神经网有3个感知机】

那么第一层输出的就是一个(1x3)的列向量，再输入到输出层，列向量通过输出函数输出一个值

![输入图片说明](https://images.gitee.com/uploads/images/2020/0731/120352_01633a67_5550632.png "屏幕截图.png")

然后我们还有一个简单的数量关系，即：

$\color{red}{如果网络中有 s_j 个神经元在j层，s_{j+1} 个神经元在j + 1层，那么Θ^{(j)}的维度为 s_{j+1} × (s_j+1)}$

![输入图片说明](https://images.gitee.com/uploads/images/2020/0731/121145_6845c449_5550632.png "屏幕截图.png")

比如，上图中有输出层(第0层)有3个特征向量(不包含x~0~)，第2层有4个神经元，那么Θ^（1）^的维数就是 4 × (3+1) = 4 × 4

### 10.4 神经网络向量化

![输入图片说明](https://images.gitee.com/uploads/images/2020/0805/143329_dc614068_5550632.png "屏幕截图.png")

为了高效地进行计算，我们要对上面这个式子进行向量化
$$
设:z^{(2)}_1 = Θ^{(1)}_{10}x_0 + Θ^{(1)}_{11}x_1 +Θ^{(1)}_{12}x_2 +Θ^{(1)}_{13}x_3\\
z^{(2)} = \left[              
\begin{array}{lcr}     
z_1^{(2)}\\
z_2^{(2)}\\
z_3^{(2)}
\end{array}       
\right]
\\同时将：Θ^{(1)}_{10}x_0 + Θ^{(1)}_{11}x_1 +Θ^{(1)}_{12}x_2 +Θ^{(1)}_{13}x_3和之后的若干项看作:
\\
x = \left[              
\begin{array}{lcr}     
x_0\\
x_1\\
x_2\\
x_3
\end{array}       
\right]
Θ^{(1)} = \left[
\begin{array}{lcr}
Θ^{(1)}_{10}\quad Θ^{(1)}_{11}\quadΘ^{(1)}_{12}\quadΘ^{(1)}_{13}\\
Θ^{(1)}_{20}\quad Θ^{(1)}_{21}\quadΘ^{(1)}_{22}\quadΘ^{(1)}_{23}\\
Θ^{(1)}_{30}\quad Θ^{(1)}_{31}\quadΘ^{(1)}_{32}\quadΘ^{(1)}_{33}\\
\end{array}
\right]
\\
Θ^{(1)}x
$$
综上我们可以得出：
$$
z^{(2)} =Θ^{(1)}x\\
a^{(2)} = g(z^{(2)})
$$

把第二层的神经元统一看成一个向量，它是由第一层的输入决定的，为了方便理解，这里可以把
$$
x 当作 a^{(1)}
$$

那么上述的整个计算流程可以用下图表示：

![输入图片说明](https://images.gitee.com/uploads/images/2020/0805/145912_4532e951_5550632.png "屏幕截图.png")

从输入层开始到最后的输出层，我们是一层一层向后迭代的，所以把这个过程称为**正向传播（forward propagation）**

![输入图片说明](https://images.gitee.com/uploads/images/2020/0805/150153_f66c7674_5550632.png "屏幕截图.png")

单看这一层的输出，它就是一个单纯的逻辑回归，只不过它的特征矩阵不再是我们给它的了，而是由它的上一层计算得到的

整个神经网络看上去就是一个大的逻辑回归，但是所有的参数都是有它自己学习得出的。

![输入图片说明](https://images.gitee.com/uploads/images/2020/0805/150456_5d5c3ebc_5550632.png "屏幕截图.png")

通过这样的学习可以使计算机跨过由于底层表示和现实世界的数据维度差距过大所导致的**语义鸿沟**。

最后讲一个有关神经网络**架构(architecture)**的概念

![](https://images.gitee.com/uploads/images/2020/0805/150900_fe1ae2b9_5550632.png)

神经网络的架构指的是不同层神经元之间的连接方式。

##### 通过例子进行深入理解

###### 引入

在举例之前我们重温一下Sigmoid函数的图像:

![输入图片说明](https://images.gitee.com/uploads/images/2020/0923/150350_c9fcd06b_5550632.png "屏幕截图.png")

<br>

**使用单一神经元模拟 AND**

我们的需求是使用神经元来模拟 AND 信号。真值表如下:

![输入图片说明](https://images.gitee.com/uploads/images/2020/0923/150824_62a67bea_5550632.png "屏幕截图.png")

假设参数为20，20。偏置单元为 -30，如下图，就可以将这些值看成参数矩阵(本例中为向量)



$$
-30 => \theta^{(1)}_{10} \\
20 => \theta^{(1)}_{11} \\
20 => \theta^{(1)}_{12}
$$

![输入图片说明](https://images.gitee.com/uploads/images/2020/0923/150550_ca96f98e_5550632.png "屏幕截图.png")

当参数去上述值时，我们假设函数的输出和AND运算的结果是近似相同的。

<br>

**使用单一神经元模拟 OR**

同理，OR的真值表如下:

![输入图片说明](https://images.gitee.com/uploads/images/2020/0923/151444_1aba2222_5550632.png "屏幕截图.png")

设计参数和偏置的值为：**20，20，-10**

假设函数内部的值：

![输入图片说明](https://images.gitee.com/uploads/images/2020/0923/151821_e47a3ed6_5550632.png "屏幕截图.png")

<br>

**使用单一神经元模拟 NOT**

![输入图片说明](https://images.gitee.com/uploads/images/2020/0923/152041_6fea7511_5550632.png "屏幕截图.png")

<br>

**使用单一神经元模拟 (NOT x_1) AND (NOT x_2)**

真值表如下:

![输入图片说明](https://images.gitee.com/uploads/images/2020/0923/152438_3376c567_5550632.png "屏幕截图.png")

设计参数和偏置:**-30,-30,20**

最终结果:

![输入图片说明](https://images.gitee.com/uploads/images/2020/0923/152725_9b82655a_5550632.png "屏幕截图.png")

<br>

**综上实现 XNOR**

首先将上述三种神经元画出来（参数的选择情况不止一种）:

![输入图片说明](https://images.gitee.com/uploads/images/2020/0923/152929_cea72ca6_5550632.png "屏幕截图.png")



XNOR的真值表:

![输入图片说明](https://images.gitee.com/uploads/images/2020/0923/153123_bf7a7763_5550632.png "屏幕截图.png")

![输入图片说明](https://images.gitee.com/uploads/images/2020/0923/154540_b4af671e_5550632.png "屏幕截图.png")

计算过程:

![输入图片说明](https://images.gitee.com/uploads/images/2020/0923/154927_e7020f4e_5550632.png "屏幕截图.png")

![输入图片说明](https://images.gitee.com/uploads/images/2020/0923/155011_1b346198_5550632.png "屏幕截图.png")

### 10.5 多元分类问题

接下来我们将举出一个计算机视觉的例子，来学习多元分类问题

#### 10.5.1 问题概述

![输入图片说明](https://images.gitee.com/uploads/images/2020/0923/155554_99f22659_5550632.png "屏幕截图.png")

给出一组图片，让计算机去判别该图片中是**行人，汽车，摩托车，卡车**中的哪一类。很显然这是一个4元分类问题，所以我们的输出层会有4个单元。输出的结果是一个4维向量，我们可以做出如下假设:

![输入图片说明](https://images.gitee.com/uploads/images/2020/0923/155912_7a748835_5550632.png "屏幕截图.png")

当训练集图片为行人时，标记为 [1 0 0 0]^T^，训练集的标签由原来的实数，变成了向量。

#### 10.5.2 代价函数

在讲多元分类问题的代价函数之前，我们需要明确一下需求。

![输入图片说明](https://images.gitee.com/uploads/images/2020/0929/094130_24a25676_5550632.png "屏幕截图.png")

首先我们的训练集记作:

$$
\{(x^{(1)},y^{(1)}),(x^{(2)},y^{(2)}),(x^{(3)},y^{(3)}),……,(x^{(m)},y^{(m)})\}
$$
L :代表了神经网络的总层数

s~l~ : 第 l 层的神经元个数

在原来的二分类问题中，我们可以把它看作输出层只有一个神经元的神经网络，所以我们可以将它的代价函数写为:

![输入图片说明](https://images.gitee.com/uploads/images/2020/0929/100620_e35d3265_5550632.png "屏幕截图.png")
$$
K=1\\
J(\theta)=-\frac{1}{m}[\sum_{i=1}^m\sum_{k=1}^Ky^{(i)}_klog\;h_\theta(x^{(i)})_k+(1-y^{(i)}_k)log\;h_\theta(1-x^{(i)})_k] + \frac{\lambda}{2m}\sum_{l=1}^L\sum_{i=1}^{s_l}\sum_{j=1}^{s_l+1}(\theta^{(l)}_{ji})^2
$$

当K>1时:

![输入图片说明](https://images.gitee.com/uploads/images/2020/0929/101026_875cc28c_5550632.png "屏幕截图.png")

<br>

#### 10.5.3 反向传播算法

现在，我们拥有了假设函数，代价函数，那么只需要对代价函数进行梯度下降，我们就可以求出每层神经网之间的权重矩阵了。然而，梯度下降中有关于参数θ的偏导数。我们在神经网络中应该如何计算这些偏导数呢？

我们先假设一个简单的例子，看看计算过程：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1029/192044_736c4a32_5550632.png "屏幕截图.png")

假设我们的数据集中就一组数据(x,y)，应用前向传播的计算流程为上图所示。接着为了能算出每层之间的参数矩阵Θ，我们需要对代价函数进行梯度下降，其中所计算的偏导项就要使用反向传播算法了。

##### 算法描述

![输入图片说明](https://images.gitee.com/uploads/images/2020/1029/192522_86c642b6_5550632.png "屏幕截图.png")

定义：δ~j~^(l)^ 为第 l 层中第 j 个结点的误差。举个例子：

对于最后一层，我们将其向量化后可以看作 δ^(4)^ = a^(4)^ - y，那么我们就可以接着向前推导
$$
\delta^{(3)} = (Θ^{(3)})^T\delta^{(4)}.dot(g^{,}(z^{(3)}))\\
\delta^{(2)} = (Θ^{(2)})^T\delta^{(3)}.dot(g^{,}(z^{(2)}))
$$
其中z^j^ 为第j层神经网络的输出值，由于从输入层进入是我们所观测到的数据所以只计算到δ^(2)^

![输入图片说明](https://images.gitee.com/uploads/images/2020/1029/192911_30d6594c_5550632.png "屏幕截图.png")

最终经过及其复杂的推导证明我们得出了这样一个结论：
$$
\left.\frac{\partial J(\Theta)}{\partial \Theta_{ij}^{(l)}}\right. = a^{(l)}_j*\delta^{(l+1)}_i
$$

##### 深入理解反向传播算法

反向传播算法在机器学习的学习过程中是一个坎儿，接下来我要做的工作就是，将前向传播，反向传播算法细化推演，争取在宏观的角度给大家带来启发。我们首先来看前向传播算法。

![输入图片说明](https://images.gitee.com/uploads/images/2020/1105/193658_df3785ec_5550632.png "屏幕截图.png")

假设有一个如上图的神经网络，将其故意画成椭圆形以便进行标注。那它的前向传播算法其实如下：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1105/195632_8b13ece3_5550632.png "屏幕截图.png")

所以，我们不难看出每个神经元的输入部分为，前一项的值和前一层的权重矩阵的线性组合，而神经元的输出部分则是，对该线性组合的结果的sigmoid函数值。这就是前向传播的计算流程。

想进行前向传播，那就必须知道**每一层神经网之间的权重矩阵**，在线性回归中，我们直接对代价函数进行梯度下降，然后得出模型参数。类比的，我们要对神经网络的**代价函数进行梯度下降**，神经网络中的代价函数长这样：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1105/200216_aab79a1d_5550632.png "屏幕截图.png")

它的作用和线性回归中的均方根误差公式的作用是一样的。而反向传播算法就是在计算**每一层神经网络的每个激活函数输出值的偏差**，我们来详细地看一下它的计算流程：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1105/201756_f7b01eac_5550632.png "屏幕截图.png")

在数学上的含义如下：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1105/201902_af4d2a8a_5550632.png "屏幕截图.png")

#### 10.5.4 梯度检验 (Gradient Checking)

梯度检验用于评估在运行繁复的反向传播算法后**是否得到了正确的偏导数值**。有可能当你辛辛苦苦训练完一个神经网络之后，却发现由于**反向传播算法的实现出现了失误**，导致发生了难以察觉的细小Bug，导致最终的模型结果不准确。为了能够尽早地发现问题，我们来介绍一种梯度检验的方法，用于评估使用反向传播算法运算结果所得到的**偏导数值**。

我们是如下进行导数估计的

![输入图片说明](https://images.gitee.com/uploads/images/2020/1130/144608_d28be25c_5550632.png "屏幕截图.png")

函数在点θ处的切线斜率为导数的几何意义，我们取距离θ较近的对称位置θ-e，θ+e，当e足够小时，该红色直线的斜率就是θ点处的导数值。一般我们取e为10e-4，此时θ的导数如下式:

$$
\frac{d}{d_\theta}J(\theta) ≈ \frac{J(\theta+e)-J(\theta-e)}{2e}
$$
(双侧差分)

当θ展开变成向量时我们可以如下计算：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1130/145714_bc96224b_5550632.png "屏幕截图.png")

附上Octave的代码：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1130/145857_34c34a14_5550632.png "屏幕截图.png")

注意：我们在训练模型时（应用反向传播算法时），一定要关闭掉梯度检测算法，否则电脑会占用大量计算资源。

#### 10.5.5 随机初始化

我们在之前进行线性回归的实验时选择的是向量全为1 的初始化方式，而在逻辑回归中我们可以使用全零的初始化方式，但是这种方式应用在神经网络中就显得没什么意义了，原因如下：

![image-20201130152931236](C:\Users\micha\AppData\Roaming\Typora\typora-user-images\image-20201130152931236.png)

如果参数矩阵的值都相等，就会导致最终所计算出的激活函数值是相同的，它们再经过反向传播算法后得到的的偏导数也相同，梯度下降之后，所得到的参数矩阵的值虽然不是零，但是依旧相等。相当于整个神经网络就是在计算一个相同的特征，不仅浪费性能，而且还无法得到准确的结果。此时我们就要对初始化的参数矩阵做**随机**处理，如下所示：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1130/153526_5c4a6c7a_5550632.png "屏幕截图.png")

rand(10,11)可以生成一个Matrix(10*11),基于上图中的公式，我们就可以将所有的θ矩阵初始化到一个[-a,a]的范围中了。

#### 10.5.6 组合到一起

本节来综合上述所讲的有关于神经网路的知识点，同时说明自己训练模型时的过程。

**Step 1选择神经网络的架构**

![输入图片说明](https://images.gitee.com/uploads/images/2020/1130/173336_6da22807_5550632.png "屏幕截图.png")

这一步主要要明确的是，**输入的特征向量维度**和最终神经网络**输出的输出单元**，同时选择隐藏层的数量和神经元的个数。当存在多层隐藏层时，在目前阶段我们推荐选择的神经元个数都和前一个隐藏层相同。（通常情况下，隐藏层越多越好）

**Step 2 随机初始化参数**

如同其字面意思，针对之前所选择的神经网络架构，随机初始化每层神经网间的权重矩阵。

**Step 3 实现前向传播对于每个x^(i)^得到其假设函数h_θ_(x)**

**Step 4 实现代价函数 J(θ) 的代码**

**Step 5 实现反向传播算法，计算偏导数**

![输入图片说明](https://images.gitee.com/uploads/images/2020/1130/174945_08d481b1_5550632.png "屏幕截图.png")

大佬强烈建议在初次实现前向和反向传播算法时，使用for循环来实现

**Step 6 使用梯度检测算法来验证第一次用反向传播算法计算出的偏导数值**

之后，$\color{red}{停止梯度检测程序}$

**Step 7 使用梯度下降或其它高级优化算法来对 J(θ)[关于参数θ的函数] 做最小化**

##### 直观理解梯度下降在神经网络中的作用

![输入图片说明](https://images.gitee.com/uploads/images/2020/1130/175734_008ec2e6_5550632.png "屏幕截图.png")

上图为*代价函数在第 l 层神经网络中，从权重矩阵中仅选择两个参数的可视化假设图*，说人话就是，我们画了一个代价函数在不同参数取值时的函数值。由于我们只能理解3维图像，这里就取了两个模型参数作为函数的输入，实际上它是n维的。图像中的每个点代表**一组参数所对应的代价函数值**，反向传播的作用相当于**选择向哪个方向做梯度下降**，梯度下降的作用就是**负责在这个选定方向上下降多少**，最终我们可以得到一个局部最小值。使得：

$$
h_\theta(x^{(i)}) ≈ y^{(i)}
$$

只不过我们此时的假设函数的表示形式为神经网络中每一层的线性组合。

<br>

## Part 11 机器学习诊断法 (Machine Learning diagnostic)

在完成一个机器学习项目时，如何评估算法的性能好坏，如果发现效果不好，我们应当如何改进自己的算法模型，以房价预测为例，我们有如下的处理办法：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1130/181648_eacc35bf_5550632.png "屏幕截图.png")

> 获得更大的数据集
>
> 使用更少的特征值
>
> 试图增加新的特征值
>
> 试图在假设函数中加入多项式
>
> 增加λ
>
> 减小λ

有没有一种简单有效的方法来选择上述优化方法从而避免浪费不必要的时间，避免不必要的努力呢？这章我们要讲的内容就是这个，在此之后我会通过这一套方法来实现基于神经网络的项目（又到了喜闻乐见手撸机器学习源码的时候呢）。

### 11.1 评估假设函数

在对假设函数进行评估前，我们一般采用一种标准化的流程，实际上，我在之前的房价预测案例中已经无形的使用了这种方式。

> 1. 分割数据集
> 2. 对测试集运行代价函数，以便评估

一般我们习惯将数据集分为**70%训练集，30%测试集**

![输入图片说明](https://images.gitee.com/uploads/images/2020/1130/183132_1e224cfc_5550632.png "屏幕截图.png")

像图中红色方框内的数据就是测试集的第一组数据，并记下标test。如果数据集中的数据不是随机排列的，那么建议我们随机选择70%的数据作为训练集。之后，就是将使用测试集训练出的参数代到代价函数中（如果是线性回归是这样的），计算**测试集的代价函数值**。

![输入图片说明](https://images.gitee.com/uploads/images/2020/1130/183526_0b9575b8_5550632.png "屏幕截图.png")

如果是逻辑回归，则同理：

$$
J_{test}(\theta)=-\frac{1}{m_{test}}\sum_{i=1}^{m_{test}}y_{test}^{(i)}log\;h_\theta(x_{test}^{(i)})+(1-y_{test}^{(i)})log\;h_\theta(1-x_{test}^{(i)})
$$
如果是0-1分类问题，我们就设计一个误差函数：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1130/184216_dc1468b6_5550632.png "屏幕截图.png")

它的含义就是：当假设函数输出值大于0.5 ，但真实值为负类，或者当分类为负类时实际为正类时，我们将其置为1（就是分类分错的时候）

分类分正确了，函数值为 0。

最后，我们对测试集的误差估计就是:

$$
Err_{test} = \frac{1}{m_{test}}\sum_{i=1}^{m_{test}}err(h_{\theta{test}}(x^{(i)}),y_{test}^{(i)})
$$

### 11.2 模型选择问题

我们现在依旧假设有一个房价预测的问题，它有如下10个假设函数：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1201/132645_6ee08e5e_5550632.png "屏幕截图.png")

d为多项式的最高次方。

按照我们之前的做法，我们会将数据集一分为二，用训练集训练模型，用测试集测试模型，**并选出代价函数值最小的那个多项式为假设函数**。但其实这样做是错误的，这样算出来的代价函数值不能代表该模型在其它数据集上的**泛化能力**。什么是泛化能力？其实就是模型由于过拟合导致无法适配其它数据的现象。下图为上述方法选择模型的可视化流程：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1201/133019_1fba0da8_5550632.png "屏幕截图.png")

计算代价函数值本身没错，只不过是数据选择的问题，所以最终我们决定采用如下的数据集分配方式：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1201/133242_f9da934a_5550632.png "屏幕截图.png")

我们将数据集分为**60%训练集，20%交叉验证集(Cross Validation Set)，20%测试集**

我们依旧采用相同的记法记录数据

$$
x_{cv}^{(i)},y_{cv}^{(i)}
$$
随后我们用**交叉验证集的代价函数值来评估模型的好坏**，选择最小的模型之后，我们使用测试集**最终测试数据集的泛化能力**

![输入图片说明](https://images.gitee.com/uploads/images/2020/1201/133537_ded7cb9b_5550632.png "屏幕截图.png")

![输入图片说明](https://images.gitee.com/uploads/images/2020/1201/133737_a411e9a5_5550632.png "屏幕截图.png")

还是之前的场景，假设四次多项式的交叉测试集的代价函数值最小，我们选择*d= 4*的模型，并评估其在测试集上的代价函数值**(泛化误差值)**。

<br>

### 11.3 诊断偏差与方差

#### 11.3.1 偏差与方差

在机器学习算法中，一个模型只会出现两种情况，**过拟合和欠拟合**的问题，那我们如何来评估一个机器学习算法是过拟合还是欠拟合呢？一般来说$\color{red}{欠拟合就是出现了偏差问题，而过拟合就是出现了方差问题}$。

![输入图片说明](https://images.gitee.com/uploads/images/2020/1201/135423_d959e62b_5550632.png "屏幕截图.png")

这张图我们可熟悉了，左侧第一张就是由于采用了低次函数拟合数据集导致发生了**欠拟合**的现象，最右侧的图像就是我们熟悉的**过拟合**图像了。我们来画一画

$$
J_{train}(\theta)\\
J_{cv/test}(\theta)
$$
这两个关于误差的图像吧。

![输入图片说明](https://images.gitee.com/uploads/images/2020/1201/135804_a344ce8a_5550632.png "屏幕截图.png")

$\color{purple}{粉紫色}$：代表训练集的代价函数值（函数值越小，误差越小）

$\color{red}{红色：}$代表交叉验证集或者测试集的代价函数值

随着多项式的次数增加当然训练集的代价函数值会**减小**，甚至会到 0 ，但是由于过拟合数据集，会导致无法很好的拟合交叉验证集的数据，就会导致**交叉验证集的代价函数值飙升**。

![输入图片说明](https://images.gitee.com/uploads/images/2020/1201/140513_3ee999e1_5550632.png "屏幕截图.png")

一般而言，当

$$
J_{train}(\theta)\;很大\; \\
\;J_{cv}(\theta)≈J_{train}(\theta)
$$

时，我们认为算法出现了偏差问题，即欠拟合问题，**需要调高多项式的最高次数**

当

$$
J_{train}(\theta)\;很小\; \\
\;J_{cv}(\theta)>>J_{train}(\theta)
$$
时，我们认为算法出现了方差问题，即过拟合问题，**需要降低多项式的最高次数**

#### 11.3.2 正则化和偏差与方差的关系

可能大家已经忘记了什么是正则化，正则化就是用于**梯度下降时所添加的那个惩罚项**。如同下述公式中的那个小“尾巴”

$$
J(\theta) = \frac{1}{2m}\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})^2 + \frac{λ}{2m}\sum_{j=1}^{m}\theta_j^2
$$

**※注意区分概念，代价函数$\color{red}{用于评估模型拟合结果的好坏}$，带有正则化项的代价函数则是$\color{red}{用来训练模型，作为优化对象应用于梯度下降算法的(梯度下降时用带正则化项的代价函数，评估误差时去掉正则项)}$**。

我们看一看，正则化参数λ过大过小会引发哪些问题：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1202/185041_fa58f10a_5550632.png "屏幕截图.png")

如上图所示，**当λ过大**，导致惩罚过大，梯度下降时值减的太厉害，导致所有的模型参数均较小，最后的假设函数就像是一条常函数。其结果就是**欠拟合**。

如果**λ过小**，导致梯度下降时，梯度下降得很慢，最终模型过拟合数据集。只有挑选一个适中的λ，模型效果才是最优的。在训练模型时，我们选择带有正则项的代价函数做梯度下降，在**挑选，评估模型**时，我们计算的训练集的代价函数，交叉验证集的代价函数以及训练集的代价函数均**不带正则项**。

![输入图片说明](https://images.gitee.com/uploads/images/2020/1202/185620_6d555777_5550632.png "屏幕截图.png")

随后，我们假设若干λ的值，对 J(θ) 进行梯度下降，得到一系列模型参数，如下图所示：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1202/185928_433dcc25_5550632.png "屏幕截图.png")

随后我们用交叉验证集测试，找出代价函数最小的λ参数，假设这里我们找到的是**λ = 0.08**，最后我们用测试集测试这个模型，看看测试集下的代价函数值。如果将λ和代价函数值一起可视化，可以得到如下图像（理想状况）：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1202/190654_7c83f6b2_5550632.png "屏幕截图.png")

当λ取值较小时，蓝色的训练集代价函数值会很小，因为很可能出现**方差问题，导致过拟合**，当λ较大时，对每个模型参数的惩罚都相对较大，很可能出现**偏差问题，导致欠拟合**。而交叉验证集则相反，当λ很小时，模型过拟合，导致效果不好，代价函数值大，当λ很大时，模型几乎不拟合数据集，效果不好，出现偏差问题，代价函数值大。

### 11.4 学习曲线 (Learning curves)

通过综合上面所学，我们可以得到一种判断模型处于哪种问题下的方法，它就是**学习曲线**。我们先看一下学习曲线是怎么来的：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1203/181130_4745e453_5550632.png "屏幕截图.png")

**在选定一个模型后**，我们记**实际所使用的数据集数据条数为m**，如上图，我们选定的假设函数为

$$
h_\theta(x) = \theta_0+\theta_1x+\theta_2x^2
$$
这样的二次函数，用一条数据训练模型，当然能很好地拟合数据，就算使用正则化，那最后训练集上的代价函数值也不会很大，随后我们增加训练模型的数据数目，会发现随着数据量的增大，假设函数越来越难来拟合数据集，那么训练集的代价函数值会逐步上升。

我们反观，交叉验证集或者是测试集的代价函数值。由于刚开始我们使用一条数据进行训练，当然模型的泛化能力差，代价函数值高。随着训练集规模的增加，假设函数拟合的相对较好，交叉验证的代价函数值就会缓慢下降。

换句话说，学习曲线可以**评估训练集规模对同一模型的两种不同代价函数值(训练集下的代价函数值，交叉验证集下的代价函数值)**，进而可以用于评估模型是出现了偏差问题，还是方差问题。

我们先看看在高偏差情况下的学习曲线：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1203/182215_5f2676ee_5550632.png "屏幕截图.png")

我们选取一次函数作为假设函数（一条直线）。在训练集较小时，如m=1,2时，当然用直线拟合没有问题，所以应用训练集的模型的代价函数很小，随着训练集的增加，直线还是直线，无论再怎么扩大数据集，基本上代价函数值都不会发生改变了，如同上图紫色图像。同理，应用交叉验证集的模型随着数据量的增大，会逐步减小。最后就给大家呈现出了一种**J~cv~(θ) 和 J~train~(θ)最终持平的效果**，

同时我们会发现，在高偏差情况下，**增加数据集的数目是没有帮助的**。我们再看看高方差下的学习曲线：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1203/182952_d893c33c_5550632.png "屏幕截图.png")

由于采用高阶多项式拟合数据集，最终会过拟合，随着数据集的增加，当然 J_train(θ)会增加，因为拟合的难度会增加，而且由于过拟合，导致模型泛化能力差，J_cv(θ)也居高不下，图像开始会呈现出一个**差距gap**，**然后随着训练集数据的增加而有所改善，最终两条曲线趋于平稳**。

那么一个比较理想的学习曲线就应该是**低方差，低偏差，收敛且误差值小**，学习曲线如下图所示：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0225/161936_637454fd_5550632.png "屏幕截图.png")

那么我们回到之前所说的房价预测例子上：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1204/132133_0977ea56_5550632.png "屏幕截图.png")

之前我们给出了若干种解决方案，如果我们画出了学习曲线，我们就能明确地选择出对应问题的解决方法。

如果是**高方差问题 (high variance)**，我们可以：

1. 增加训练集的规模
2. 减少特征向量数目
3. 增加正则化参数λ(λ越小，惩罚代价越小越容易出现过拟合的现象)

如果是**高偏差问题 (high bias)**,我们可以：

1. 添加新的特征向量
2. 使用更高阶的多项式
3. 减小正则化参数λ

![输入图片说明](https://images.gitee.com/uploads/images/2020/1204/132918_b7d9d2d7_5550632.png "屏幕截图.png")

一般而言那种“小型”的神经网络（参数和隐藏层数目都少），参数更少，更可能出现欠拟合的问题，但是胜在计算量小

而那种“大型”的神经网络，往往性能更好，但是可能会出现过拟合的情况，我们一般可以采用调整正则化参数的方式来改善模型质量。

当我们不知道应该使用多少层隐藏层时，我们可以通过**计算不同数目隐藏层下的 J~cv~(θ) 来评估选择什么样的模型**。



<br>

## Part 12 机器学习系统设计

### 12.1 情景引入

假设现在我们要做一个垃圾邮件分类器：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1204/134642_9b2b2bb9_5550632.png "屏幕截图.png")

左子图是一封垃圾邮件，右面的不是。我们如何训练一个分类器来进行邮件分类呢？

我们第一步当然是要取**选择特征向量**了

![输入图片说明](https://images.gitee.com/uploads/images/2020/1204/134826_f8062df6_5550632.png "屏幕截图.png")

如上图，我们可以这样简单地建立特征向量。

首先，选出垃圾邮件中可能出现的单词，比如：*deal*,*buy*,*discount*,*now*,……

然后，对于一封邮件，我们将找到该单词的位置置为 1，未找到就置为 0

$$
x_j = 1 第j个位置的单词出现了\\
x_j = 0 第j个位置的单词未出现
$$

通过这种方法，我们就得到了一个简单的特征向量。当然了，我们也可以按照下面列出的思路去设计更复杂的特征向量：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1204/135254_a86a6e66_5550632.png "屏幕截图.png")

1. 收集更多的数据
2. 设计可以包含邮件发送人的特征向量
3. 同一字母的不同大小写
4. 字母内部穿插数字

……

所以，大佬推荐的开发过程是：

1. 快速地实现一个简单粗暴的模型
2. 应用学习曲线来决定，进行何种优化
3. 误差分析

所以，这种开发模式不像是我们所想的像造大坝那样的庞大的预测式项目，而像是**基于快速原型模型开发的项目**。举一个具体例子

![输入图片说明](https://images.gitee.com/uploads/images/2020/1204/141911_2de6b837_5550632.png "屏幕截图.png")

我们先实现一个邮件分类器，使用交叉验证集检验模型，发现算法在500个验证数据中错误地分了100封邮件，那么接下来我们就要**人工地**对这些数据进行分析，比如我们发现：

> 医药广告：12条
>
> 虚假消息：4条
>
> 钓鱼邮件：53条
>
> 其它：31条

在这些邮件中，我们发现它们可能会出现以下情况：

> 错误拼写：5条
>
> 特殊的邮件路径：16条
>
> 特殊的标点符号：32条

此时，我们就可以针对钓鱼邮件和标点符号设计更复杂的特征向量。那么我们再细节一点，如果单词中出现*discount,discounting，discounted，discounts……*这些词，我们是将它们看成一个特征好，还是分开看好呢？单词的大小写区分是不是会影响到模型的准确度呢？此时，我们迫切地希望可以存在一种**量化指标来评估模型的效果**，这就是接下来要讲的误差分析。

### 12.2 误差分析

#### 12.2.1 偏斜类问题(Skewed classes)

机器学习分类模型存在一种情况叫**偏斜类**。偏斜类简单理解就是在训练模型时由于正样本和负样本数目之间的严重不平衡，导致模型最后检测全部都是1或者全部都是0，我们有如下一个肿瘤分类问题：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1204/152038_b70c15e7_5550632.png "屏幕截图.png")

假如我们发现我们的模型正确率为99.2%，误差为0.8%，但是我们在测试集中只有**0.5%的患者**，此时，如果我们单纯地返回0，只会造成0.5%的误差，所产生的效果甚至优于机器学习模型的效果，“模型正确率”为99.5%。所以我们能够得出一个结论，**简单地使用正确率，错误率来检验模型误差是不合适的**，因此我们引出两个指标用于评估模型的误差。我们先画出如下的一张图：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1207/175342_9bc70054_5550632.png "屏幕截图.png")

##### 查准率 （Precision）

**查准率/准确率**是针对我们**预测结果**而言的，它表示的是预测为正的样本中有多少是真正的正样本。那么预测为正就有两种可能了，一种就是把正类预测为正类(TP)，另一种就是把负类预测为正类(FP)，也就是
$$
Precision = \frac{TP}{TP+FP}
$$

举个例子就是，**在我们预测为阳性的患者中，真正的阳性的比例为多少**。

##### 召回率 （Recall）

而**召回率**是针对我们原来的**样本**而言的，它表示的是样本中的正类有多少被预测正确了。那也有两种可能，一种是把原来的正类预测成正类(TP)，另一种就是把原来的正类预测为负类(FN)。
$$
Recall=\frac{TP}{TP+FN}
$$

举个例子就是，**在样本中，有多少比例的患者被正确被确诊为阳性**。

比如对于一个只是返回0的模型，它的召回率就是0（它不存在真阳性的情况），那它就不是一个好模型。

我们通常将**很少出现的情况置为正类（y = 1），在本例中恶性肿瘤为正类，良性肿瘤为负类**。

<br>

#### 12.2.2 查准率和召回率的权衡

准确率和召回率都是越高越好吗？实则不然。我们接着讨论癌症分类的问题，我们记患癌症 y = 1，否则 y = 0。

我们的假设函数会输出一个[0,1]间的数，为**患癌症的概率**。如果我们将h(x)的输出阈值设为0.9，即 h(x) > 0.9时，y = 1。那么此时，我们会拥有很高的查准率，较低的召回率。较高的阈值，**我们预测病人为真阳性的概率会很高，但是会出现由于阈值设置过高而忽略的假阴性**。而较低的阈值，**我们确实可以找出很多阳性的患者，但是对于是否为真阳性这种情况，我们的准确度会降低**。

总的来说就是，**高查准率带来了较低的召回率，反之亦然，鱼和熊掌不可兼得**，如何选择出效果最优的模型，就是本节要讲述的内容。

![输入图片说明](https://images.gitee.com/uploads/images/2020/1208/195909_48fe752a_5550632.png "1.png")

上图是什么意思呢？上图表示，准确率和召回率会随着采用的模型不同而发生改变，**不同模型之间的查准率和召回率间没有直接联系**，算法1的0.1查准率和算法2的0.1查准率的含义是不同的，因为它们的图像不同。那么我们如何寻找一个指标来评估呢？

![输入图片说明](https://images.gitee.com/uploads/images/2020/1208/195940_b70d294a_5550632.png "2.png")

如上图，我们不采用平均值作为评估指标，因为当其中一个值极大时，可能会拉高整体均值，如算法3。所以，我们转而使用 f （或者f1） 作为评审指标，它越大，模型的效果就越好。

F1计算方式为：
$$
P为查准率,R为召回率
\\F_1Score = 2\frac{PR}{P+R}
$$


<br>

### 12.3 数据集的规模与机器学习算法

在之前的学习中，我们知道了机器学习算法会出现高偏差或高方差的问题，为了获得一个高性能的机器学习模型，我们一般采用**模型参数多的，使用大量数据训练**的方法来获得模型。模型参数多而复杂可以避免偏差问题，训练的数据量大可以避免方差问题。

<br>



## Part 13 支持向量机 (Support Vector Machine)

### 13.1 支持向量机的引出

支持向量机是监督学习中的一种二元分类器，具体数学原理我们之后再讨论，先看看支持向量机是怎么来的。

以二分类问题为例，我们有如下的假设函数：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1208/202518_087ebad1_5550632.png "屏幕截图.png")

我们记

$$
z = \theta^Tx
$$

那么当y=1,正类时，h(x) ≈ 1，z >> 0

那么当y=0,负类时，h(x) ≈ 0，z << 0

接着，我们就要对代价函数进行最小化，使用逻辑回归算法时，一条数据的损失函数值的计算公式如下：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1208/202857_56ed962d_5550632.png "屏幕截图.png")

这里把负号移到括号内部了。

我们以y=1为例画出函数图像：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1208/203040_3d098fbd_5550632.png "屏幕截图.png")

支持向量机做的就是用下图这条紫色的函数来代替原来的函数，当y=0时也同理：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1208/203204_832b4290_5550632.png "屏幕截图.png")

![输入图片说明](https://images.gitee.com/uploads/images/2020/1208/203354_26b2ce74_5550632.png "屏幕截图.png")

在这里插一句，此时我们计算的是**单个样本的代价值**，当数据为正类时，我们的z会远大于零，自然h(x)≈1，代价值小。如果预测错了，即z<<0,h(θ)≈0，那么代价就会变大。然后，我们给它们分别命名:

![输入图片说明](https://images.gitee.com/uploads/images/2020/1208/203711_7d0729fd_5550632.png "屏幕截图.png")

cost_0(z)代表代价函数中 y=0 时的函数.

cost_1(z)为代价函数中 y=1 时的函数.

接着我们看看新的代价函数：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1208/203955_43428945_5550632.png "屏幕截图.png")

我们用新函数代替log的复合函数，同时去掉常数项1/m。其实去掉常数项不影响最小化的结果，如上图红字示例所示（对原来的式子进行了适当的放大，对原来的代价函数进行了线性近似）

得到：

$$
min_\theta\;\sum_{i=1}^{m}y^{(i)}cost_1(\theta^Tx^{(i)})+(1-y^{(i)})cost_0(\theta^Tx^{(i)}) + \frac{λ}{2}\sum_{j=1}^{m}\theta_j^2
$$

在逻辑回归中，我们可以把代价函数拆成如下两个部分：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1208/205340_d4db8738_5550632.png "屏幕截图.png")
$$
J(\theta)=A+λB
$$
它可以通过参数来调整是A项重要还是B项重要（当λ很小时，正则项的权重就更大）。在支持向量机中，我们换了一个新的表达形式：

$$
J(\theta) = CA+B\\
如果当\;C=\frac{1}{λ}时，支持向量机和逻辑回归所得到的模型参数应该相同
$$

最终，我们通过最小化如下函数，就得到使用SVM的模型参数：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1208/205828_1964c0aa_5550632.png "屏幕截图.png")

支持向量机输出的不是概率，而是最终的分类结果：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1208/205956_4d06fb09_5550632.png "屏幕截图.png")

### 13.2 对SVM的直观理解

我们来回顾一下支持向量机的代价函数（优化目标）：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1217/155344_60de69f6_5550632.png "屏幕截图.png")

对于这样的一个函数，**它如何才能取到最小值呢？**

当 y = 1 时，θ^T^x^(i)^ ≥ 1 ，cost~1~(θ^T^x^(i)^)的值最小，(1-y^(i)^)cost~0~(θ^T^x^(i)^)为零。

当 y = 0 时，θ^T^x^(i)^ ≤ -1 ，cost~0~(θ^T^x^(i)^)的值最小，y^(i)^cost~1~(θ^T^x^(i)^)为零。

接下来，我们考虑一种情况，**当 C 很大，如C=100000时，如何让SVM的代价函数尽量小呢？**当然是让C后面乘的项尽可能地小，为零最好。那也就意味着，支持向量机只剩下了最后一项。

![输入图片说明](https://images.gitee.com/uploads/images/2020/1217/160219_fb9ec68a_5550632.png "屏幕截图.png")

因为我们知道**前面那一堆的最小值就是0**，那么最终我们需要最小化的函数就是：
$$
min_\theta \; \frac{1}{2}\sum_{j=1}^{n}\theta_j^2
$$
因此，我们会得到一个很有趣的**决策边界**，如下图所示:

![输入图片说明](https://images.gitee.com/uploads/images/2020/1217/161411_71d87bf1_5550632.png "屏幕截图.png")

支持向量机做出的决策边界和其它的决策边界不同，它能使正负类之间的“间隔”尽可能地大。下图展示的是SVM产生的决策边界和其它决策边界的区别，其中黑色的为SVM的决策边界，可以看出它是最大化支持向量的边界的：

<img src="https://images.gitee.com/uploads/images/2020/1217/161717_9186cf65_5550632.png" alt="输入图片说明" title="屏幕截图.png" style="zoom:67%;" />

最后一点，支持向量机对噪声很敏感，尤其是当C很大的时候。下图是两种不同情况下的决策边界示意图：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1217/162413_71405c0b_5550632.png "屏幕截图.png")

<br>

### 13.3 大间隔分类器的数学原理-初步

既然支持向量机又叫大间隔分类器，从上节中我们已经看到了“间隔”的直观表现形式，那么它是通过何种数学原理呈现的呢？

首先，我们先复习一下向量的点乘，向量点乘有两种定义方式，代数方式和几何方式
$$
v=[v_1,v_2]\;u=[u_1,u_2]
\\u^Tv=?
\\代数定义:u_1*v_1+u_2*v_2
\\几何定义:||v||*||u||*cos\theta \;其中||v|| = \sqrt{v_1^2+v_2^2}
$$
![输入图片说明](https://images.gitee.com/uploads/images/2020/1214/143604_f71db46b_5550632.png "屏幕截图.png")

由上图，我们就得出了一个推论：
$$
u^Tv=u_1*v_1+u_2*v_2= P*||u||(P为v在u上的投影长度)
$$
由于P的正负取决于夹角θ，若θ>90°，cos θ < 0。

接下来，我们来规定支持向量机的假设函数，代价函数。

假设函数：
$$
h_\theta(x)=\left\{
\begin{aligned}
1 & &\theta^Tx≥0 \\
0 & & otherwise\\
\end{aligned}
\right.
$$
代价函数:
$$
s.t.
\; \theta^Tx^{(i)}≥1 \;if \;y^{(i)} = 1 \\
\theta^Tx^{(i)}≤-1 \;if \;y^{(i)} = 0
\\
J(\theta) =\frac{1}{2}\sum_{j=1}^{n}\theta_j^2
$$
我们使每次为正类样本时的向量内积≥1，反之≤-1。由于之前我们画出了支持向量机的图像，所以在此就直接使用该函数图像的结果。

![输入图片说明](https://images.gitee.com/uploads/images/2020/1208/203711_7d0729fd_5550632.png "屏幕截图.png")

当 n=2 时，我们可以有如下推论：
$$
\frac{1}{2}\sum_{j=1}^{2}\theta_j^2 = \frac{1}{2}(\sqrt{(\theta_1^2+\theta_2^2)})^2\\
=\frac{1}{2}||\theta||^2
$$
那么将θ与x的向量点乘类比到u,v上，我们就可以得到如下结论：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1214/145927_d7b77f5d_5550632.png "屏幕截图.png")

那么就可以这么书写：
$$
\theta^Tx^{(i)} = P^{(i)}||\theta||
$$

$$
s.t.
\;  P^{(i)}||\theta||≥1 \;if \;y^{(i)} = 1 \\
 P^{(i)}||\theta||≤-1 \;if \;y^{(i)} = 0\\
 min_\theta \; \frac{1}{2}\sum_{j=1}^{n}\theta_j^2=\frac{1}{2}||\theta||^2
$$

假设有这样一条决策边界（绿色）：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1214/150819_2406eb79_5550632.png "屏幕截图.png")

正类为红色的图案，负类为蓝色的图案。
$$
∵x^{(1)}是正类\\
∴p^{(1)}*||\theta|| ≥ 1且p^{(1)}为定值
\\∴||\theta||值会大，与最小化的目标冲突\\
同理,x^{(2)}为负类,p^{(2)}*||\theta|| ≤ -1且p^{(2)}为定值\\||\theta||值会大，与最小化的目标冲突
$$
所以上面这条分割线其实不是最终SVM找到的那条。实际上，支持向量机会寻找类似下图的分类边界，找出**支持向量投影长度尽量长，但参数向量θ范数尽量小的分界线**，这也就是大间隔的由来。

![输入图片说明](https://images.gitee.com/uploads/images/2020/1214/151634_453dda9f_5550632.png "屏幕截图.png")

顺带提一下为什么**决策边界和参数向量θ正交**，以下图为例，我们规定了
$$
\theta^Tx^{(i)}≥1 \;if \;y^{(i)} = 1 \\
\theta^Tx^{(i)}≤-1 \;if \;y^{(i)} = 0
$$


![输入图片说明](https://images.gitee.com/uploads/images/2020/1214/152323_a4339890_5550632.png "屏幕截图.png")
$$
当-1<\theta^Tx^{(i)}<1时，其实就是决策边界的图像范围，我们不妨设决策边界(绿线)为:\\\theta^Tx^{(i)}=0\\
\theta_1*x_1 + \theta_2*x_2 = 0,K_{决策边界} = -\frac{\theta_1}{\theta_2}\\
θ向量(蓝线)由于\theta_0 = 0始终过原点，斜率K_{theta} = \frac{\theta_2}{\theta_1}\\
两斜率乘积为-1，相互垂直，所以两向量正交
$$

### 13.4 核函数

我们希望能对复杂的高阶多项式做分类器，按照之前的做法很难实现，所以我们来介绍一个用于非线性函数边界确定的方法。

![输入图片说明](https://images.gitee.com/uploads/images/2020/1214/180852_ad135a7f_5550632.png "屏幕截图.png")

如上图，我们拥有一个高阶非线性函数，我们记每项特征的组合为 f~1~,f~2~,……
$$
g(x) = \theta_0+\theta_1x_1+\theta_2x_2+\theta_3x_1x_2+\theta_4x_1^2+\theta_5x_2^2+……
\\
f_1=x_1,f_2=x_2,f_3=x_1x_2,f_4=x_1^2,……
$$
接着我们**手动地**在n为特征向量构成的空间中，选出标记点 l

![输入图片说明](https://images.gitee.com/uploads/images/2020/1214/181428_ce81599d_5550632.png "屏幕截图.png")



上图中所选取的特征向量为二维特征向量，它们构成了一个平面，我们在这个平面上寻找出3个**标记点**，接着，我们来**计算空间中的点距离标记点的相似度**。
$$
给定空间上任意一点x\\
f_1 = Similarity(l^{(1)},x) = e^{-\frac{||x-l^{(1)}||^2}{2 σ^2}} <=>exp(-\frac{||x-l^{(1)}||^2}{2 σ^2}))\\
f_2 = Similarity(l^{(2)},x) = exp(-\frac{||x-l^{(2)}||^2}{2 σ^2})\\
f_3 = Similarity(l^{(3)},x) = exp(-\frac{||x-l^{(3)}||^2}{2 σ^2})\\
$$


上述所说的**相似度函数**，就是**核函数(kernel function)**，这里我们使用的是高斯核函数。我们会将**Similarity(a,b)写为k(a,b)**

举个例子：
$$
If  \quad x ≈ l^{(1)}\\
f_1 ≈ k(l^{(1)},x) ≈ exp(-\frac{0}{2 σ^2})≈1/e^0 ≈ 1\\
If \quad x 远离l^{(1)},假设为+∞\\
f_1 ≈ k(l^{(1)},x) ≈ exp(-\frac{+∞}{2 σ^2})≈\frac{1}{e^{+∞}} ≈ 0\\
$$


我们接着看一看核函数在几何上的体现。

![输入图片说明](https://images.gitee.com/uploads/images/2020/1214/183434_c6b67682_5550632.png "屏幕截图.png")

如上图，我们人工选择了一个标记点 l^(1)^ = [3,5]，如果选取特征x = [3,5]，它们重合，相似度此时最高为 1，如果更改σ的值，我们会得到下图中的结果。

![输入图片说明](https://images.gitee.com/uploads/images/2020/1214/184158_2d33d131_5550632.png "屏幕截图.png")

我们不难分析出，**σ影响了核函数的相似范围**，σ越大，相似的范围越宽泛，σ越小，相似的条件越严苛。

![输入图片说明](https://images.gitee.com/uploads/images/2020/1214/184712_97caff6b_5550632.png "屏幕截图.png")

我们通过**设定标记点，计算核函数的方式来替换了原来的特征**，如上图，如果我们有一个品红色的x，假设模型参数已知，那么对于品红色的x就有：
$$
\theta_0 = -0.5,\theta_1 = 1,\theta_2 = 1,\theta_3 = 0\\
f_1 ≈ 1,f_2≈0,f_3≈0\\
品红色x的值为0.5>0所以预测为正类\\
蓝色的点同理
$$

### 13.5 核函数与SVM

在讲核函数时，我们是人工地选取若干点作为标记点，但是在一个机器学习训练任务中，我们应该如何选择呢？

事实上我们直接将**训练样本点设置为标记点**，如下图所示：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1217/150853_d48404b9_5550632.png "屏幕截图.png")



最终得到 x^(m)^ 对应的 l^(m)^ .

那么带有核函数的SVM就可以归结为一下过程：

1. 选定训练集中的点作为标记点。

2. 对于一个从训练集或交叉验证集中选出的点，我们做**特征映射**

   > f~1~ = similarity（l^(1)^,x^(i)^）
   >
   > f~2~ = similarity（l^(2)^,x^(i)^）
   >
   > ...
   >
   > f~i~ = similarity（l^(i)^,x^(i)^） = 1
   >
   > ...
   >
   > f~m~ = similarity（l^(m)^,x^(i)^）

   得到的这个新向量，作为新的特征向量，即：
   $$
   f = [f_0,f_1,...,f_m] \;\;f_0 = 1\\
   h_\theta(x) = \theta^Tf \\
   if \;\;\theta^Tf ≥ 0\; predict \;1
   $$
   想得到参数向量θ，我们只需要对于下列函数做最小化即可：

   ![输入图片说明](https://images.gitee.com/uploads/images/2021/0125/172540_e92682f9_5550632.png "屏幕截图.png")



对于最后一项，将其向量化后可以看成：
$$
\frac{1}{2}\sum_{j=1}^m{\theta_j}^2 = \frac{1}{2}\theta^T\theta
$$
接着，我们来看一看关于参数选择与方差，偏差问题之间的关系。

由于我们是从Logistics Regression出发，推导的SVM，那么对于逻辑回归，我们可以将其代价函数看做：
$$
A+\lambda B
$$
正则化参数λ越大，对参数向量的惩罚越大，模型欠拟合导致高偏差问题。反之，造成高方差问题。

此时SVM可以看作：
$$
CA+B\;(当C=\frac{1}{\lambda}时,A+\lambda B = CA+B)
$$
此时，C越大(λ越小)，造成高方差，低偏差的问题，C越小(λ越大)，造成高偏差，低方差的问题（欠拟合）。

对于核函数中的σ^2^，则有下列结论：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0125/173945_4dc708c3_5550632.png "屏幕截图.png")

σ^2^过大，映射特征f更光滑，模型对变化更不敏感，高偏差，低方差。

反之，σ^2^过小，映射特征f 更陡峭，模型对变化更敏感，低偏差，高方差。

### 13.6 SVM的使用

根据大佬的指示，对于SVM我们不必从头到尾自己实现。毕竟在之后的练习中，大佬也只是自己写了个模型让我们调用。我好奇看了看源码，其中用到了一个叫SMO的优化算法来实现SVM。其原理，不是现在的我能攻克的。

对于调库，这工作就轻松多了，首先我们要确定SVM中的**参数C**，然后如果使用高斯核函数的话那就再指定一下**σ^2^**,如果不用核函数，即线性核函数的话，那就不用管了。

至于什么时候使用SVM，Logistics Regression和神经网络，大佬给了如下建议：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0125/203715_55b1cc1a_5550632.png "屏幕截图.png")

总的来讲就是，当特征值很多（相对与训练样本数量）时，我们可以使用逻辑回归或者无核的SVM

如果，特征值少，训练数量适中，选择带高斯核函数的SVM。

特征值少，训练样本很多，考虑添加更多的特征，使用逻辑回归或者无核的SVM

神经网络无论什么情况都适用。

具体的数值参考范围就看图片吧，这里我就不赘述了。



<br>

## Part 14 无监督学习 (Unsupervised Learning)

### 14.1 启航

就在此刻，我们迈入了机器学习的第二扇大门-无监督学习。在本博客开篇我们简单地介绍了一下无监督学习。现在，让我们重新地来认识一下它。

在监督学习中，我们的数据集是有标签的，此时我们通过假设函数来拟合数据集达成我们的目标，如下图所示：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0125/205321_28963647_5550632.png "屏幕截图.png")

但是在无监督学习中，我们希望计算机能够自动地分别出这些数据，这些相似的数据就是一个**簇（cluster）**，此时我们的训练集长这样，已经没有了标签，通过分簇算法将它们自行归类：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0125/205445_c4b9944a_5550632.png "屏幕截图.png")

无监督学习能做的事情有很多，比如分析社交网络，用户群体，探索银河系……

### 14.2 K-means算法

#### 14.2.1 算法流程概述

K-means算法是一个迭代算法，主要会进行两项工作，**簇分配**和**移动簇中心**，我们用图片来表示：

开始时，对于下图，我们随机出两个**簇中心**。

![输入图片说明](https://images.gitee.com/uploads/images/2021/0126/160802_9e52c3a2_5550632.png "屏幕截图.png")

接着我们开始簇分配，其实很简单就是遍历整个数据集**计算样本点到若干簇的距离**，取最小的距离的那个簇，标为一类，如同用颜色分类一样。

![输入图片说明](https://images.gitee.com/uploads/images/2021/0126/161014_4bab46ab_5550632.png "屏幕截图.png")

如上图，我们就将样本点按簇中心分为这两类了，接着我们要将**簇中心进行移动**。步骤很简单，计算现在红色点和蓝色点的均值，生成新的坐标点，然后让簇中心移动到该点处。如下图：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0126/161325_b459805b_5550632.png "屏幕截图.png")

然后重新进行簇分配，进行簇移动。

第二次簇分配和簇移动：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0126/161417_0f2035cf_5550632.png "屏幕截图.png")

第三次簇分配和簇移动：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0126/161505_1d03dbcd_5550632.png "屏幕截图.png")

所以对于K-means算法而言，只需要准备训练数据和K的大小就可以把数据分成K个簇了。

![输入图片说明](https://images.gitee.com/uploads/images/2021/0126/161701_b72b02b5_5550632.png "屏幕截图.png")

我们指定 K 个簇，K-means就会随机初始化 K 个簇中心。

接着开始迭代循环，在循环中要做两件事情：

1. 进行簇分配，从第1个样本遍历到第m个样本，给它们分配簇中心
   $$
   c^{(i)} = min_k(||x^{(i)}- \mu_k||^{2})
   $$
   
2. 移动簇中心，举个例子：
   $$
   若\;c^{(3)} = 3,c^{(1)} = 3,c^{(5)} = 3,c^{(8)} = 3\\
   x^{(3)},x^{(1)},x^{(5)},x^{(8)}均为簇3的点\\
   新的簇中心\;\mu_3=\frac{1}{4}[x^{(3)}+x^{(1)}+x^{(5)}+x^{(8)}]
   $$

所以我把K-means算法理解为**分K个簇的，簇中心平均值坐标算法**

#### 14.2.2 K-means 的代价函数（优化目标）

在开始说明K-means的代价函数（失真函数）前，首先说明一下若干变量。
$$
c^{(i)}=x^{(i)}样本点被分配的簇中心索引号\\
\mu_k = 第k个簇中心\\
\mu_{c^{(i)}} = x^{(i)}从属的簇中心编号
$$
这样，我们来看一下K-means算法的代价函数：
$$
J(c^{(1)},...,c^{(m)},\mu_1,...,\mu_K)= \frac{1}{m}\sum_{i=1}^{m}{||x^{(i)}-\mu_{c^{(i)}}||}^2\\
min_{c^{(1)},...,c^{(m)}\\\mu_1,...,\mu_K}J(c^{(1)},...,c^{(m)},\mu_1,...,\mu_K)
$$
通过这个公式，我们就能找到距离簇中心最近的点的集合和最优的簇中心。

#### 14.2.3 簇的随机初始化

现在，我们来介绍簇的随机初始化过程，下图总述了K-means的过程，那我们如何进行随机初始化呢？

![输入图片说明](https://images.gitee.com/uploads/images/2021/0127/143618_59057d44_5550632.png "屏幕截图.png")

我们采取的方式是**随机选择样本点**，来继续簇中心的初始化，举个例子：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0127/143730_ea09ef8b_5550632.png "屏幕截图.png")

首先，当然分的簇的个数不能大于样本点的数量（这不是废话吗(＠_＠;)），这里我们假设分两个簇。

然后就如同上图的右侧部分一样，如果脸好，随机的结果比较好，我们就可能得到图片右上方的结果。要是脸黑，我们就随机成右下方的结果。鉴于这种情况，一般而言在分簇数量在**2~10**的时候采用重复随机的形式来计算代价函数，取出最小的代价函数值，得到聚类结果。我们看图说话：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0127/144332_daf77f64_5550632.png "屏幕截图.png")

显然对于这个数据集，我们最好的聚类结果应该是最上面的那张子图。但由于随机初始化，我们就可能得到下面这两种图像，为了避免这个情况发生，我们会这样处理：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0127/144549_7d78a8b3_5550632.png "屏幕截图.png")

随机初始化k-means 50-1000次，每次都计算一个 代价函数J的值，最后选最小的函数值，那其中所有的参数（参数包括了每个点所分配的簇中心），就是最优的聚类结果。

#### 14.2.4 分簇的数量

大佬说，现在最常用的方式还是得到数据集的可视化视图，进行人工辨别得出分簇的数量。不过有时很难用肉眼观测出结果，如下图：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0127/145840_1a8ecca9_5550632.png "屏幕截图.png")

有人觉得它是可以分两个簇，有人觉得它是4个簇，甚至有人认为它是三个簇。由此可见有时肉眼不见得能很好地观察出来聚类结果。那么我们还有另外一种方式，叫做“肘部法则”，如下图：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0127/150109_dc833963_5550632.png "屏幕截图.png")

我们通过**增加聚类数量的方式来计算每一次增加时的代价函数值**，我们期望得到左侧图像这样的结果，这样我们就可以直接**取拐点**作为我们的分簇数量了。但是一般而言，我们得到的图像都是类似右侧的图像，图像很光滑，不太好找到那个“肘”。

通常，聚类结果是用于具体场景下的，比如卖T恤衫，我到底是将尺码分成（S，M，L）三类好，还是（XS，S，M，L，XL）五类好，这个得看实际的市场需要和顾客的满意程度，没有固定的答案。

![输入图片说明](https://images.gitee.com/uploads/images/2021/0127/150626_a590fced_5550632.png "屏幕截图.png")

### 14.3 第二类无监督学习-降维(Dimensionality Reduction)

降维，这个词听起来很高大上，其实很好理解。我们举个例子说明一下，假设我们有两维数据，其中一维数据用来描述物体长度单位厘米，另一维数据也用来描述物品长度，单位英尺。很显然，这两组数据**高度耦合**，本质上都是描述物体的相同信息-长度。我们画个图，表示一下上述文字：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0128/145509_b786998e_5550632.png "屏幕截图.png")

我们要做的就是用一个一维特征来替代这个二维的特征向量。

![输入图片说明](https://images.gitee.com/uploads/images/2021/0128/145918_bb0e1790_5550632.png "屏幕截图.png")

最简单的做法就是把原函数直接投影到一条直线上。那如果是n维特征值，想降成n-1维特征值，何解？其实也是做投影，比如将3维数据投影到一个二维平面上。如下图所示：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0128/150023_2ca76dd4_5550632.png "屏幕截图.png")

通过降维的方式使耦合数据压缩，进而我们可以减少存储空间的使用，同时提高学习算法的时间效率。不过，我有一些小猜测想留在这里。

1. 降维的过程像不像从一个坐标系变换到另一个坐标系的过程呢？或者说由一组基换成另一组基。
2. 降维的过程中势必会造成误差，这个误差能算出来吗？就像重积分中坐标转换一样会不会出现一个形如雅可比行列式这样的东西呢？
3. 是不是在特征高度耦合的时候，采用降维这个手段是最好的呢？

#### 14.3.1 降维的应用-数据可视化

对于下面这些关于经济的数据，貌似直接使用画图模块是没法画的，毕竟这是一个50维的数据，为了能将其呈现在画布上。我们需要将它将成2维数据。

![输入图片说明](https://images.gitee.com/uploads/images/2021/0128/151355_f303935f_5550632.png "屏幕截图.png")



![输入图片说明](https://images.gitee.com/uploads/images/2021/0128/151429_c434d55c_5550632.png "屏幕截图.png")

将50维的数据压缩成2维，我们就会得到如上图这样的二维数据，进而我们可以进行画图。则数据z1可能主要表示国家总体GDP情况，z2主要表示人均GDP情况。

![输入图片说明](https://images.gitee.com/uploads/images/2021/0128/151649_462050c4_5550632.png "屏幕截图.png")

接下来，我们就要学习这种名为**主成分分析PCA(Principal Component Analysis)**的算法来进行数据降维和数据压缩。

#### 14.3.2 PCA (Principal Component Analysis)

##### PCA的概述

假设我们有一个分布在二维空间上的数据集，此时我们像将其投影到一个一维直线上。

![输入图片说明](https://images.gitee.com/uploads/images/2021/0129/154351_100a4d24_5550632.png "屏幕截图.png")

我们要做的事情就是，找到一条向量，将点投影到该向量上，**以期许找到投影长度最短的那条向量**。再举一个三维空间上的例子，如下图，我们拥有一个分布在三维空间中的数据集。

![输入图片说明](https://images.gitee.com/uploads/images/2021/0129/154620_1988d197_5550632.png "屏幕截图.png")

我们要做的就是找到两个向量用来表示二维平面，使得3维空间的点投影至二维平面上的投影误差最小。同时，线性回归和PCA的工作是完全不同的。这主要是由于它们两个计算的目标不同。线性回归评价的是**预测值到真实值之间的误差**。而PCA是**投影距离尽量小**。

![输入图片说明](https://images.gitee.com/uploads/images/2021/0129/155347_60c9b240_5550632.png "屏幕截图.png")

那么，我们如何使得投影最小化呢？如何进行数据降维呢？

![输入图片说明](https://images.gitee.com/uploads/images/2021/0204/170841_091cc1ae_5550632.png "屏幕截图.png")



首先第一件事就是特征的**均值归一化**，如上图所示。对于PCA，接下来要做的事情就是寻找到两个重要的内容。

1. 一组比原特征空间**低维的一组基**
2. 新特征的数值映射值

就是下图的u向量和z映射：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0204/171436_5a8b4b07_5550632.png "屏幕截图.png")

至于如何得到这组向量涉及到复杂的数学推导公式，未来我可能会补上，但是现在能力有限，请允许我先忽略过去。首先引入**协方差矩阵**这一概念，计算公式如下:
$$
\sum=\frac{1}{m}\sum_{i=1}^m(x^{(i)}){(x^{(i)})}^T
$$
这个矩阵是一个n*n的矩阵((n\*1)\*(1\*n))，然后计算该矩阵的特征向量，想降几维，就选几列向量即可。对协方差矩阵的分析操作在Octave中使用的是SVD函数，声明如下：（SVD又称为奇异值分解 Singular Value Decomposition）
$$
[U,S,V] = svd(Sigma)
$$
我们取U这个返回值，U的结果如下图所示：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0204/172722_612743cb_5550632.png "屏幕截图.png")

取到了一组基，我们现在就开始做数值映射。

![输入图片说明](https://images.gitee.com/uploads/images/2021/0204/173501_20b41804_5550632.png "屏幕截图.png")

将n维数据压缩到k维，选取前k个向量后，我们给它起个新名字叫**U_reduce**,我们一个新的特征向量就是：
$$
Z = {U_{reduce}}^Tx \;(k*n)*(n*1)->(k*1)
$$
总结一下如何实现PCA。

1. 进行均值归一化
2. 计算协方差矩阵Σ
3. 调用svd奇异值分解函数
4. 选择U~reduce~ = U(：,1:k)
5. 计算z=U~reduce~^T^ \* x

挖个坑(PCA是如何最小化平方误差投影的)

##### 如何选择主要成分数量

在之前所计算出来的 U 矩阵中，你所选择的数量就是PCA的主要成分的数量，本小节是一些有关选择数量的建议。

![输入图片说明](https://images.gitee.com/uploads/images/2021/0204/175128_134f7222_5550632.png "屏幕截图.png")

其中 x_approx 是这样计算的
$$
x_{approx}^{(i)} = U_{reduce}^T*z^{(i)} 
$$
分式上方的算式计算的是平均投影误差，下方算式用来计算特征据坐标轴的举例，我们**尝试不同的k值使得满足上述不等式**。不等式右侧常用常数值为0.01，不过0.05也是可以的。接着我们如何写脚本实现上述过程呢？

![输入图片说明](https://images.gitee.com/uploads/images/2021/0204/180224_e7b70f95_5550632.png "屏幕截图.png")

一个迭代算法，取k=1计算若干参数，再应用不等式直到不等式成立，算法结束。迭代看起来很慢很傻，幸运的是，应用SVD我们能很快地计算出不等式的结果。**SVD第二个返回参数S是一个对角矩阵**，原不等式可以等价为
$$
1-\frac{\sum_{i=1}^kS_{ii}}{\sum_{i=1}^nS_{ii}} ≤0.01
$$
![输入图片说明](https://images.gitee.com/uploads/images/2021/0204/180907_72f5a9e1_5550632.png "屏幕截图.png")

所以我们只需要执行一次SVD，获得S这个对角矩阵然后不断计算这个不等式就行了。（当降维幅度较大时我们可以计算 算式≥0.99）

##### 压缩重现 （Reconstruction）

通过PCA我们可以得到降维的数据，那么我们怎么将降维的数据还原成原来的维度呢？

![输入图片说明](https://images.gitee.com/uploads/images/2021/0208/151507_5457b0c9_5550632.png "屏幕截图.png")
$$
z=U_{reduce}^Tx\\
x≈ x_{approx} = U_{reduce}z
$$
U~reduce~=(n,k)转置之后为(k,n),x为(n,n),那么z就是(k,n)

那么将其逆运算回去得到的x~approx~就是（n,n）近似为降维前的数据。

##### PCA应用时的小建议

我们可以将PCA应用到监督学习的场景下，以减少运算量。假设我们正在做一个计算机视觉的项目，得到了一个(100*100)的图片，这就包含了至少10000的特征值。我们现在想通过PCA降低模型的计算量，何解？

![输入图片说明](https://images.gitee.com/uploads/images/2021/0208/153246_80235eb5_5550632.png "屏幕截图.png")



首先我们对训练集做PCA，得到n维到k维的映射关系，然后将新特征z^(i)^代入学习算法中，上图是Logistics Regression。计算模型参数。当从测试集或交叉检验集中来的x^(i)^时，应用**从训练集得出的U~reduce~**进行降维，扔到学习算法中去。

**最好不要用PCA去尝试解决过拟合问题**，老师严正声明，这是因为PCA不使用标签y去降维，而且降维本身会带来误差，所以不要这样去做，如果过拟合，咱们为啥不用**调整正则化参数**，这种方法呢？

![输入图片说明](https://images.gitee.com/uploads/images/2021/0208/154231_7e69d0f9_5550632.png "屏幕截图.png")

最后，还是要嘱咐一句话**请不要滥用PCA算法，它很好用，不过请在应用它之前问一问自己，如果没有PCA学习算法会怎样呢？**

<br>

### 14.4 异常检测 (Anomaly Detection )

#### 14.4.1 问题背景

什么是异常检测，我觉得异常检测其实就是离群点检测。举个实际的例子，假设你是一个飞机引擎制造商，在引擎出厂时需要进行质量检测，会测量一系列特征参数，如震动频率啊，温度啊，什么的，我们要做的事情就是**从所有引擎中挑选出有问题的引擎**，详细展开说明其实就是对所有样本构造一个**概率分布模型**，P(x)<ε，所有小于阈值e的样本均为**异常样本**。

![输入图片说明](https://images.gitee.com/uploads/images/2021/0209/153401_73d368bf_5550632.png "屏幕截图.png")

#### 14.4.2 高斯分布（Gaussian distribution）

嗯，正态分布，主要就说说图像，参数和他们的含义吧

![](https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3530606917,2044115981&fm=26&gp=0.jpg)

这是一个标准的正态分布图像，其概率密度函数写在了图像下方，我们记x~N(μ,σ^2^)为样本x**服从**平均值为μ，标准差为σ的正态分布。图像的**对称轴为x=μ，σ决定了图形的胖瘦**，如下图所示：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0209/155004_5442bdca_5550632.png "屏幕截图.png")

**σ越小，函数图像“越瘦”，越大越胖**，同时，如果你对这个图形做积分，其结果一定是1，因为总体概率是1.

##### 参数估计

在我们的场景下，是已知观测的样本数据，假设它们服从正态分布，**估算出概率模型的参数，即μ和σ**，怎么算？（极大似然估计）

概率论内容，不想赘述，公式如下：
$$
\mu=\frac{1}{m}\sum_{i=1}^mx^{(i)}\\
\sigma^2=\frac{1}{m-1}\sum_{i=1}^m(x^{(i)}-\mu)^2
$$
事实上，对于方差的计算在机器学习领域中取m和m-1关系不大。

#### 14.4.3 异常检测算法

我们假设数据集中的样本的**每个特征值都独立同分布的**，并服从高斯分布。

![输入图片说明](https://images.gitee.com/uploads/images/2021/0210/172823_ff193627_5550632.png "屏幕截图.png")

那么对于每一个样本X,就会存在如下的公式：
$$
P(x) = P(x_1;\mu_1;\sigma_1^2)P(x_2;\mu_2;\sigma_2^2)P(x_3;\mu_3;\sigma_3^2)...\\
P(x)=\prod_{j=1}^nP(x_j;\mu_j;\sigma_j^2)
$$
所以对于异常检测算法它的工作流程是这样的：

1. 选取一些你觉得可能是异常的特征值x~i~

2. 计算均值与方差
   $$
   \mu_j=\frac{1}{m}\sum_{i=1}^mx^{(i)}_j\\
   \sigma^2_j=\frac{1}{m}\sum_{i=1}^m(x^{(i)}_j-\mu_j)^2
   $$
   
3. 给定一个新的样本x，计算P(x),如果P(x)<ε,则为异常点.

$$
P(x)=\prod_{j=1}^nP(x_j;\mu_j;\sigma_j^2)=\prod_{j=1}^n\frac{1}{\sqrt{2\pi}\sigma_j}exp(-\frac{(x_j-\mu_j)^2}{2\sigma_j^2})
$$

举个例子，看一看怎么进行异常检测。如下图，我们算出了特征值x~1~,x~2~的期望和标准差，它们的图像在右侧，其连乘的图像为左下角的3D图像。

![输入图片说明](https://images.gitee.com/uploads/images/2021/0210/174155_97150835_5550632.png "屏幕截图.png")

对于$\color{green}{绿色待测试的x_{test}^{(1)},x_{test}^{(2)}}$,我们计算出它们的概率值，然后与阈值进行比对，最后发现第一个样本是正常的，第二个样本是异常的。同时不难观测出，P(x)的3D图像上平面区域是异常区域。

#### 14.4.4 使用异常检测解决实际问题

当我们在试图选取一个特征值来决策是否将其放入异常检测算法中时，我们总能希望能找到一个指标值（实数值）来评估一个算法的好坏。所以，我们引入带有标签的异常检测算法。以飞机引擎检测为例，现在我们的每个样本自带一个标签，表示正常或异常。假设我们现在拥有**10000个正常飞机引擎的样本，20个异常的飞机引擎样本**。第一件事情就是**重新设计数据集**，新数据集的结构如下图所示：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0215/163647_32a416bd_5550632.png "屏幕截图.png")

然后我们使用训练集来拟合出P(x),$P(x)=\prod_{j=1}^nP(x_j;\mu_j;\sigma_j^2)=\prod_{j=1}^n\frac{1}{\sqrt{2\pi}\sigma_j}exp(-\frac{(x_j-\mu_j)^2}{2\sigma_j^2})$,其中$\mu_j=\frac{1}{m}\sum_{i=1}^mx^{(i)}_j\;
\sigma^2_j=\frac{1}{m}\sum_{i=1}^m(x^{(i)}_j-\mu_j)^2$。

接着，我们使用交叉验证集，来预测样本x

![输入图片说明](https://images.gitee.com/uploads/images/2021/0215/164053_32253790_5550632.png "屏幕截图.png")

此时，我们是不是就会得到一个预测结果的混淆矩阵啊，是不是忘了混淆矩阵长啥样了呢？我把它拿出来，复习复习。

![输入图片说明](https://images.gitee.com/uploads/images/2020/1207/175342_9bc70054_5550632.png "屏幕截图.png")

回忆一下，之前我们是如何权衡查准率和召回率之间的关系的，是不是使用一个叫F~1~Score的函数啊，它是怎么算的来着？
$$
P为查准率,R为召回率
\\F_1Score = 2\frac{PR}{P+R}
$$
这个值越大，不就代表模型效果越好吗，经过反复不断地在交叉验证集上选取不同的特征，不同的ε，使得F1函数值到达最大，最后在测试集上测试出所有数据。（在CV中做决策，在Test中得到最终结果）

#### 14.4.5 异常检测与监督学习的比较

异常检测做的工作是选择适当的特征值构造一个高斯函数，然后决策一个样本是否是异常点。而监督学习看起来做的是相同问题，无论是应用Logistics Regression还是SVM亦或是神经网络都可以做到分类的工作。那么我们什么时候使用异常检测又在什么时候使用监督学习算法呢？**简单来说，当数据集中正样本极多，负样本极少时，采用异常检测。正负样本数量都差不多大的时候，使用监督学习算法**。

异常检测主要应用在，*小网站的欺诈检测，飞机引擎的异常检测，计算机集群的主机检测，……*。

倾斜类时用异常检测，非倾斜类时用监督学习。

#### 14.4.6 异常检测的特征选择

首先，我们在选择特征之前，最好把该特征的结果可视化一下。这一步的目的是看一看该特征是否**满足高斯分布**。如果不满足最好对它进行一下变换（当然不做这步对算法的影响不大）

![输入图片说明](https://images.gitee.com/uploads/images/2021/0216/192658_9f78c5fa_5550632.png "屏幕截图.png")

变换的方式有很多，我们可以取对数，可以开根号。此时请化作调参侠，将一个特征值捏成高斯分布吧。第二步就是特征选取，很遗憾在这一步没有可以量化的指标来进行评估。不过有一个很浅显的道理，**特征选取的越多，所包含的信息就越多，在一个维度上检测不出来的问题，会在另一个维度上出现异常**，如下图：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0216/193139_ceab531e_5550632.png "屏幕截图.png")

图像的高度为近似的概率值。我们选取了x~1~这个特征作为算法的一部分，假设$\color{green}{绿色线条对应的是一个异常样本的特征值}$，此时如果仅看x~1~，算法是检测不出来异常的，因为此时的概率值并不小，如果我们如左图叠加一个新的特征值x~2~，分布在圈里的就是正常样本，而此时绿色样本的异常就被检测出来了。

换句话说，**异常检测的特征选择是取决于实际业务场景的。**如果想检测一个数据中心的计算机集群中是否有计算机出现异常，我们认为**CPU利用率，网络使用率为特征值x~1~,x~2~**。且它们是线性关系的，因为可能像在双十一购物节时，一台服务器需要为很多用户服务，导致这两个特征值都很高，此时为正常情况。但是，如果一个计算机出现代码的死循环，那么x~1~会很高，x~2~很低，此时我们就需要捏出一个新的特征值$x_3 = \frac{x_1^2}{x_2}$或者其它的特征。来表示这种异常情况，此时算法就会在一个新的维度上找到该异常主机。

#### 14.4.7 多元高斯分布

普通的高斯分布是不蕴含**特征之间的关系的**，就像上节处理的那样，需要人工创造新的特征值，来显示地描述。但是，多元高斯分布却可以描述特征之间的关系，举个例子。

我们这有一个数据中心监控计算机异常的任务，其中两个重要评判指标是**CPU使用率和内存占用率，x~1~,x~2~**，此二者本身线性关系假设它们两个特征的高斯分布图像长这样:

![输入图片说明](https://images.gitee.com/uploads/images/2021/0217/134056_1deaf769_5550632.png "屏幕截图.png")

现在有一个$\color{green}{绿色的异常点}$。分别看它的两个特征，概率都不小，于是之前我们采用连乘方式的单变量高斯分布模型会认为它是一个正常样例。而实际上它却是一个异常点。因此我们需要改变建模方式，**不再对每一个特征值单独建立若干个高斯分布，而是对所有特征值建立一个高斯分布**。

![输入图片说明](https://images.gitee.com/uploads/images/2021/0217/134158_7602ff36_5550632.png "屏幕截图.png")
$$
\mu∈R^n,Σ∈R^{n×n}(协方差矩阵)
\\P(x;\mu;Σ)=\frac{1}{(2\pi)^{\frac{n}{2}}|Σ|^\frac{1}{2}}exp(-\frac{1}{2}(x-\mu)^TΣ^{-1}(x-\mu))
$$
公式很复杂，不仅要求协方差矩阵的行列式，还需要求它的逆。那么我们此时化作调参侠，将这个函数可视化，看看都代表什么意思。

![输入图片说明](https://images.gitee.com/uploads/images/2021/0217/135117_42e46d1f_5550632.png "屏幕截图.png")

第一组参数，**$\mu不动，改变协方差矩阵Σ$**，当Σ=E为单位矩阵时，图像为最左边所示，为参照。当缩小x~1~对应的矩阵值时，图像变窄，放大，图像变宽。

第二组参数，协方差矩阵值缩小，图像变化瘦，尖

![输入图片说明](https://images.gitee.com/uploads/images/2021/0217/135449_8ad400c9_5550632.png "屏幕截图.png")

第三组参数，取负值：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0217/135624_c67127df_5550632.png "屏幕截图.png")

第四组参数，移动μ：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0217/135652_b44a0edc_5550632.png "屏幕截图.png")

由于笔者能力有限，只能用图像的方式描述多元高斯分布，更多细节请参考其它博主的博文。

#### 14.4.8 使用多元高斯分布的异常检测

上文中介绍了多元高斯分布，其中有两个重要参数：**μ，Σ**。如何估计这些参数呢？

![输入图片说明](https://images.gitee.com/uploads/images/2021/0217/140059_9e7da43b_5550632.png "屏幕截图.png")

μ是一个n维向量，估计方法就是对样本求平均值，Σ，协方差矩阵和PCA中的求法一样，公式参照上图。

![输入图片说明](https://images.gitee.com/uploads/images/2021/0217/141608_adb5f271_5550632.png "屏幕截图.png")

对于一个应用了多元高斯分布的异常检测模型，我们首先需要计算两个参数，μ和Σ。然后套公式计算即可。

那我们什么时候选择多元高斯分布的模型呢？如下表：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0217/141823_9d9d6f12_5550632.png "屏幕截图.png")

原始模型不会捕捉特征之间的关系，而多元高斯分布会。

原始模型，计算代价小，方便算。新模型代价大，毕竟要求协方差矩阵，求逆。

当数据量大于特征数量时，可以考虑选择多元高斯分布模型。

<br>

## Part 15  推荐系统 (Recommender System)

### 15 .1 问题场景

现在我们拥有一个电影推荐的项目，如下表，我们会有一些用户对电影的喜爱度评分。从0-5，那些用户没看过的就变成问号

![输入图片说明](https://images.gitee.com/uploads/images/2021/0219/144817_48ea3368_5550632.png "屏幕截图.png")

接着，我们来引入一些符号，来描述表格中的信息。
$$
n_u= \;no.users\;客户数量\\
n_m \;no.movies\;电影数量\\
r(i,j)=1\;第i个用户是否给第j个电影评过分\\
y^{(i,j)}=当r(i,j)=1时，用户的评分\;y^{(1,1)}=5
$$
我们要做的就是去预测这些问号值，然后结合该用户的观影习惯，如果没有看过，那么我们就给他进行推荐。

### 15.2 基于内容的推荐算法

假设，我们现在能评估出一个内容的度量特征值，我们若是以电影举例的话就将其简单评估为是**动作电影**还是**爱情电影**。我们就会得到这样的一张表。

![输入图片说明](https://images.gitee.com/uploads/images/2021/0219/150853_7000cd21_5550632.png "屏幕截图.png")

对于第一个电影，取爱情度量为0.9，动作度量为0.那么对于每一个电影，我们都能构造出一个特征向量。由于对于用户而言，他的评分是一个基于线性回归的预测问题，所以，我们要对每一个用户求出他对应的模型参数θ^(j)^,假设我们此时求出了Alice的模型参数。
$$
\theta^{(1)} = [0\;5\;0]^T\\
x^{(3)}=[1\;0.99\;0]\\
y^{(1,3)}=(\theta^{(1)})^T.dot(x^{(3)})=4.95
$$
如果我们把**求解每个用户的模型参数**提炼成问题的表达式，则有：
$$
r(i,j)=1\;第i个用户是否给第j个电影评过分\\
y^{(i,j)}=当r(i,j)=1时，用户的评分\\
\theta^{(j)}=第j个用户的模型参数向量\\
x^{(i)}=第i个电影的特征向量\\
m^{(j)}=被第j个用户评过的电影数量\\
对于每个用户j，电影i预测评分、(θ^{(j)})^T(x^{(i)})\\
学习θ^{(j)}
$$

$$
min_{\theta^{(j)}} \frac{1}{2m^{(j)}}\sum_{i:r(i,j)=1}((θ^{(j)})^T(x^{(i)})-y^{(i,j)})^2+\frac{\lambda}{2m^{(j)}}\sum_{k=1}^n(\theta_k^{(j)})^2
$$

这个公式只是用来学习一个用户的模型参数的公式，如果我们要求出所有用户的模型参数，那么这个公式长成这样（此处删掉m是因为常数不影响函数最小化）
$$
J({\theta^{(1)},\theta^{(2)},...\theta^{(n_u)}})=min_{\theta^{(1)},\theta^{(2)},...\theta^{(n_u)}}\frac{1}{2}\sum_{j=1}^{n_u}\sum_{i:r(i,j)=1}((θ^{(j)})^T(x^{(i)})-y^{(i,j)})^2+\frac{\lambda}{2}\sum_{j=1}^{n_u}\sum_{k=1}^{n}(\theta_k^{(j)})^2
$$
Okay,现在代价函数有了，我们推导其梯度下降公式:
$$
\theta_k^{(j)}:=\theta_k^{(j)}-\alpha(\sum_{i:r(i,j)=1}((θ^{(j)})^T(x^{(i)})-y^{(i,j)})x_k^{(i)}(k=0)
$$
$$
\theta_k^{(j)}:=\theta_k^{(j)}-\alpha(\sum_{i:r(i,j)=1}((θ^{(j)})^T(x^{(i)})-y^{(i,j)})x_k^{(i)}+\lambda\theta_k^{(i)})(k≠0)
$$



哦，看起来我们得到了我们最终想要的公式，但是，其中的物品（内容）的特征值我们都得是已知的，不过大多数情况下我们物品的特征值是未知的，下一讲介绍真正的基于物品的推荐算法。

### 15.3 协同过滤 (Collaborative Filtering)

协同过滤算法可以自动学习特征。现在，我们的数据集是这样的，我们想把每部电影的特征值反向计算出来：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0219/160638_21d48851_5550632.png "屏幕截图.png")

但是，在用户新注册系统时，我们要对用户进行**偏好设置**，得到每个用户的特征θ，类似于刚才的方法，给定每个用户的偏好，学习每部电影的特征值。

<br>，

![输入图片说明](https://images.gitee.com/uploads/images/2021/0219/160916_d17b4903_5550632.png "屏幕截图.png")

然后，我们就可以“套娃”了，随机初始化一组用户的偏好。然后....

![输入图片说明](https://images.gitee.com/uploads/images/2021/0219/161224_9c8c464e_5550632.png "屏幕截图.png")

这就是未改良的协同过滤推荐算法。

### 15.4 组合到一起

将两个式子结合到一起，我们得到了协同过滤算法的优化目标：
$$
J({x^{(1)},x^{(2)},...,x^{(n_m)},\theta^{(1)},\theta^{(2)},...\theta^{(n_u)}})=\\min_{x^{(1)},x^{(2)},...,x^{(n_m)}\theta^{(1)},\theta^{(2)},...\theta^{(n_u)}}\frac{1}{2}\sum_{(i,j):r(i,j)=1}((θ^{(j)})^T(x^{(i)})-y^{(i,j)})^2+\frac{\lambda}{2}\sum_{i=1}^{n_m}\sum_{k=1}^{n}(x_k^{(j)})^2+\frac{\lambda}{2}\sum_{j=1}^{n_u}\sum_{k=1}^{n}(\theta_k^{(j)})^2
$$
在协同过滤算法中，我们不再强制捏出一个截距x~0~=1，所以特征向量是n维的，不是n+1维的。

所以，协同过滤算法的执行流程为：

1. 随机初始化模型参数x,θ

2. 对上式进行梯度下降或者使用其它数值优化算法找到最小值

   ![输入图片说明](https://images.gitee.com/uploads/images/2021/0222/135316_10abee74_5550632.png "屏幕截图.png")

3. 根据用户的特征计算出$(\theta^{(j)})^T(x^{(i)})$(评分)

### 15.5 低秩矩阵分解 (Low rank matrix factorization)

之前我们以评分为基本度量，建立了商品与用户之间的联系，**评分越高，用户的喜爱程度越高。反之亦然。**然后通过线性回归的方式，预测出每个用户与商品之间的评分，排除掉那些用户已经浏览或交互过的商品。最终得到的若干待推荐内容。但是，**如何度量，某一内容和用户最近浏览内容的相似度呢？**

还是这个场景：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0225/152152_001175db_5550632.png "屏幕截图.png")

首先，要确定每个用户的评分，经过向量化之后，对评分的计算不难得到如下表达：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0225/152344_3da79f23_5550632.png "屏幕截图.png")

即，**用户特征.dot(电影特征)**。将上述内容拆成两个矩阵，**电影特征矩阵 X 和 用户特征矩阵 Θ，其中按行表达每一个电影和用户**。
$$
X = \left[              
\begin{array}{lcr}     
-(x^{(1)})^T-\\
-(x^{(2)})^T-\\
\;\;\;\;\;\;.\\
\;\;\;\;\;\;.\\
\;\;\;\;\;\;.\\
-(x^{(n_m)})^T-\\

\end{array}       
\right]\\
Θ= \left[              
\begin{array}{lcr}     
-(\theta^{(1)})^T-\\
-(\theta^{(2)})^T-\\
\;\;\;\;\;\;.\\
\;\;\;\;\;\;.\\
\;\;\;\;\;\;.\\
-(\theta^{(n_u)})^T-\\

\end{array}       
\right]\\
$$
对于评分的预测即可写作：
$$
R=XΘ^T
$$
评分矩阵都是稀疏的，也就是大部分的评分都是空的。我们在做推荐的时候，希望能够把空的评分位置填充上评分。这样就可以根据评分的高低，对用户提供推荐服务。所以上述算法又称**低秩矩阵分解**。

那么度量内容之间的相似度就相对容易了许多，得到了内容的特征向量（高维空间上的一个点），两点之间的距离，不就是最好的相似度度量方式吗？
$$
min ||x^{(i)}-x^{(j)}||
$$
现在，让我们再面对一个更让人头疼的问题，如果**我们有一个新用户，注册了我们的系统，他没有给任何电影评过分数，想给他推荐电影，假设电影的特征向量的维度还是2，不采用k-means对用户本身做聚类，不采用其它估计方式，如何给这名新用户推荐内容呢？**

![输入图片说明](https://images.gitee.com/uploads/images/2021/0225/155251_fa97b307_5550632.png "屏幕截图.png")

换句话说，该用户的初始特征向量里全是0，预测评分的结果也全是0，无法为用户进行推荐，何解？

**采用对评分进行均值归一化的方式解决**。

![](https://images.gitee.com/uploads/images/2021/0225/155513_7cd0e234_5550632.png)
$$
r(i,j)=1时，计算每个电影的平均评分值，然后Y-\mu得到新的评分矩阵
$$
对于用户 j 在电影 i 上的评分，即可表示为：
$$
(\theta^{(j)})(x^{(i)}) + \mu_i
$$
对于此时的用户 5而言，用户的特征值就不全是 0 了。

<br>

## Part 16 学习大规模数据集

数据集在机器学习算法中是十分重要的一部分，如果现在给你一个 m = 1 亿 这么多条记录的数据集，对其做线性回归，其中计算偏导数项的求和所耗费的时间代价可想而知。

![输入图片说明](https://images.gitee.com/uploads/images/2021/0225/160905_12d15b53_5550632.png "屏幕截图.png")

第一点，我们可以反思，在项目开始之前能不能只用1000条数据去训练模型呢？

第二点，我们可以借助学习曲线，来评估一个算法的高偏差方差问题，进而在决定是否增添数据。如果是高偏差问题，**不如再仔细设计一下特征向量，或者是神经网的隐藏层数。增加数据的做法，并不会改变现状。**
虽说如此，当我们如果真的要处理大规模数据集时，总得有方法来处理它，本章内容就是介绍一些处理大规模数据集的方法。它们是**随机梯度下降(Stochastic gradient decent)**和**减少映射(Map Reduce)**还有其它的梯度下降计算技巧。
### 16.1 随机梯度下降(Stochastic gradient decent)
在学习随机梯度下降之前，我们先复习一下我们之前经常用的批量梯度下降(Batch gradient decent)。
![输入图片说明](https://images.gitee.com/uploads/images/2021/0227/155209_0d338c60_5550632.png "屏幕截图.png")
这可是老熟人了，一个熟悉的线性回归的假设函数，熟悉的代价函数，以及熟悉的梯度下降公式和它的可视化。我们考虑一下,当m = 5 亿时，这个偏导数计算是这样的（假设 n >1000）：

1. 将 5 亿条记录全部读入内存中

2. 此时我们特征值构成了一个 (5亿×n)的矩阵，计算 $x^T.dot((x.dot(theta)-y))$

      ```python
   def gradient_decent(theta,x,y,alpha=0.01,iteration_cnt=1000):
       m = theta.shape[0] #m = 5亿
       for it in range(iteration_cnt):
           S = (1/m)*(x.T.dot((x.dot(theta)-y)))#向量化后计算偏导数
           theta = theta - alpha*S
           print(cost_function(x,y,theta))
           return theta
   ```
   
      生成一个 5亿维的向量，然后更新模型参数（迭代 1 次）
   
3.  重复步骤 2，直到完成迭代次数。

好家伙，内存爆不爆炸另说，光这矩阵转置和乘法就要命了。那么此时，我们想找到一种函数优化算法**能不能每次只取一个样本做梯度下降，这即节省了内存（不用一次性全读取进来），又可以少算很多项**。随机梯度下降就是干这个的，我们来看看它是咋玩的。
$$
cost(\theta,(x^{(i)},y^{(i)}))=\frac{1}{2}(h_\theta(x^{(i)})-y^{(i)})^2\\
J_{train}(\theta) = \frac{1}{m}\sum_{i=1}^mcost(\theta,(x^{(i)},y^{(i)}))
$$

随机梯度下降的算法流程如下:

![输入图片说明](https://images.gitee.com/uploads/images/2021/0301/151448_57775065_5550632.png "屏幕截图.png")



它是先对第一个样本做梯度下降，得到一组 θ~j~ (1,2,...,n)，再对第二个样本做梯度下降更新 模型参数，....。

![输入图片说明](https://images.gitee.com/uploads/images/2021/0227/164448_df3cf800_5550632.png "屏幕截图.png")

**与批量梯度下降不同的是，随机梯度下降在更新模型参数时，是来一个样本点更新一次模型参数 θ，直到取完 5 亿个样本**。而不是一次性计算 5亿个样本的求和值。画出随机梯度下降和批量梯度下降时的迭代过程示意图：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0227/165041_7cea3966_5550632.png "屏幕截图.png")

$\color{red}{红色}$为批量梯度下降的迭代路线，$\color{purple}{品红色}$为随机梯度下降的迭代路线。所以对于随机梯度下降而言，执行一次迭代基本上就可以找到模型参数了，如果不放心可以在[1,10]之间选择总迭代次数。

了解了随机梯度下降的原理和过程后。那么此时，新的问题诞生了，我们**如何确保随机梯度下降算法收敛，学习率α如何确定？**

首先，回忆一下，在梯度下降中，我们**每做完一次迭代后**，会计算代价函数值J(θ)，来评估算法是否在收敛，或者算法由于学习率过大而直接导致错过最小值。回忆一下，代价函数的计算公式：
$$
J(\theta)=\frac{1}{m}\sum_{i=1}^{m}(h_{\theta}x^{(i)}-y^{(i)})^2
$$


对于大样本量的梯度下降，我们显然不希望每次迭代后，等待一段时间去计算这个式子。所以我们换一种思路。，对于每个样本点，我们还是具有如下公式：
$$
cost(\theta,(x^{(i)},y^{(i)}))=\frac{1}{2}(h_{\theta}x^{(i)}-y^{(i)})^2
$$
然后，注意了，**我们在每次参数列表更新前计算代价函数值**。每隔1000次，记录一下之前计算代价函数值的平均值，记录下来以便画图使用。写成伪代码就类似于（c初始值为0）：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0301/152650_6962bd24_5550632.png "屏幕截图.png")

那么将代价函数可视化之后，我们会得到若干种图像。

**第一种，正常收敛，蓝线为基础学习率，红线学习率比蓝线小**：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0301/152904_9fa4c2ff_5550632.png "屏幕截图.png")

由于噪声的干扰，图像看上去歪歪扭扭，不过大体趋势是下降，证明算法在慢慢收敛。红线由于学习率小，最终收敛在最小值附近的结果相对准确。

**第二种，收集间隔比较大，蓝线为1000次收集一次代价函数值，红线为5000次收集一次代价函数值画图**：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0301/153211_115a7ddb_5550632.png "屏幕截图.png")

由于红线每次取值较多，平均掉了噪声带来的影响，图像显得光滑了很多。从上图看，这也是梯度下降正常收敛的结果。

**第三种，反复横跳，蓝线为1000次采样，红线为5000次采样，酚酞粉为5000次采样**

![输入图片说明](https://images.gitee.com/uploads/images/2021/0301/153529_b426f907_5550632.png "屏幕截图.png")

蓝线在1000次的采样频率下，蹦蹦跳跳。**第一感觉是算法没有收敛，此时不妨将采样间隔变大一些，如红线所示**，可以看出趋势还是在缓慢下降的，**至少可以说明算法没有问题**。但是，如果采样间隔扩大了，但是**图像像酚酞粉一样，代价函数值基本不变，那么大概率是学习算法没有进行有效的学习，可以重新设计特征值和算法了**。

**最后一种，火箭升空**

![输入图片说明](https://images.gitee.com/uploads/images/2021/0301/153902_8f6bf457_5550632.png "屏幕截图.png")

这种情况大多由于**设置了过大的学习率**，导致算法刀片超车，直接错过全局最小值。解决方案，调低学习率再试试。

有关学习率的设置方式，一般而言和梯度下降一样，取个（0.1~0.001）的数试一试，效果好的话再微调。全局保持不动。但也有另外一种做法，设学习率为：
$$
\alpha=\frac{const\;1}{iteration_{count}+coust\;2}
$$
易得，**学习率随着迭代次数的增多而减小**，普通的随机梯度下降可能会在全局最小值附近徘徊震荡，误差相对较大。而采样这种学习率的更新方式，就会让它**越走越精准（离终点越近，迈的步子越小）**。最终会呈现出这样的效果：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0301/154607_efb7fce5_5550632.png "屏幕截图.png")

而不是这样的：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0301/154639_30538903_5550632.png "屏幕截图.png")

准确的代价是复杂，至于这两个常量如何确定，只能化身调参侠，慢慢去尝试。

### 16.2 Mini-Batch gradient decent

批量梯度下降算法每次使用m个样本做一次迭代，随机梯度下降算法每次使用一个样本做一次迭代。而mini-batch一次选择**b个样本做一次迭代**，这个b就是，算法所包含的参数。b的值取2~100之间。若取b=10,则梯度下降会变为：
$$
\theta_j:=\theta_j-\alpha*\frac{1}{10}\sum_{k=i}^{i+9}(h_\theta(x^{(k)})-y^{(k)})x_j^{(k)}\\
i:=i+10
$$
![输入图片说明](https://images.gitee.com/uploads/images/2021/0301/144409_e741abcf_5550632.png "屏幕截图.png")

这样看起来，感觉mini-batch也没什么，不就是取了b组数据来做梯度下降吗？这不就比随机梯度下降多取了几条样本吗。**其实，Mini-Batch是为向量化服务的。**

由于随机梯度下降每次只取一个样本，导致向量化之后，会形成一个(1×n)的矩阵（向量），矩阵的行数太小，向量化的意义不大。而如果用批量梯度下降，又会形成一个(m×n)的矩阵，行数太大，计算量过高。

**通过选择b的方式，控制每次梯度下降时特征矩阵X的行数，减少矩阵转置的计算量，提高算法整体性能，多次少量地进行梯度下降**。

### 16.3 在线学习（Online Learning）

在线学习适用于**用户量大，并发数高的项目**，不过，我更愿意把它称之为**大数据杀熟算法**。在线学习和普通的机器学习算法比，差距只是在**数据集的使用上**。我们首先例举出一个生活中的场景，假如你在某宝或某电商平台上购物，你现在想买一本《算法导论》，发现居然需要90块钱，感觉太贵，不买了。又过了7天，当你攒够了钱，再次打开网站的时候，发现同样的商品降价到了79块钱。这是为啥呢？其实在背后，这些平台上运行着一种**分类算法**，**它会预测出用户是否购买某商品的概率，根据这个概率，电商平台再适当地提高或降低商品的价格。**有的时候用户期望低，不想太多花钱，那就降价，少赚点。有时用户期望高，愿意花钱，那就多赚点。

我们假设这个算法是逻辑回归模型，最终我们要的就是它：$P(y=1;x,θ)$。

它是这样训练的：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0302/152947_eaa307f3_5550632.png "屏幕截图.png")

可以看出，该网站是来一个用户就收集一下用户地行为信息，不再采用线下的训练方式，故称在线学习。它的第二个应用就是**点击量预测（Click Through Rate CTR）**。什么是点击量预测呢？假设你是一个未来科技无限责任公司的电商平台部长，专门卖手机，现在你有1000种不同型号的手机，如果用户查询**128T内存+50兆亿像素主摄+86核光量子CPU**的手机，如何选择**10台**，放在首页上？根据手机的配置和用户搜索的条件，我们可以构造出一款手机的特征向量，依旧是计算$P(y=1;x,θ)$。y 代表拥有是否点击链接进入商品信息主页。那么每当有新用户登录平台，你就会获取到十条数据记录，用于算法的学习。

回到现实，在线学习还可以应用在舆情推荐，产品推荐等等方面。

说了这么多，其实就是一句话：**在线学习应用在高用户高并发的项目中，不用这种方法也能做，核心算法长得一样。对偏好兴趣发生变化的场景更加适应。**

### 16.4 减少映射 （Map-reduce）与数据并行（Data parallel）

减少映射是什么意思呢？

假设，现在我们有一个线性回归任务，有4亿条数据。**我们显然不想只让一台电脑去计算，为了提高效率，我们采用归并的思想，将大问题化小，最后集中解决**。看个图就都明白了：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0302/161653_79d023d7_5550632.png "屏幕截图.png")

**当学习任务的梯度值可以求和的时候，我们才能拆成子集去做。**

![输入图片说明](https://images.gitee.com/uploads/images/2021/0302/161849_28fcb274_5550632.png "屏幕截图.png")

当然了，个人电脑的多核CPU间的并行计算是同样的道理，只是把电脑换成了CPU，而且没有了网络传输的延迟。

![输入图片说明](https://images.gitee.com/uploads/images/2021/0302/162017_6166d5cb_5550632.png "屏幕截图.png")

一般而言，优秀的线性代数库都是自动采用并行计算的，所以这也就是为什么我们喜欢对学习问题向量化的原因。

<br>

## Part 17 机器学习实例：Photo OCR

### 17.1 Machine Learning Pipeline

在这一章，我们用一个机器学习实例项目来说明机器学习中的**流水线思想（pipeline）**

Photo OCR全称**Photo Optical Character Recognition**，其目的在于，在图片中找到文本区，并将文本区中的文字提取出来。类似这样：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0303/152637_9b1f050a_5550632.png "屏幕截图.png")

那它需要几步才能做到呢？

1. 识别出文本区
2. 将文本串分割成文字
3. 进行文字分类，得到结果

![输入图片说明](https://images.gitee.com/uploads/images/2021/0303/152842_85ada914_5550632.png "屏幕截图.png")

整个识别流程就是**机器学习流水线**。十分类似与**面向过程的函数调用**。

##### 0x00 滑动窗口

先解决流水线中的第一个步骤，**如何划分文本区？**。从图片中识别出文本区和在图片中识别出行人，本质上是一样的，就是在**一张大图片中，把识别结果用矩形框框出来即可。**由于行人的矩形框无论远近都是可以等比例缩放的，我们先看看行人检测系统是如何训练的

![输入图片说明](https://images.gitee.com/uploads/images/2021/0303/153241_c444d52d_5550632.png "屏幕截图.png")

![输入图片说明](https://images.gitee.com/uploads/images/2021/0303/153430_ec488dea_5550632.png "屏幕截图.png")

每一张图片都是（82*36）作为特征向量，一组行人照片为正类，另一组非行人照片为负类。

假设，我们依据数据集已经训练好了模型，下图为测试集中的一张照片，我们**如何把人框出来？**

![输入图片说明](https://images.gitee.com/uploads/images/2021/0303/153803_e0880845_5550632.png "屏幕截图.png")

我们可以**任取一个矩形框（x\*y）【多试几个不同大小的矩形】，取出的矩形按比例缩放至（82\*36）,这个矩形就叫做滑动窗口**。然后，我们从左向右遍历图片，每次走b个步长，单位为像素。不难看出，每次向右走一个像素是最准确的，也是计算代价最大的。

把整个图片遍历一遍。

![输入图片说明](https://images.gitee.com/uploads/images/2021/0303/154808_f9c14b2f_5550632.gif "slide window.gif")

最终得到结果：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0303/155048_0291d57b_5550632.png "屏幕截图.png")

文本识别同理，先训练让电脑知道哪里是文本区：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0303/155325_2963da1e_5550632.png "屏幕截图.png")

虽说文本有长短，但是我们依旧用一个固定大小的矩形来当作滑动窗口。最终生成一个和原图片比例一模一样的副本，**有字的地方为高亮，越亮为文字的概率越大**。

![输入图片说明](https://images.gitee.com/uploads/images/2021/0303/155546_1a5dd879_5550632.png "屏幕截图.png")

为了提高精度，我们使用放大算子，提高识别结果。具体来讲，就是一个像素一个像素遍历，如果周围10-15个像素为高亮，那么这一片区域均为高亮。最终效果如下：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0303/155909_109e266e_5550632.png "屏幕截图.png")

最终我们丢弃掉那些奇奇怪怪的矩形（竖着写的文字怎么办？），并以此绘制矩形框。

第一步结束了，接着进行第二步，识别文本间隔，划分文本。训练方法同理：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0303/160156_aedb1aa7_5550632.png "屏幕截图.png")

依旧是使用一维的滑动窗口，对每个字符串进行分割：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0303/160322_0332a8d5_5550632.png "屏幕截图.png")

最后一步，n元分类问题，在此就不赘述了。

### 17.2 数据获取和人工数据合成

为了得到一个可靠的机器学习系统，我们喜欢**构造一个低偏差的模型，用大量数据去训练模型**，可是数据从哪来呢？

在机器学习中有个思想，叫做**人工数据合成**。没有数据，咱们就自己创造数据，当然得靠谱地创造数据，以Photo OCR为例，看看怎么造数据。下图是一个真实的数据集，我们的任务是**识别出小正方形最中央的字母**：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0303/161145_fd9bda32_5550632.png "屏幕截图.png")

为了扩大该数据集，我们可以应用不同的字体，或者旋转，剪切，等等操作。并将它们粘到不同的背景中去。然后我们得到了人造数据集：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0303/161348_ebd70649_5550632.png "屏幕截图.png")

上述方案，可以让你从零创造数据集，但是当你已经有了一个数据集时，我们也可以对其进行魔改，达到扩大数据集的效果：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0303/161627_5e7a0d4d_5550632.png "屏幕截图.png")

当然了，在对数据做失真处理的时候，一定是合乎常理有意义的，即**生活中存在的**。

最后再次强调，**于其花大代价创造数据集，不如先做出一个低偏差的模型来的实在。**

### 17.3 上限分析（Ceiling Analysis）

通过上限分析，我们能够评估出在流水线中，哪些模块是最值得花时间改进的。以Photo OCP为例。

![输入图片说明](https://images.gitee.com/uploads/images/2021/0303/163301_6dfcffe1_5550632.png "屏幕截图.png")

在这个例子中，对一个模型的好坏的评判标准之一就是，**识别准确率**。那么我们需要做如下的事情：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0303/163958_0938760b_5550632.png "屏幕截图.png")

首先整体跑一边，得到模型的准确率，上图中为72%。

然后，我们使用“人工智能”，在第一步的文本区检测中人工地进行划分，把正确地结果告诉算法，然后再进行剩余步骤，模型准确率为89%

同理，在第二步，我们直接将人工划分好的数据喂给模型，最后跑出来的准确率是90%。

最后，我们认为每次分类都是正确的，当然最终准确率为100%。

这样我们就能看出**改善文本区识别模块可以让模型提高17%的准确率，空间最大，而改善字符分割的作用不大，就只能提高1%的准确率。**至此，**我们抓住了事务的主要矛盾**。有了模型优化的方向。

再举一个例子，现在有一个人脸识别的任务（只是一个例子，实际上远比这个复杂的多），你想知道照片里的人你到底是不是你的朋友。我们设计如下的工作流：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0303/164836_96046c9d_5550632.png "屏幕截图.png")

1. 去掉图片背景
2. 找到人脸
3. 找到五官特征
4. 进入逻辑回归分类器
5. 得到标签

对于该任务做上限分析，得到的结果如下：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0303/165159_009ae726_5550632.png "屏幕截图.png")

不难看出，将精力投入在人脸检测上对整体效果影响最大，其次五官中，眼睛的分割和嘴巴的分割。

<br>

## Part 18 总结与感谢

在本次学习中我学到了以下内容：

1. 监督学习算法：线性回归，逻辑回归，神经网络，SVM
2. 无监督学习算法：K-means，PCA，异常检测
3. 特殊应用：推荐系统和用于大数据杀熟的在线学习
4. 一些机器学习的经验方法：偏差/方差，正则化，如何评估机器学习算法的优劣（召回率，查准率，F~1~Score），学习曲线，误差分析，工作流。

![输入图片说明](https://images.gitee.com/uploads/images/2021/0303/170408_2fb9acad_5550632.png "屏幕截图.png")

至此，课程完结，感谢吴恩达老师的教诲，感谢大家能耐着性子把本篇博客看完。谢谢大家。

<br>

## Appendix 作业及解析

附录中的作业均出自于：

https://github.com/Ayatans/Machine-Learning-homework

中文解析包括在该项目内，以下内容均为练习参考使用，请酌情观看。

### Programming Exercise 1 Linear Regression

**题目概述**

```
In this part of this exercise, you will implement linear regression with one
variable to predict profits for a food truck. Suppose you are the CEO of a
restaurant franchise and are considering different cities for opening a new
outlet. The chain already has trucks in various cities and you have data for
profits and populations from the cities.
You would like to use this data to help you select which city to expand
to next.
The file ex1data1.txt contains the dataset for our linear regression prob-
lem. The first column is the population of a city and the second column is
the profit of a food truck in that city. A negative value for profit indicates a
loss.
The ex1.m script has already been set up to load this data for you.
```

```
参考翻译：
在本次练习中，你将会实现一个单变量线性回归模型来预测一卡车食物的利润。
假设你是一个特许经营餐厅的CEO，希望打通不同城市间的一条新销路。在不同城市的供应链上已经存在了很多卡车，同时你拥有每座城市的人口和利润信息。
你想使用这些信息来帮助你决策下一个生意扩张的城市。
ex1data1.txt 包含了线性回归模型所需要的数据集，第一列为人口，第二列为一卡车食物的利润，负值代表亏损。
ex1.m 中的脚本已经帮助你加载了这些数据
```

单变量线性回归模型：

> x0 = 1
>
> x1 = 城市人口
>
> y = 利润

**Warmup**

生成一个五维单位矩阵

```python
import numpy as np
m = np.eye(5)
print(m)
```

```
[[1. 0. 0. 0. 0.]
 [0. 1. 0. 0. 0.]
 [0. 0. 1. 0. 0.]
 [0. 0. 0. 1. 0.]
 [0. 0. 0. 0. 1.]]
```

**数据集可视化**

```python
def draw_data_set():
    data = np.loadtxt(FILE_PATH, delimiter=',')
    x = data[:,0]
    y = data[:,1]
    plt.scatter(x,y,marker='x')
    plt.xlabel("population")
    plt.ylabel("profit")
    plt.show()
```

![输入图片说明](https://images.gitee.com/uploads/images/2020/1216/152718_d976c487_5550632.png "屏幕截图.png")

下图为作业中自带的参考答案：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1216/152751_cb2a27a9_5550632.png "屏幕截图.png")

**代价函数的实现**

```python
def cost_function(x,y,theta):
    m = x.shape[0]
    predict_value = hypothesis_function(theta,x)
    sqrErrors = (predict_value - y)**2
    cost = 1 /(2*m)*sum(sqrErrors)
    return cost
```

```
运行结果:
32.072733877455654
```

![输入图片说明](https://images.gitee.com/uploads/images/2020/1216/154920_6dbcd9cf_5550632.png "屏幕截图.png")

**未实现均值归一化前的梯度下降实现**

要求：学习率为：0.01,迭代次数为：1500

我设置的参数为：

```
alpha=0.0001,iteration_cnt=1000
```

其中正规方程组法得到的参数为: [-3.89578088  1.19303364]
代价函数值为：4.476971375975179

梯度下降法得到的参数为：[-2.2379466   1.02648621]

代价函数值为：4.727185425388962

![输入图片说明](https://images.gitee.com/uploads/images/2020/1216/173525_dc98af68_5550632.png "屏幕截图.png")

```python
import numpy as np
import matplotlib.pyplot as plt
FILE_PATH = r"ex1data1.txt"


def get_x(file_path):
    """
    
    :param file_path: 
    :return: vectorX(97,2)
    """
    data = np.loadtxt(file_path,delimiter=',')
    data[:,1] = data[:,0]
    data[:,0] = 1
    return data

def hypothesis_function(theta,x):
    """
    :param theta: 
    :param x: 
    :return: theta0*x0+theta1*x1(x0 = 1)
    """
    return x.dot(theta)

def cost_function(x,y,theta):
    m = x.shape[0]
    predict_value = hypothesis_function(theta,x)
    sqrErrors = (predict_value - y)**2
    cost = 1 /(2*m)*sum(sqrErrors)
    return cost

def gradient_decent(theta,x,y,alpha=0.0001,iteration_cnt=1000):
    m = theta.shape[0]

    for it in range(iteration_cnt):
        S = (1/m)*(x.T.dot((x.dot(theta)-y)))
        theta = theta - alpha*S
    print(cost_function(x,y,theta))
    return theta

def normal_equation(x,y):
    res = np.linalg.pinv(x.T.dot(x)).dot(x.T).dot(y)
    return  res

def main():
    theta = np.array([0,0])
    x = get_x(FILE_PATH)
    y = np.loadtxt(FILE_PATH,delimiter=',')
    y = y[:,1]
    theta = gradient_decent(theta,x,y)
    print(theta)
    theta_normal_equation = normal_equation(x,y)
    print(theta_normal_equation)
    print(cost_function(x,y,theta_normal_equation))
    draw_data_set(x,theta)
    
def draw_data_set(feature_x,theta):
    data = np.loadtxt(FILE_PATH, delimiter=',')
    x = data[:,0]
    y = data[:,1]
    predict_y = feature_x.dot(theta)
    plt.scatter(x,y,marker='x',c="red",label="Training data")
    plt.plot(x,predict_y,label="Linear regression")
    plt.legend()
    plt.xlabel("population")
    plt.ylabel("profit")
    plt.show()



main()
```

**实现均值归一化后的梯度下降实现**

我设置的参数为：

```
alpha=0.01,iteration_cnt=1000
```

其中正规方程组法得到的参数为: [-3.89578088  1.19303364]
代价函数值为：4.476971375975179

梯度下降法得到的参数为：[0.69726026 9.73491593]

代价函数值为：4.476971375975179

![输入图片说明](https://images.gitee.com/uploads/images/2020/1217/145642_5c59c1c1_5550632.png "屏幕截图.png")

```python
import numpy as np
import matplotlib.pyplot as plt
FILE_PATH = r"ex1data1.txt"

def get_x(file_path):
    """
    
    :param file_path: 
    :return: vectorX(97,2)
    """
    data = np.loadtxt(file_path,delimiter=',')
    data[:,1] = data[:,0]
    data[:,0] = 1
    return data

def hypothesis_function(theta,x):
    """
    :param theta: 
    :param x: 
    :return: theta0*x0+theta1*x1(x0 = 1)
    """
    return x.dot(theta)

def cost_function(x,y,theta):
    m = x.shape[0]
    predict_value = hypothesis_function(theta,x)
    sqrErrors = (predict_value - y)**2
    cost = 1 /(2*m)*sum(sqrErrors)
    return cost

def gradient_decent(theta,x,y,alpha=0.01,iteration_cnt=1000):
    m = theta.shape[0]

    for it in range(iteration_cnt):
        S = (1/m)*(x.T.dot((x.dot(theta)-y)))
        theta = theta - alpha*S
    print(cost_function(x,y,theta))
    return theta

def normal_equation(x,y):
    res = np.linalg.pinv(x.T.dot(x)).dot(x.T).dot(y)
    return  res

def feature_normalize(x):
    sigma = np.mean(x,axis=0)
    mu = np.std(x,axis=0)
    for j in range(1,x.shape[1]):
        if sigma[j] == 0:
            sigma[j] = 1e-30
        x[:,j] = (x[:,j] - mu[j])/sigma[j]
    return x


def main():
    theta = np.array([0,0])
    x = get_x(FILE_PATH)
    y = np.loadtxt(FILE_PATH,delimiter=',')
    y = y[:,1]
    new_x = feature_normalize(x)
    new_theta = gradient_decent(np.array([0,0]),new_x,y)
    print("new theta: " + str(new_theta))
    print("cost of feature normalization: %.2f" % cost_function(x, y, new_theta))

    draw_data_set(x,new_theta)
    
def draw_data_set(feature_x,theta):
    data = np.loadtxt(FILE_PATH, delimiter=',')
    x = data[:,0]
    y = data[:,1]
    predict_y = feature_x.dot(theta)
    plt.scatter(x,y,marker='x',c="red",label="Training data")
    plt.plot(x,predict_y,label="Linear regression")
    plt.legend()
    plt.xlabel("population")
    plt.ylabel("profit")
    plt.show()



main()
```

### Programming Exercise 2 Logistics Regression

**题目概述**

```
In this part of the exercise, you will build a logistic regression model to
predict whether a student gets admitted into a university.
Suppose that you are the administrator of a university department and
you want to determine each applicant's chance of admission based on their
results on two exams. You have historical data from previous applicants
that you can use as a training set for logistic regression. For each training
example, you have the applicant's scores on two exams and the admissions
decision.
Your task is to build a classification model that estimates an applicant's
probability of admission based the scores from those two exams. This outline
and the framework code in ex2.m will guide you through the exercise.
```

```
参考翻译：
在本次练习中，你将会训练一个逻辑回归模型来预测一个学生是否能进入大学。
假设你是一名大学招生办的管理员，你希望通过申请人的两项考试成绩来决定他们是否有升学的机会。
你有可以用于进行逻辑回归模型训练的之前申请人的历史数据。
对于每一个训练数据，它会提供申请人的两项考试成绩和决策结果。
你的任务是训练一个分类模型以用于评估申请人基于两项考试成绩申请的通过可能性。
大纲和框架代码将会在 ex2.m 中知道你完成此次练习。
```

**数据可视化**

下面这句话是作业文档中的原话，我觉得很有价值，便抄录了下来。

```
Before starting to implement any learning algorithm, it is always good to
visualize the data if possible.
```

```python
import matplotlib.pyplot as plt
import numpy as np

FILE_PATH = r"ex2data1.txt"

def get_data(file_path):
    res = np.loadtxt(file_path,delimiter=',')
    return res

data = get_data(FILE_PATH)
x = data[:,0:2]
y = data[:,2]


res1_x1 = []
res1_x2 = []

res2_x1 = []
res2_x2 = []

for i in range(y.shape[0]):
    if y[i] == 0:
        res1_x1.append(x[i,0])
        res1_x2.append(x[i,1])
    elif y[i] == 1:
        res2_x1.append(x[i, 0])
        res2_x2.append(x[i, 1])

plt.scatter(res1_x1,res1_x2,marker='x',c='r',label='Not admitted')
plt.scatter(res2_x1,res2_x2,marker='o',c='b',label='Admitted')
plt.xlabel("Exam 1 score")
plt.ylabel("Exam 2 score")

plt.legend()
plt.show()
```

数据集可视化效果图：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1218/110057_0f8ce02d_5550632.png "屏幕截图.png")

作业文档中的参考图像：

![输入图片说明](https://images.gitee.com/uploads/images/2020/1218/105850_f0038aa5_5550632.png "屏幕截图.png")

**Warmup-实现sigmoid函数**

```python
import numpy as np

def g(z):
    result = 1/(1+np.exp(-z))
    return result

def hypothesis_function(feature_x,theta):
    z = feature_x.dot(theta)
    return g(z)

print(g(0))
```

**实现代价函数和梯度下降**

```python
import numpy as np
import matplotlib.pyplot as plt

FILE_PATH = r"ex2data1.txt"

def get_data(file_path):
    res = np.loadtxt(file_path,delimiter=',')
    return res

def sigmoid(z):
    result = 1/(1+np.exp(-z))
    return result

def hypothesis_function(feature_x,theta):
    z = feature_x.dot(theta)
    return sigmoid(z)

def cost_function(x,y,theta):
    m = y.shape[0]
    # 1/m*np.sum(-y.dot(np.log(h(x))) - (1-y).dot(np.log(1-h(x))))
    cost = 1/m*((-y.dot(np.log(hypothesis_function(x,theta)))) - ((1-y).dot(np.log(1-hypothesis_function(x,theta)))))
    return cost

def gradient_decent():
    pass



def main():
    data = get_data(FILE_PATH)
    x = data[:, 0:2]
    y = data[:, 2]
    theta =  np.zeros((2,1))
    cost = cost_function(x,y,theta)
    print(cost)


main()
```

初始代价函数值：

```
0.69314718
```

接着我们按照要求应该进行目标函数的最小化，但是题目要求使用Octave中的**fminunc**，由于我使用的是Python实现，这里使用了**scipy中的optimize**来类似计算。最终计算结果和Octave的一样。

```python
import numpy as np
import matplotlib.pyplot as plt
import scipy.optimize as op
FILE_PATH = r"ex2data1.txt"

def get_data(file_path):
    res = np.loadtxt(file_path,delimiter=',')
    return res

def sigmoid(x):
    z = 1/(1+np.exp(-x))
    return z



def cost_function(theta,x,y):
    m = x.shape[0]
    J = (-np.dot(y.T, np.log(sigmoid(x.dot(theta)))) -
         np.dot((1 - y).T, np.log(1 - sigmoid(x.dot(theta))))) / m
    return J


def gradient(theta,x,y):
    m, n = x.shape
    theta = theta.reshape((n, 1))
    grad = np.dot(x.T, sigmoid(x.dot(theta)) - y) / m
    return grad.flatten()



def feature_normalize(x):
    sigma = np.mean(x, axis=0)
    mu = np.std(x, axis=0)
    for j in range(0, x.shape[1]):
        if sigma[j] == 0:
            sigma[j] = 1e-30
        x[:, j] = (x[:, j] - mu[j]) / sigma[j]
    return x

def calc_y(x,theta):
    """
    1*0 +theta1*x1 + theta2*x2 = 0
    x2 = -theta1*x1/theta2
    :param x: 
    :return: 
    """
    return -theta[0]*x/theta[1]

def draw_pict(data,theta):
    x = data[:, 0:2]
    y = data[:, 2]
    res1_x1 = []
    res1_x2 = []
    res2_x1 = []
    res2_x2 = []
    for i in range(y.shape[0]):
        if y[i] == 0:
            res1_x1.append(x[i, 0])
            res1_x2.append(x[i, 1])
        elif y[i] == 1:
            res2_x1.append(x[i, 0])
            res2_x2.append(x[i, 1])

    plt.scatter(res1_x1, res1_x2, marker='x', c='r', label='Not admitted')
    plt.scatter(res2_x1, res2_x2, marker='o', c='b', label='Admitted')

    plt.plot(x[:,0],calc_y(x[:,0],theta))
    plt.xlabel("Exam 1 score")
    plt.ylabel("Exam 2 score")

    plt.legend()
    plt.show()


def init_data(x):
    m,n = x.shape
    initial_theta = np.zeros(n + 1)
    vector_one =  np.ones((m,1))
    x = np.column_stack((vector_one,x))
    return x,initial_theta

def reshape_data(data):
    m = np.size(data, 0)
    x=data[:,0:2]
    y=data[:,2]
    y=y.reshape((m,1))
    return x,y


def main():
    data = get_data(FILE_PATH)
    x,y = reshape_data(data)
    x,initial_theta = init_data(x)

    result = op.minimize(fun=cost_function, x0=initial_theta, args=(x, y), method='TNC', jac=gradient)
    print(result)


main()
```

结果：

```
    fun: array([0.2034977])
     jac: array([9.17727211e-09, 1.02335214e-07, 4.81971997e-07])
 message: 'Local minimum reached (|pg| ~= 0)'
    nfev: 36
     nit: 17
  status: 0
 success: True
       x: array([-25.16131857,   0.20623159,   0.20147149])
```

第一行是代价函数值：0.203，

最后一行是参数向量theta =[-25.16131857,   0.20623159,   0.20147149]

随后，我们使用这个参数进行画图。

![输入图片说明](https://images.gitee.com/uploads/images/2020/1219/172625_cb1541c9_5550632.png "屏幕截图.png")

#### 2.2 带有的正则化逻辑回归

**题目概述**

```
In this part of the exercise, you will implement regularized logistic regression
to predict whether microchips from a fabrication plant passes quality assur-
ance (QA). During QA, each microchip goes through various tests to ensure
it is functioning correctly.
Suppose you are the product manager of the factory and you have the
test results for some microchips on two different tests. From these two tests,
you would like to determine whether the microchips should be accepted or
rejected. To help you make the decision, you have a dataset of test results
on past microchips, from which you can build a logistic regression model.
You will use another script, ex2 reg.m to complete this portion of the
exercise.
```

```
在本部分的练习中，你将实现一个带有正则化的逻辑回归模型，用于预测从制造工厂产出的微芯片是否能通过质量保证（QA）
在QA的时候，每个微芯片都会进行一系列测试来保证其功能的正确性。
假设你是工厂的产品经理，你有一些微芯片的两种不同测试的结果。通过这两项测试，你会决策出一个微芯片是否应当接受或拒绝出厂。
为了帮助你进行选择，你有一个关于之前微芯片的测试数据集，以便于构建逻辑回归模型。
你将使用另外一个脚本，ex2 reg.m 来完成这一部分的练习。
```

**数据集可视化**

![输入图片说明](https://images.gitee.com/uploads/images/2020/1222/132416_3d3f5fbe_5550632.png "屏幕截图.png")

**特征映射**

为了能够拟合这个分散的数据集，普通的直线分类已经不适用，所以我们要把**2维原始特征映射成一个28维特征**

![输入图片说明](https://images.gitee.com/uploads/images/2020/1222/132738_3ed9f71f_5550632.png "屏幕截图.png")

```python
def feature_map(X,exponent=6):
    """
    特征映射,将二维特征向量映射为 28 维特征向量
    :param X: 
    :return: res_feature
    """
    x1 = X[:,0]
    x2 = X[:,1]
    res_feature = np.ones((X.shape[0],1))
    for i in range(1,exponent+1):
        for j in range(0,i+1):
            new_feature = (x1**(i-j))*(x2**j)
            res_feature = np.column_stack((res_feature,new_feature))
    return res_feature
```

**代价函数和梯度**

```python
import numpy as np
import matplotlib.pyplot as plt
import scipy.optimize as op

FILE_PATH = r"ex2data2.txt"

def get_data(file_path):
    data = np.loadtxt(file_path,delimiter=',')
    X = data[:,0:2]
    y = data[:,2]
    return X,y

def feature_map(X,exponent=6):
    """
    特征映射,将二维特征向量映射为 28 维特征向量
    :param X: 
    :param exponent: 
    :return: 
    """
    x1 = X[:,0]
    x2 = X[:,1]
    res_feature = np.ones((X.shape[0],1))
    for i in range(1,exponent+1):
        for j in range(0,i+1):
            new_feature = (x1**(i-j))*(x2**j)
            res_feature = np.column_stack((res_feature,new_feature))
    return res_feature


def cost_function(theta,X,y,my_lambda = 1):
    """
    计算代价函数值
    :param X: 训练集
    :param y: 标签
    :param theta: 模型参数
    :param my_lambda: 正则化参数
    :return: 
    """
    m = X.shape[0]

    regularization = (my_lambda/2*m)*theta.T.dot(theta)
    left = np.dot((-y).T,np.log(hypothesis_function(theta,X)))
    right = np.dot((1-y).T,np.log(1 - hypothesis_function(theta,X)))
    cost = (left-right)/m+regularization
    #print(cost)
    return cost

def hypothesis_function(theta,X):
    """
    :param theta: (28, 1)
    :param X: (118, 28)
    :return: 
    """
    # print(X.shape)
    # print(theta.shape)
    z = X.dot(theta)
    return 1/(1+np.exp(-z))

def initialize_theta(m):
    res_theta = np.zeros((m,1))
    return res_theta

def gradient(theta,X,y,my_lambda = 1):
    x_0 = X[:, 0]
    m = X.shape[0]
    temp = hypothesis_function(theta,X).flatten()-y #降维成118向量后对应做差

    partial_derivative_theta_0 = (1/m)*np.dot(temp,x_0)
    x_remain = X[:,1:].T
    tail = (my_lambda/m)*theta[1:]#(27,1)
    partial_derivative_theta_j = (1/m)*np.dot(x_remain,temp)-tail.flatten() #j>=1 时的偏导数
    res_partial_derivative = np.append(partial_derivative_theta_0,partial_derivative_theta_j)
    return res_partial_derivative

if __name__ == '__main__':


    X,y = get_data(FILE_PATH)
    new_X = feature_map(X,exponent=6)
    theta = initialize_theta(new_X.shape[1])
    theta = theta.flatten()
    """
    optimize.minimize(target_fun,init_val,method,jac,hess) 
    fun：待优化函数的表达式计算； 
    X0：初始值；
    args:元组，给待优化函数的参数
    method：最小化的算法； 
    jac：雅各比矩阵 
    注意，在optimize.minimize函数中，优化函数和梯度函数的第一个参数必须是theta，且shape为(x,)
    """

    gradient(theta,new_X,y)
    result = op.minimize(fun=cost_function, x0=theta, args=(new_X, y), method='TNC', jac=gradient)
    print(result)

```

注意：$\color{red}{在optimize.minimize函数中，优化函数和梯度函数的第一个参数必须是theta，且shape为(x,)}$

函数优化结果：

```
     fun: 0.6931386454411619
     jac: array([8.47340040e-03, 1.87875076e-02, 7.88189819e-05, 5.03437256e-02,
       1.15006836e-02, 3.76665340e-02, 1.83553987e-02, 7.32380104e-03,
       8.19162502e-03, 2.34772285e-02, 3.93479496e-02, 2.23843278e-03,
       1.28603353e-02, 3.09512924e-03, 3.93037093e-02, 1.99700945e-02,
       4.32950572e-03, 3.38608692e-03, 5.83832901e-03, 4.47555784e-03,
       3.10079314e-02, 3.10304053e-02, 1.09681899e-03, 6.31578628e-03,
       4.08091516e-04, 7.26520038e-03, 1.37565475e-03, 3.87935191e-02])
 message: 'Linear search failed'
    nfev: 107
     nit: 1
  status: 4
 success: False
       x: array([ 1.14616634e-04,  1.03955049e-04,  1.46947914e-04, -2.47073240e-04,
       -2.76692230e-04, -2.36092801e-04,  1.18886735e-04, -1.04813843e-04,
       -1.11375838e-04,  3.79573444e-05, -1.38756231e-04, -3.21762115e-05,
       -1.32052923e-04, -8.67618336e-05, -1.12277115e-04,  8.79636146e-05,
       -4.69546463e-05, -2.06384068e-05, -6.52112561e-05, -7.13623836e-05,
        7.54429159e-05, -4.18552393e-05,  5.41398980e-06, -6.25800757e-05,
       -7.69406082e-06, -6.48878220e-05, -3.39848194e-05,  1.71874064e-05])
```

从上图可以看出，我们的代价函数值为  0.693，和答案所给的一致，我们忽略掉failed和False，直接用这组模型参数进行绘图。

**绘制不同正则化参数下的决策边界**

画图函数：

```python
def draw_result(path,opt_theta):
    """
    
    :param path: 数据集路径
    :return: None
    """
    """
    绘制数据集-Start
    """
    data1 = np.loadtxt(path, delimiter=',')
    pos_index = np.where(data1[:, 2] == 1)
    neg_index = np.where(data1[:, 2] == 0)

    plt.scatter(data1[pos_index, 0], data1[pos_index, 1], marker='o',c='b',label='Accepted',s=5)
    plt.scatter(data1[neg_index, 0], data1[neg_index, 1], marker='x',c='r',label='Rejected')
    """
    绘制数据集-End
    """
    """
    绘制决策边界-Start
    """
    xx = np.linspace([-1],[1.5],30)#生成 from -1 to 1.5，中间有30项的等差数列
    yy = np.linspace([-1],[1.5],30)
    # 对x,y网格化，得到X,Y
    X, Y = np.meshgrid(xx, yy)
    z = np.zeros((xx.size, yy.size))#等高线的高
    for i in range(0, xx.size):#生成特征 1
        for j in range(0, yy.size):#生成特征 2
            one_row = np.column_stack((xx[i], yy[j]))
            value = np.dot(feature_map(one_row),opt_theta) #预测结果
            z[i][j] = value
    z = z.T #z矩阵的第一行对应数据集的第一列，所以要转置
    plt.contour(X, Y, z, [0], colors='g')


    """
    绘制决策边界-End
    """
    plt.xlabel('Feature 1')
    plt.ylabel('Feature 2')


    plt.legend()
    plt.show()

```

正则化参数，λ = 1，代价函数 =  0.6931386454411619：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0315/114316_04fdcca2_5550632.png "屏幕截图.png")

 正则化参数，λ = 0，代价函数值= 0.2598871533548602：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0315/120831_d84f5bfa_5550632.png "屏幕截图.png")

<br>

### Programming Exercise 3 Multi-class Classification and Neural Networks

**问题描述**

```
  In this exercise, you will implement one-vs-all logistic regression and neural networks to recognize hand-written digits.In the first part of the exercise, you will extend your previous implemention of logistic regression and apply it to one-vs-all classification.You are given a data set in ex3data1.mat that contains 5000 training examples of handwritten digits.
  There are 5000 training examples in ex3data1.mat, where each training example is a 20 pixel by 20 pixel grayscale image of the digit. Each pixel is represented by a floating point number indicating the grayscale intensity at that location. The 20 by 20 grid of pixels is "unrolled" into a 400-dimensional vector. Each of these training examples becomes a single row in our data matrix X. This gives us a 5000 by 400 matrix X where every row is a training example for a handwritten digit image.The second part of the training set is a 5000-dimensional vector y thatcontains labels for the training set. To make things more compatible with Octave/MATLAB indexing, where there is no zero index, we have mappedthe digit zero to the value ten. Therefore, a "0" digit is labeled as "10", while the digits "1" to "9" are labeled as "1" to "9" in their natural order.
```

```
题目大意：
在本次练习中，你将实现一个一对多的逻辑回归模型和神经网络来识别手写数字。在第一部分的练习中，你将拓展先前的逻辑回归，使应用到一对多分类问题中。5000个手写数字的数据集在ex3data1.mat中给出。5000个训练样例是由20*20像素的灰度图片构成的，每一个像素都是一个浮点数，用于描述其在当前区域的灰度强度，这些像素被展开成一个400维的向量，因此我们拥有一个5000*400的特征矩阵X，每一行都是一张手写数字图片。同理我们拥有一个5000维的标签向量,为了适应Octave/MATLAB，没有0索引，数字0的标签为10，1-9为1-9
```

**数据可视化**

```python
import numpy as np
import scipy.io as io
import matplotlib.pyplot as plt


FILE_PATH = r"ex3data1.mat"


def load_data(file_path):
    """
    
    :param file_path: 
    :return:data->dict,key="X",value="y"
     X(5000, 400),y(5000, 1)
    """
    data = io.loadmat(file_path)
    # print(data["X"].shape)
    # print(data["y"].shape)
    return data["X"],data["y"]


def show_image(X,n=10):
    """
    从手写数字特征矩阵中随机拿出n*n个数字进行可视化
    :param X: 手写数字数据集
    :param n: n*n个数字
    :return: 
    """
    images = np.zeros((1,400))
    for i in range(n*n):
        pict_sub = np.random.randint(X.shape[0])
        image = X[pict_sub]
        images = np.row_stack((images,image))
    images = images[1:,:]
    fig, axes = plt.subplots(nrows=n, ncols=n)
    sub = 0
    for i in range(0,n):
        for j in range(0,n):
            axes[i,j].imshow(images[sub].reshape(20,20).T)
            sub+=1
    plt.show()


X,y=load_data(FILE_PATH)

show_image(X)

```

![输入图片说明](https://images.gitee.com/uploads/images/2021/0316/220725_2e684151_5550632.png "屏幕截图.png")

**向量化逻辑回归模型**

因为我们这次要分10类，所以要训练10个分类器，由此可以看出**向量化非常重要！！**

在这里我就直接复用上一节中的代码了。

```python
import numpy as np
import matplotlib.pyplot as plt
import scipy.optimize as op


def hypothesis_function(theta,X):
    """
    :param theta: 
    :param X: 
    :return: 
    """
    # print(X.shape)
    # print(theta.shape)
    z = X.dot(theta)
    return 1/(1+np.exp(-z))


def cost_function(theta,X,y,my_lambda = 0):
    """
    计算代价函数值
    :param X: 训练集
    :param y: 标签
    :param theta: 模型参数
    :param my_lambda: 正则化参数
    :return: 
    """
    m = X.shape[0]

    regularization = (my_lambda/2*m)*theta.T.dot(theta)
    left = np.dot((-y).T,np.log(hypothesis_function(theta,X)))
    right = np.dot((1-y).T,np.log(1 - hypothesis_function(theta,X)))
    cost = (left-right)/m+regularization
    #print(cost)
    return cost

def gradient(theta,X,y,my_lambda = 0):
    x_0 = X[:, 0]
    m = X.shape[0]
    temp = hypothesis_function(theta,X).flatten()-y

    partial_derivative_theta_0 = (1/m)*np.dot(temp,x_0)
    x_remain = X[:,1:].T
    tail = (my_lambda/m)*theta[1:]
    partial_derivative_theta_j = (1/m)*np.dot(x_remain,temp)-tail.flatten() #j>=1 时的偏导数
    res_partial_derivative = np.append(partial_derivative_theta_0,partial_derivative_theta_j)
    return res_partial_derivative

```

**一对多分类**

现在我们进行一对多分类，对于本问题我们将对数字 1做一个分类器，数字 2做一个分类器……详情请看如下核心代码：

```python
def one_vs_all(X,y,k,my_lambda = 0):
    n = X.shape[1]
    theta_all = np.zeros((k,n))
    for i in range(1,k+1):
        theta_i = np.zeros(n)
        res = op.minimize(cost_function,theta_i,args=(X,y==i,my_lambda),method='TNC',jac=gradient)
        # print("res: ",i)
        # print(res)
        theta_all[i-1] = res.x
    return theta_all
```

**结果展示**

```
训练集上模型准确度为: 94.56%
图片==> 0.png:识别该数字为:  0
图片==> 1.png:识别该数字为:  5
图片==> 2.png:识别该数字为:  2
图片==> 3.png:识别该数字为:  3
图片==> 4.png:识别该数字为:  4
图片==> 5.png:识别该数字为:  5
图片==> 6.png:识别该数字为:  6
图片==> 7.png:识别该数字为:  1
图片==> 8.png:识别该数字为:  5
图片==> 9.png:识别该数字为:  3
测试集上模型准确度为: 50.00%
```

<br>

**问题描述**

在之前的练习中，我们实现了一个一对多的多元逻辑回归分类器用于手写数字识别。识别效果不甚理想，这是因为它仅仅只是一个线性分类器【你也可以使用多项式特征，但是会增加计算开销】，无法使用非线性假设函数来拟合数据集。

在本次练习中，你将在相同的数据集上实现一个神经网络，它可以表示更复杂的模型。在本次练习中，将使用官方已准备好的神经网络的模型参数。你的目标是使用已知权重矩阵实现一个**前向传播模型**，在下次练习中，你将自己实现**反向传播算法来计算模型参数**。

我们的神经网络架构如下图所示：

![输入图片说明](https://images.gitee.com/uploads/images/2021/0323/212933_076ee2fa_5550632.png "屏幕截图.png")

输入层为400个输入单元，排除一个恒为1的偏置单元。第二层拥有25个神经元，输出层为10个神经元，用于分类。

```python
import numpy as np
import scipy.io as io

THETA_FILE_PATH = r"ex3weights.mat"

def get_theta(file_path):
    data = io.loadmat(file_path)
    return data["Theta1"],data["Theta2"]

theta_1,theta_2=get_theta(THETA_FILE_PATH)
print(theta_1.shape)
print(theta_2.shape)
```

```
(25, 401)
(10, 26)
```

**前向传播算法**

```python
import numpy as np
import scipy.io as io

THETA_FILE_PATH = r"ex3weights.mat"
FILE_PATH = r"ex3data1.mat"

def get_theta(file_path):
    data = io.loadmat(file_path)
    return data["Theta1"],data["Theta2"]

def get_data(file_path):
    data = io.loadmat(file_path)
    return data["X"], data["y"]

def sigmoid(z):
    return 1/(1+np.exp(-z))

def forward_propagation(X,theta1,theta2):
    z = sigmoid(X @ theta1.T)
    z = np.column_stack((np.ones((z.shape[0], 1)), z))
    final = sigmoid(z @ theta2.T)
    return final


if __name__ == '__main__':


    theta_1,theta_2=get_theta(THETA_FILE_PATH)
    X,y = get_data(FILE_PATH)
    X = np.column_stack((np.ones((X.shape[0],1)),X))

    final_theta = forward_propagation(X,theta_1,theta_2)
    y_prefi=np.argmax(final_theta,axis=1)+1
    y=y.flatten()
    acc=np.mean(y_prefi==y)
    print("训练集上模型准确度为: %.2f"%(acc*100) + "%")

```

```
训练集上模型准确度为: 97.52%
```

<br>

### Programming Exercise 4: Neural Networks Learning

在Ex3的基础上，我们要进行反向传播算法的实现，下图为这次神经网络的结构以及参数的维度，值得一提的是，我们把神经网络的**偏置全看做1**.

![输入图片说明](https://images.gitee.com/uploads/images/2021/1011/151247_8b6a0f37_5550632.png "屏幕截图.png")



**实现代价函数与标签值的转化**

因为标签值还是10和1-9，我们要把标签值翻译成神经网络输出层中的那个10维向量

```python
import scipy.io as io
import numpy as np
import matplotlib.pyplot as plt


DATA_SET_PATH = r"dataset/ex4data1.mat"
WEIGHT_PATH = r"dataset/ex4weights.mat"

data_mat_dict = io.loadmat(DATA_SET_PATH)
weight_mat_dict = io.loadmat(WEIGHT_PATH)

X = data_mat_dict["X"]  # 这是数据集中的特征向量,5000*400,每一行代表一个数字,数字图片是20*20的
y = data_mat_dict["y"]  # 这是数据集中的标签,5000*1,1-10对应1-0这十个数字

X = np.insert(X, 0, values=np.ones((1, X.shape[0])), axis=1, )

theta_1 = weight_mat_dict["Theta1"]  # 25*401
theta_2 = weight_mat_dict["Theta2"]  # 10*26

print("X: ", X.shape)
print("y: ", y.shape)
print("Theta1: ", theta_1.shape)
print("Theta2: ", theta_2.shape)

"""
设神经网络结构为
Input:5000*401
H_1: W^[1]:35*401,b^[1]:5000*1 = 1
Output:W^[2]:10*35,b^[2]:5000*1 = 1
"""


def calc_z(theta_matrix, feature_x):
    return np.dot(feature_x, theta_matrix.T)


def activate_function(z):
    return 1 / (1 + np.exp(-z))


def activate_function_gradient(z):
    return activate_function(z)(1 - activate_function(z))


def cost_function(predict_y, label_y, regularization=0.0):
    print("predict_y: ", predict_y.shape)
    print("label_y: ", label_y.shape)
    m = y.shape[0]
    part_a = label_y * np.log(predict_y)
    part_b = (1 - label_y) * np.log((1 - predict_y))
    sum_part = np.sum(part_a + part_b)

    return (sum_part / (-m)) + regularization


def regularize(m, theta_matrix_tup, my_lambda=1):
    n = len(theta_matrix_tup)  # 矩阵个数
    sum_result = 0
    for sub_i in range(0, n):
        # print(theta_matrix[sub_i].shape)
        sum_result += np.sum(np.dot(theta_matrix_tup[sub_i], theta_matrix_tup[sub_i].T))
    reg_result = my_lambda / (2 * m) * sum_result
    print("reg: ", reg_result)
    return reg_result


def recode_label(label_y):
    # 把标签0-9重编码:10 = [0,0,0,0,0,0,0,0,0,1](1*10)
    matrix_y = np.zeros((label_y.shape[0], 10))
    for sub_i in range(0, label_y.shape[0]):
        matrix_y[sub_i, label_y[sub_i] - 1] = 1
        # print(label_y[sub_i],matrix_y[sub_i,:])
    return matrix_y


def forward_propagation(theta_1, theta_2, feature_x):
    z_1 = calc_z(theta_1, feature_x)
    a_1 = activate_function(z_1)
    a_1 = np.insert(a_1, 0, np.ones((1, a_1.shape[0])), axis=1)
    print("a_1: ", a_1.shape)
    z_2 = calc_z(theta_2, a_1)
    a_2 = activate_function(z_2)
    print("a_2: ", a_2.shape)
    return a_2


def main():
    y_predict = forward_propagation(theta_1, theta_2, feature_x=X)
    y_true = recode_label(label_y=y)
    reg = regularize(m=y_true.shape[0], my_lambda=1, theta_matrix_tup=(theta_1, theta_2))
    print(cost_function(predict_y=y_predict, label_y=y_true, ))
    print(cost_function(predict_y=y_predict, label_y=y_true, regularization=reg))


main()

```

然后对答案：

```
0.2876291651613189(不带正则项：0.287629)
0.3527834696960166(带正则项：0.383700)
```

**实现sigmoid的梯度**

```python

def activate_function(z):
    return 1 / (1 + np.exp(-z))


def activate_function_gradient(z):
    return activate_function(z)*(1 - activate_function(z))
```

代数对答案：

```
z=0,梯度=0.25
```

**随机初始化参数矩阵Θ**

```python
def random_init_theta(m_shape, init_epsilon=0.12):
    result = (2 * init_epsilon) * np.random.random(m_shape) - init_epsilon
    return result
```

**完整代码**

```python
import scipy.io as io
import numpy as np
import matplotlib.pyplot as plt

DATA_SET_PATH = r"dataset/ex4data1.mat"
WEIGHT_PATH = r"dataset/ex4weights.mat"

data_mat_dict = io.loadmat(DATA_SET_PATH)
weight_mat_dict = io.loadmat(WEIGHT_PATH)

X = data_mat_dict["X"]  # 这是数据集中的特征向量,5000*400,每一行代表一个数字,数字图片是20*20的
y = data_mat_dict["y"]  # 这是数据集中的标签,5000*1,1-10对应1-0这十个数字

X = np.insert(X, 0, values=np.ones((1, X.shape[0])), axis=1, )

theta_1 = weight_mat_dict["Theta1"]  # 25*401
theta_2 = weight_mat_dict["Theta2"]  # 10*26

print("X: ", X.shape)
print("y: ", y.shape)
print("Theta1: ", theta_1.shape)
print("Theta2: ", theta_2.shape)

"""
设神经网络结构为
Input:5000*401
H_1: W^[1]:35*401,b^[1]:5000*1 = 1
Output:W^[2]:10*35,b^[2]:5000*1 = 1
"""


def calc_z(theta_matrix, feature_x):
    return np.dot(feature_x, theta_matrix.T)


def activate_function(z):
    return 1 / (1 + np.exp(-z))


def activate_function_gradient(z):
    return activate_function(z) * (1 - activate_function(z))


def cost_function(predict_y, label_y, regularization=0.0):
    """
    计算代价函数
    :param predict_y:
    :param label_y:
    :param regularization:
    :return:
    """
    # print("predict_y: ", predict_y.shape)
    # print("label_y: ", label_y.shape)
    m = y.shape[0]
    part_a = label_y * np.log(predict_y)
    part_b = (1 - label_y) * np.log((1 - predict_y))
    sum_part = np.sum(part_a + part_b)

    return (sum_part / (-m)) + regularization


def regularize(m, theta_matrix_tup, my_lambda=1):
    """
    正则化
    :param m:
    :param theta_matrix_tup:
    :param my_lambda:
    :return:
    """
    n = len(theta_matrix_tup)  # 矩阵个数
    sum_result = 0
    for sub_i in range(0, n):
        # print(theta_matrix[sub_i].shape)
        sum_result += np.sum(np.dot(theta_matrix_tup[sub_i], theta_matrix_tup[sub_i].T))
    reg_result = my_lambda / (2 * m) * sum_result
    print("reg: ", reg_result)
    return reg_result


def recode_label(label_y):
    # 把标签0-9重编码:10 = [0,0,0,0,0,0,0,0,0,1](1*10)
    matrix_y = np.zeros((label_y.shape[0], 10))
    for sub_i in range(0, label_y.shape[0]):
        matrix_y[sub_i, label_y[sub_i] - 1] = 1
        # print(label_y[sub_i],matrix_y[sub_i,:])
    return matrix_y


def forward_propagation(theta_1, theta_2, feature_x):
    """
    前向传播
    :param theta_1:
    :param theta_2:
    :param feature_x:
    :return:
    """
    z_1 = calc_z(theta_1, feature_x)
    a_1 = activate_function(z_1)
    a_1 = np.insert(a_1, 0, np.ones((1, a_1.shape[0])), axis=1)
    # print("a_1: ", a_1.shape)
    z_2 = calc_z(theta_2, a_1)
    a_2 = activate_function(z_2)
    # print("a_2: ", a_2.shape)
    return a_2, a_1, z_1


def random_init_theta(m_shape, init_epsilon=0.12):
    result = (2 * init_epsilon) * np.random.random(m_shape) - init_epsilon
    return result


def back_propagation(y_true, a_2, a_1, w_2, z_1, a_0):
    m = y_true.shape[0]
    d_z_2 = a_2 - y_true
    # print("d_z_2: ", d_z_2.shape)
    # print("A_1.T: ", a_1.T.shape)
    d_w_2 = np.dot(a_1.T, d_z_2) / m
    # print("w_2[ :,1:].T: ",w_2[:,1:].T.shape)
    # print("d_z_2.T: ",d_z_2.T.shape)

    # print("z_1: ",z_1.shape)
    d_z_1 = np.dot(w_2[:, 1:].T, d_z_2.T) * activate_function_gradient(z_1).T
    # print("d_z_1: ",d_z_1.shape)
    # print("a_0: ",a_0.shape)

    d_w_1 = np.dot(d_z_1, a_0)
    return d_w_1, d_w_2


def gradient_descent(feature_matrix, y_true, theta_1, theta_2, alpha=0.001, it=1000):
    for i in range(it):
        a_2, a_1, z_1 = forward_propagation(theta_1, theta_2, feature_matrix)
        d_w_1, d_w_2 = back_propagation(y_true, a_2, a_1, theta_2, z_1, feature_matrix)
        # print("theta_1: ",theta_1.shape)
        # print("d_w_1: ", d_w_1.shape)
        #
        # print("theta_2: ",theta_2.shape)
        # print("d_w_2.T: ", d_w_2.T.shape)
        theta_1 = theta_1 - alpha * d_w_1
        theta_2 = theta_2 - alpha * d_w_2.T
        print(
            "episode:%s,Cost:%s" % (i, cost_function(forward_propagation(theta_1, theta_2, feature_matrix)[0], y_true)))
    return theta_1, theta_2


def train(feature_x, label_y):
    my_theta_1 = random_init_theta((25, 401))
    my_theta_2 = random_init_theta((10, 26))
    my_theta_1, my_theta_2 = gradient_descent(feature_x, label_y, my_theta_1, my_theta_2, alpha=0.08, it=1150)
    print("Cost: ", cost_function(forward_propagation(my_theta_1, my_theta_2, feature_x)[0], label_y))
    return my_theta_1, my_theta_2


def test(X, y, my_theta_1, my_theta_2, theta_1, theta_2):
    i = 0
    for i in range(0, 1000):
        a_2, a_1, z_1 = forward_propagation(theta_1, theta_2, X[i, :].reshape((X[i].shape[0], 1)).T)
        print("predict_1: ",print_digit(np.argmax(a_2, axis=1)[0]) )
        my_a_2, my_a_1, my_z_1 = forward_propagation(my_theta_1, my_theta_2, X[i, :].reshape((X[i].shape[0], 1)).T)
        print("predict_2:", print_digit(np.argmax(my_a_2, axis=1)[0]))
        print("true: ", y[i]%10)


def print_digit(num):
    res = num + 1
    if res == 10:
        return 0
    else:
        return res


def main():
    # y_predict = forward_propagation(theta_1, theta_2, feature_x=X)
    y_true = recode_label(label_y=y)
    # reg = regularize(m=y_true.shape[0], my_lambda=1, theta_matrix_tup=(theta_1, theta_2))
    # print(cost_function(predict_y=y_predict, label_y=y_true, ))
    # print(cost_function(predict_y=y_predict, label_y=y_true, regularization=reg))

    my_theta_1, my_theta_2 = train(X, y_true)

    test(X, y, my_theta_1, my_theta_2, theta_1, theta_2)
    # res = forward_propagation(theta_1,theta_2,X[0,:].reshape(X[0].shape[0],1).T)[0]
    # print("predict_1: ", print_digit(np.argmax(res, axis=1)[0]))

main()

```

<br>

###  Programming Exercise 5: Regularized Linear Regression and Bias v.s.
Variance

```
In the first half of the exercise, you will implement regularized linear regression to predict the amount of water flowing out of a dam using the change of water level in a reservoir.In the next half, you will go through some diagnostics of debugging learning algorithms and examine the effects of bias v.s. variance.
```

```
在前半部部分的练习中，你将实现一个带有正则化的线性回归模型，通过水位来预测大坝的排水流量。在下半部分，将去使用一些机器学习诊断法来调试和验证算法在偏差（欠拟合）和方差（过拟合）上的问题。
```

**数据集说明**

![输入图片说明](https://images.gitee.com/uploads/images/2021/1012/203043_f8f811a1_5550632.png "屏幕截图.png")

**训练集可视化**

```python
import scipy.io as io
import numpy as np
import matplotlib.pyplot as plt

DATA_SET_PATH = r"dataset/ex5data1.mat"


def load_dataset(file_path):
    data_dict = io.loadmat(file_path)
    training_set_x = data_dict["X"]
    training_set_y = data_dict["y"]
    test_set_x = data_dict["Xtest"]
    test_set_y = data_dict["ytest"]
    cross_validation_x = data_dict["Xval"]
    cross_validation_y = data_dict["yval"]
    return training_set_x, training_set_y, cross_validation_x, cross_validation_y, test_set_x, test_set_y

def draw_training_set(x,y):
    x = x.T
    y = y.T
    plt.scatter(x,y,marker='x',c="red",label="Training set")
    plt.legend()
    plt.xlabel("change in water level")
    plt.ylabel("Water flowing of the dam")
    plt.show()

def main():
    training_set_x, training_set_y, cross_validation_x, cross_validation_y, test_set_x, test_set_y = load_dataset(
        DATA_SET_PATH)

    draw_training_set(training_set_x,training_set_y)

if __name__ == '__main__':
    main()
```

![输入图片说明](https://images.gitee.com/uploads/images/2021/1012/203650_d85b94d6_5550632.png "屏幕截图.png")

**带有正则项的代价函数**

```python
def regularized_cost_function(theta,x,y,my_lambda = 1):
    m = x.shape[0]
    predict_y = hypothesis_function(theta,x)
    part_a = (np.dot((predict_y-y).T,(predict_y-y)))/(2*m)
    part_b = (my_lambda/(2*m))*(np.dot(theta[1,:].T,theta[1,:]))
    res = part_a+part_b
    return res
```

```
303.99319222
答案：303.993
```

**计算梯度**

```python
def calc_gradient(theta, x, y,lambd = 1):
    m = x.shape[0]
    X_0 = x[:,0]
    X_j = x[:,1:]
    theta_j = theta[1:,0]
    term = np.dot(x,theta)-y
    theta_0_grad = (1/m)*(np.dot(X_0.T,term))
    theta_j_grad = (1/m)*(np.dot(X_j.T,term))+ (lambd/m)*theta_j
    return np.array([theta_0_grad.flatten(),theta_j_grad.flatten()])
```

```
结果与答案:
[[-15.30301567]
 [598.25074417]]
[-15.30; 598.250]
```

之后训练模型，在lambda=0时进行训练，并得到相关结果,再进行可视化：

![输入图片说明](https://images.gitee.com/uploads/images/2021/1013/162112_2631c49f_5550632.png "屏幕截图.png")

参考答案：

![image-20211013162136914](C:\Users\micha\AppData\Roaming\Typora\typora-user-images\image-20211013162136914.png)

**画出学习曲线**

我的：

![输入图片说明](https://images.gitee.com/uploads/images/2021/1013/185159_60ea31c6_5550632.png "屏幕截图.png")


官方答案：

![输入图片说明](https://images.gitee.com/uploads/images/2021/1013/185210_e2c58d8c_5550632.png "屏幕截图.png")

**多项式回归**

在多项式回归中，我们的假设函数形式为：
$$
h_\theta(x)=\theta_0+\theta_1x+\theta_2x^2+...+\theta_px^p
$$

```python
def construct_k_polynomial(ndarr,k = 5):
    """

    :param ndarr: ndarray类型，(m,1)
    :param k: k阶
    :return: (m,k)
    """
    for my_pow in range(2,k+1):
        #np.insert(x, 0, values=np.ones((1, m)), axis=1, )
        ndarr = np.insert(ndarr,my_pow-1,values=ndarr[:,0]**my_pow,axis=1)
    return ndarr
```

**训练多项式回归**

在本小节中，我们会使用8阶的特征向量，那么此时如果我们直接在投影出的数据集上进行训练，效果是非常不好的。

假设x=40，我们的第8列会计算出$40^8=6.5*10^{12}$，这个量级和40比一比，是不是相差甚远？因此我们需要标准化。

对于每一列，我们都计算平均值和方差，然后对每个指标进行规约。当正则化系数为0时，进行模型训练，得出代价函数图像和学习曲线图像。

<img src="https://images.gitee.com/uploads/images/2021/1213/123353_88e54fcd_5550632.png" alt="输入图片说明" title="屏幕截图.png" style="zoom:50%;" />

代价函数图像如上图所示，可以看出该函数极其复杂，但完全拟合了训练集中的数据，训练结果显示，此时的代价函数值为：$0.21$

然后，让我们看看学习曲线：

<img src="https://images.gitee.com/uploads/images/2021/1213/123609_39fab514_5550632.png" alt="输入图片说明" title="屏幕截图.png" style="zoom:50%;" />

可以看出，在训练集上，我们基本不存在模型误差，但是在交叉验证集上确出现了较大的波动，两条曲线中存在一个很明显的gap，说明此时模型过拟合了。附上官方的实验结果**（注：官方的画图范围和我的不同，我偷懒了只画了数据集上的那几个点，所以看起来特别的直，他的看起来更好看因为采样范围比我宽，但是实验想说明的问题是一样的）**：

<img src="https://images.gitee.com/uploads/images/2021/1213/123821_68026c41_5550632.png" alt="输入图片说明" title="屏幕截图.png" style="zoom:50%;" />

<img src="https://images.gitee.com/uploads/images/2021/1213/123851_20b4d431_5550632.png" alt="输入图片说明" title="屏幕截图.png" style="zoom:50%;" />

**调整正则化系数减少过拟合现象**

在下面的两个实验中。我们使用正则化系数为1，100。这两个值来观察对方差问题的影响。

**λ=1**

<img src="https://images.gitee.com/uploads/images/2021/1213/124434_10c8bff1_5550632.png" alt="输入图片说明" title="屏幕截图.png" style="zoom:67%;" />

此时，我们可以明显地看出，模型在交叉验证集上的误差在减小，同时训练集和交叉验证集的误差趋向于某一个数，此时模型效果是较好的。

**λ=100**

<img src="https://images.gitee.com/uploads/images/2021/1213/125240_0171229b_5550632.png" alt="输入图片说明" title="屏幕截图.png" style="zoom:67%;" />

可以看出由于惩罚项过大，导致模型无法拟合数据集，出现了高偏差问题，从学习曲线中也可以看出，两个数据集上的误差都很大。

实验结果表明，通过更改正则化系数，确实可以影响模型的训练效果。它越大，越能解决过拟合的问题

### Programming Exercise 6: Support Vector Machines

在本章练习中，我们将动手实现一个SVM分类器，用于垃圾邮件的分类。本章练习分为两大部分，前半段内容是在二维数据上使用带有Guassian核函数的SVM用于回忆起基本原理。后半段是创造SVM垃圾邮件分类器。由于SVM训练器实现的复杂性。本节并没有实现SVM的具体代码，而是调用了SVM训练库。

**热身**

我们的数据集如下图所示：

<img src="https://images.gitee.com/uploads/images/2021/1215/083731_38de89d3_5550632.png" alt="输入图片说明" title="屏幕截图.png" style="zoom:50%;" />

正样本为“+”，负样本为“O”。

其中，存在一条肉眼可见的线性分割界限，同时还有一个利群的正样本（0.1，4.1）

按照作业要求，我们需要尝试不同的C值，来观测超平面的绘制。但是，想画超平面我们需要做如下的编程工作：

1.可视化数据集

2.编写假设函数

3.编写代价函数

4.写SVM参数训练算法（不确定还用不用梯度下降）

5.画图

看着任务不多，其实光画图就要了命了。
