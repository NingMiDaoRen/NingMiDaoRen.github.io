---
title: 用户分组
date: 2020-02-21 14:34:30
tags: [算法,贪心算法]
categories: [计算机基础,算法,贪心算法]
copyright: true
description:
---

<meta name="referrer" content="no-referrer" />  
<!--more-->

# 用户分组

## 题目描述
有 n 位用户参加活动，他们的 ID 从 0 到 n - 1，每位用户都 恰好 属于某一用户组。给你一个长度为 n 的数组 groupSizes，其中包含每位用户所处的用户组的大小，请你返回用户分组情况（存在的用户组以及每个组中用户的 ID）。

你可以任何顺序返回解决方案，ID 的顺序也不受限制。此外，题目给出的数据保证至少存在一种解决方案。


## 测试用例
示例 1：

输入：groupSizes = [3,3,3,3,3,1,3]
输出：[[5],[0,1,2],[3,4,6]]
解释： 
其他可能的解决方案有 [[2,1,6],[5],[0,4,3]] 和 [[5],[0,6,2],[4,3,1]]。


示例 2：

输入：groupSizes = [2,1,3,3,3,2]
输出：[[1],[0,5],[2,3,4]]



## 数据规模及约定
groupSizes.length == n
1 <= n <= 500
1 <= groupSizes[i] <= n

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/group-the-people-given-the-group-size-they-belong-to
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



## 题目翻译

> 已知条件：
>
> 一个数组
>
> > 数据含义：
> >
> > 1. 数组长度代表用户总数
> > 2. 数组中的值，代表此用户**所在分组的最大容纳人数**
> >
> > > 目的：
> > >
> > > 找出其中**一种分组方式**，要求输出分组，以及分组里的用户id
>
> 坑：
>
> 关于“组”，在这道中，组是不用相互之间进行区别的。比如说，上限人数为2的组有2个，那么是不进行区分组1，组2以及组内的人员id的，只要分出来即可。



## 解题思路

### 策略分析
我们将目光着重看在**每个人的身上**。流程很简单，抓到一个人，就往一个组里塞（只要组没满），组满了，就再开一个组，把他扔进去。
以 groupSizes  = [2,1,3,3,3,2] 为例进行分析。
假设 i 为每个人的id
i = 0 这个人的组的最多有2个人,[0]

i = 1 这个人的组最多有1个人,[1]

i = 2 这个人的组最多有3个人,[2]
i = 3 这个人的组最多有3个人,[2,3]
i = 4 这个人的组最多有3个人,[2,3,4]

i = 5 这个人的组最多有2个人,[1,5]

答案: [ [0,5],[1],[2,3,4] ]


### 编程结构分析

**从返回值角度分析**

要求是输出分组及其结果，那么返回值势必是一个类似于二维数组这样的东西

**从策略角度分析**

需要一种以**组的容纳大小为key,组员数组为value的机制**，组织 组和成员之间的结构
返回值里的数组可以动态变化

综上:
在C++中，我选择使用vector和map这两种结构组织数据，前者可以免去我动态申请内存的麻烦，后者可以满足我的策略需求。





## 代码

```c++
#include<iostream>
#include<vector>
#include<map>

using namespace std;
vector<vector<int> > groupThePeople(vector<int>& groupSizes);
void print(vector<vector<int> > matrix);

int main()
{
	vector<int> input = {3,3,3,3,3,1,3};
	print(groupThePeople(input));
	return 0;
}

vector<vector<int>> groupThePeople(vector<int>& groupSizes) 
{
	map<int,vector<int> > m1;
	vector<vector<int> > res;
	for(int i = 0;i<groupSizes.size();i++)
	{
		m1[groupSizes[i]].push_back(i);//向组里扔人
		if(m1[groupSizes[i]].size() == groupSizes[i])//满员了
		{
			res.push_back(m1[groupSizes[i]]);//追加到返回值数组
			m1[groupSizes[i]] = {};//创建新组【清空该key对应的value】
		}
	}
    return res;
}

void print(vector<vector<int> > matrix)
{
	int i,j;
	for(i = 0;i<matrix.size();i++)
	{
		for(j = 0;j<matrix[i].size();j++)
		{
			cout << matrix[i][j] <<",";
		}
		cout << endl;
	}
}
```

