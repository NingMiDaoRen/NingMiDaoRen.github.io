---
title: 字母大小写全排列
declare: true
date: 2020-05-12 20:14:06
tags: [算法,回溯]
categories: [计算机基础,算法,回溯]
doc: true
copyright: true
---

<meta name="referrer" content="no-referrer" />  

<!--more-->

# 字母大小写全排列

## 题目描述

给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。

## 测试用例

示例:
输入: S = "a1b2"
输出: ["a1b2", "a1B2", "A1b2", "A1B2"]

输入: S = "3z4"
输出: ["3z4", "3Z4"]

输入: S = "12345"
输出: ["12345"]

## 数据规模

注意：

S 的长度不超过12。
S 仅由数字和字母组成。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/letter-case-permutation
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



## 思路分析

因为这是一道比较简单的关于回溯的例题，所以题目分析部分省略。我总结这道题的唯一目的就是要弄清楚，**回溯是如何运作的**。

回溯的目的就是，**当发现原先选择并不优或达不到目标，就退回一步重新选择**，如何让电脑回到原来的状态呢？说实话，我只能想到有两种方式。

> 1. 递归：递归分成两个过程，调用和回溯。
> 2. 堆栈：将当前状态压栈，新状态总会位于栈顶位置，当pop到“当前状态”时，就回溯到了起点。

观察本题，发现要求将所有字母进行全排列，那么推演一下：

a: a,A

ab: ab,Ab,aB,AB

![](https://images.gitee.com/uploads/images/2020/0512/203018_43c780e9_5550632.png)

由此，一颗递归树就孕育而生了。字母有两种状态：**大写**，**小写**。

我们认为从第二层开始，每一层都是对应的一个字母。所有左子树，都是当前字母保持不动的状态【图中为小写】，右子树取状态相反的情况【图中为大写】。

那么，**回溯**体现在什么地方呢？

我们假设，**当前字符的下标为 index**

看向右数的第一个叶子节点：

此时 index = 1，由于再+1，会出界，所以递归调用结束，**回溯到 ab**，然后再接着进行递归调用。

## 代码实现

```c++
#include <iostream>
#include<cstring>
#include<string>
#include<vector>
#include<ctype.h>

using namespace std;

vector<string> ans;
void dfs(string & s, int index);

vector<string> letterCasePermutation(string S) 
{
    dfs(S, 0);
    return ans;
}

void dfs(string & s, int index)
{
    if (index == s.size())
    {
        ans.push_back(s);
        return;
    }
    dfs(s, index+1);//不改变字母状态
    if (isalpha(s[index]))//改变字母状态
    {
        s[index] = s[index] >= 'a' ? s[index] - 32 : s[index] + 32;
        dfs(s, index + 1);
    }
}

int main()
{
    ios::sync_with_stdio(false);
    string s;
    cin >> s;
    vector<string> ans2 = letterCasePermutation(s);
    for (string e : ans2)
    {
        cout << e << "  ";
    }
    return 0;
}

```

