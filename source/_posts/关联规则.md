---
title: 关联规则
declare: true
date: 2020-05-23 11:08:21
tags: [算法,数据挖掘]
categories: [大数据]
toc: true
---

<meta name="referrer" content="no-referrer" />  

<!--more-->

# 关联规则

## Part 1 定义

​    关联分析又称关联挖掘，就是在交易数据、关系数据或其他信息载体中，查找存在于项目集合或对象集合之间的频繁模式、关联、相关性或因果结构。可从数据库中关联分析出形如“由于某些事件的发生而引起另外一些事件的发生”之类的规则。

## Part 2 频繁项集，闭项集

首先，什么是“项 (item)”？我们以超市购物举例子，超市中的每个商品都是一项，我们假设项的集合集 I：
$$
I = \{i_1,i_2,i_3,...,i_m\}\\
I = \{香槟,啤酒,巧克力,薯片,...\}
$$
其次，什么是事务数据库D？

事物数据库中里存的是一系列具有**唯一标识TID的事务（Transaction）**
$$
D = \{t_1,t_2,t_3,...,t_n\}\\
t_i(i = 1,2,3,...,n) ∈ I
$$
举个具体的例子就是，事务是**每个顾客的购物篮**，或是具体场景下的**选择记录**。

![](C:\Users\micha\Desktop\Word文档\001.png)

在这里，所有图书ID构成了一个**项集**，每位读者的借阅记录就是一个**事务**，**TID为读者ID**。

知道这些之后，我们再引出一些概念，首先是**k-项集 和 出现频度**。

### 2.1 k-项集与出现频度

k-项集，就是项集中有 k 个Item 的集合，比如在上图有关图书借阅的例子中 1项集长这样：

![](C:\Users\micha\Desktop\Word文档\001.png)

![](https://images.gitee.com/uploads/images/2020/0523/142432_5eba8fa1_5550632.png)

2项集长这样，图中的频度成为**绝对支持度*(support)***

在关联规则思想下，我们要先找出**频繁项集**，怎么找频繁项集呢？这里就涉及到了**最小支持度阈值**

## 2.2 最小支持度阈值

**通常我们是根据实际经验来设置最小支持度阈值的**，就本例而言，我将**最小支持度阈值设为0.2**，那我们找出来的频繁项集，就要过滤掉所有**支持度 < 0.2**的项集。

![](C:\Users\micha\Desktop\Word文档\002.png)

![](C:\Users\micha\Desktop\Word文档\003.png)

![](C:\Users\micha\Desktop\Word文档\004.png)

以上所有**$\color{red}{红色加粗}$**的字都是满足最小支持度阈值的频繁项集，有些细心的人可能会发现了，为什么在3项集的时候，我没有把所有情况都列举出来呢？因为我知道，其它的情况一定不是频繁项集，原因就是**闭项集**。

### 2.3 闭频繁项集和极大的频繁项集

**一个项集如果是频繁的，那它任意子集也一定是频繁的**，**一个项集如果是非频繁的，那么由它所形成的父集也是非频繁的**。

这句话不难理解，如果买{面包，牛奶，香肠}，是一个频繁项集，那么选择{面包，牛奶}的这个2项集也一定是一个频繁项集。用概率的形式来解释吧。
$$
假设：买面包，牛奶，火腿的概率和支持度s分别为\\
p_1,p_2,p_3,\alpha \\
前提：p_1*p_2*p_3 >= \alpha \quad (0< p_i< 1) \quad p_i = (1,2,3)\\
结论：小数乘法越乘越小，项数越少，概率越大
$$
闭频繁项集指的就是，对于一个项集 X ，你找的包含 X 的父集 Y ，只要 X , Y 的支持度不一样,你就可以说X是**闭频繁项集**。**极大频繁项集就算具有项数最多的频繁项集(可能不止一个)**。



### 2.4 通过频繁项集如何推荐





## Part 3 Apriori 算法

### 3.1 算法思路

Apriori算法的核心指导思想从它的名字中就能体现出来了，**先验性算法**，**先验性质**，其实我们之前就已经说过了，这里再明确严谨地定义一下。

**先验性质(Apriori property)**：***频繁项集的所有非空子集也一定是频繁的***

### 3.2 算法过程

#### 3.2.1 算法宏观描述

由于是先验性的，所有我们会**先收集满足最小支持度阈值的频繁1项集**。记该集合为 **L1**。然后使用 L1 找出频繁 2 项集 L2，使用 L2找出L3，以此类推，直到找不出频繁k项集为止。由此可知，每找一次Lk都需要完整地扫描一遍数据库，此时我们为了提高算法效率，要使用之前所说的**先验性质**。

#### 3.2.2 算法具体拆分





