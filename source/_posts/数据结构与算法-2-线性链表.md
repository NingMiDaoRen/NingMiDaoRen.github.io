---
title: 数据结构与算法(2)-线性链表
date: 2019-12-15 19:55:38
tags: [数据结构,链表]
categories: [计算机基础,线性表]
copyright: true
description:
---

<meta name="referrer" content="no-referrer" />  
<!--more-->

[TOC]



# Part 1 线性链表

## 1.1 线性链表的特点及其构造

&emsp;为了克服顺序存储结构在插入和删除方面的缺点，下面介绍一种新的线性表的存储方式--**链式存储结构**

这种新型存储结构与顺序存储结构相比有一个很大的区别，***链式存储结构不再要求逻辑上相邻的元素在存储单元中一定要连续***。

&emsp;链式存储图例

![](https://images.gitee.com/uploads/images/2019/1215/201750_396fd3df_5550632.jpeg)

&emsp;怎么才能用图中的方式存储呢？我们不仅要能存元素的值，还要存储一个能指示其后继元素的关系，这两部分组成了一个数据元素的存储结构，称之为一个链结点。如下图：

![](https://images.gitee.com/uploads/images/2019/1215/202603_d6614c61_5550632.png)

![](https://images.gitee.com/uploads/images/2019/1215/203552_c3a9a32c_5550632.png)

## 1.2线性链表的基本算法

### 1.2.1 链表结构体以及宏定义

```c++
#include<iostream>
#include<malloc.h>

using namespace std;

typedef struct LinkListNode
{
	int data;
	struct LinkListNode *next;
}LinkList;
#define SIZE_OF_NODE sizeof(LinkList)

void list_init(LinkList * &list)
{
	list = (LinkList *)malloc(SIZE_OF_NODE);
	list->next = NULL; 
}

bool is_empty(LinkList *list)
{
	if(list->next == NULL)
	{
		return true;
	}
	return false;
}

```

### 1.2.2 链表插入算法

```c++
void prepend_list(LinkList * &list,int elem)
{
	LinkList *p;
	p = (LinkList *)malloc(SIZE_OF_NODE);
	p->data = elem;
	if(is_empty(list))
	{
		list->next = p;
		p->next = NULL;
		return;	
	}
	else
	{
		p->next = list->next;
		list->next = p;
	}	
}


void append_list(LinkList * &list,int elem)
{
	LinkList * p = list,*q;
	q = (LinkList *)malloc(SIZE_OF_NODE);
	q->data = elem;
	q->next = NULL;
	if(is_empty(list))
	{
		prepend_list(list,elem);
		return;
	}
	else
	{
		while(p->next != NULL)
		{
			p = p->next;
		}
		p->next = q;		
	}
}

void insert_list(LinkList * &list,int index,int elem)
{
	int i;
	LinkList *p = list,*q;
	if(index <1)
	{
		return;
	}
	for(i = 1;i<index && p != NULL;i++)
	{
		p = p->next;
	}
	if(p == NULL)
	{
		append_list(list,elem);
		return;
	}
	q = (LinkList *)malloc(SIZE_OF_NODE);
	q->data = elem;
	p->next = q;
	q->next = p->next->next;	
}
```

![单链表插入示意图](..\..\source\_posts\数据结构与算法-2-线性链表\单链表插入示意图.png)

### 1.2.3 链表删除算法

```c++
void del_first(LinkList * &list)
{
	LinkList *p = list->next;
	list->next = p->next;
	free(p);
}

void del_last(LinkList *&list)
{
	LinkList *p = list;
	while(p->next->next != NULL)
	{
		p = p->next;
	}
	/*p->next 为最后一个结点*/
	free(p->next);
	p->next = NULL;
}

void del_data(LinkList * &list,int index,int & data)
{
	LinkList *p = list->next,*q;
	int i;
	for(i = 1;i<index && p != NULL;i++)
	{
		q = p;
		p = p->next;
	}
	if(p != NULL)
	{
		data = p->data;
		q->next = p->next;
		free(p);
		return;
	}
	else
	{
		data = 0;
		return ;
	}
}

```

### 1.2.4 链表其他算法

```c++
int count_length_recur(LinkList *list)
{
	if(list== NULL)
	{
		return 0;
	}
	return count_length_recur(list->next) + 1;
}

int count_length(LinkList *list)
{
	int cnt = 0;
	while(list != NULL)
	{
		cnt++;
		list = list->next;
	}
	return cnt;
}

void print_list(LinkList *list)
{
	LinkList *p = list->next;
	while(p->next != NULL)
	{
		cout << p->data << ",";
		p = p->next;
	}
	cout << endl;
}

/*链表反转*/
void invert(LinkList * &list)
{
	LinkList *p,*q,*r;
	p = list;
	q = NULL;
	while(p != NULL)
	{
		r = q;
		q = p;
		p = p->next;
		q->next = r;	
	}	
	list = q;
 
} 
```



# Part 2 线性链表拓展

## 2.1 循环链表及其操作

## 2.2 双向链表及其操作

