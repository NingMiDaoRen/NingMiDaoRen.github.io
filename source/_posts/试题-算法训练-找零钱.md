---
title: 试题 算法训练 找零钱
date: 2020-02-19 16:41:11
tags: [算法,贪心算法,竞赛]
categories: [计算机基础]
copyright: true
description:
---

<meta name="referrer" content="no-referrer" />  
<!--more-->

# 找零钱

## 资源限制

时间限制：1.0s  内存限制：256.0MB

## 题目描述

　　有n个人正在饭堂排队买海北鸡饭。每份海北鸡饭要25元。奇怪的是，每个人手里只有一张钞票（每张钞票的面值为25、50、100元），而且饭堂阿姨一开始没有任何零钱。请问饭堂阿姨能否给所有人找零（假设饭堂阿姨足够聪明）

## 输入格式

第一行一个整数n，表示排队的人数。

 接下来n个整数a[1],a[2],...,a[n]。a[i]表示第i位学生手里钞票的价值（i越小，在队伍里越靠前）

## 输出格式

输出YES或者NO

## 样例输入

第一组：

4
 25 25 50 50

样例输出

YES

第二组：

2
 25 100

样例输出

NO

第三组：

4
 25 25 50 100

样例输出

YES

## 数据规模和约定

n不超过1000000



## 题目翻译

简略概括一下就是：

>已知条件：
>
>一个**未排序**的整形数组和它的大小
>
>> 数据含义：
>>
>> 数组里的值代表着排队时每个人手里拿的钱
>>
>> > 目的：
>> >
>> > 判断整个数组是否可以全部找零成功
>
>坑：数组未排序



## 解题思路

这道题的重难点在于**怎么找零**上，我们很容易能想到：

1. 如果给了一张面值是25的，那么无需找零，且自己手上面值为25的钞票数加一张
2. 如果给了一张面值是50的，需要找零，自己手上面值为25的钞票数减一张，同时面值为50的钞票数加一张
3. 如果给了一张面值是100的，需要找零，找零策略就有两种了
   1. 一张50，一张25
   2.  三张25

本题的贪心策略体现就在，当给100时，找零的情况上。日常生活中，我们都喜欢**优先使用大面额**进行找零，而不是拿一大堆一块钱钢镚儿进行找零。

思路理解之后，代码就好写了

```c++
#include<iostream>
#include<algorithm>
using namespace std;
int arr[1000000+5] = {0};//数据规模太大，数组直接开在全局
bool simulate(int *arr,int n);
int main()
{
	int n;
	cin >> n;
	for(int i = 0;i<n;i++)
	{
		cin >> arr[i];
	}
	if(simulate(arr,n))
	{
		cout << "YES";
	}
	else
	{
		cout << "NO"; 
	}
	return 0;
}

//模拟找零法 100分 

bool simulate(int *arr,int n)
{
	int cnt_25 = 0,cnt_50 = 0;
	int i = 0;
	sort(arr,arr+n);
	while(i < n)
	{
		if(arr[i] == 25)
		{
			cnt_25++;
		}
		else if(arr[i] == 50)
		{
			if(cnt_25>0)
			{
				cnt_25--;
				cnt_50++;	
			}
			else
			{
				return false;	
			} 
		}
		else
		{
			if(cnt_25 > 0 && cnt_50 >0)
			{
				cnt_50--;
				cnt_25--;
			}
			else if(cnt_25>=3 && cnt_50 == 0)
			{
				cnt_25-=3;
			}
			else
			{
				return false;
			}
		}
		i++;	
	}
	return true;	
}

```



## 其他同类练习

在柠檬水摊上，每一杯柠檬水的售价为 5 美元。

顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。

注意，一开始你手头没有任何零钱。

如果你能给每位顾客正确找零，返回 true ，否则返回 false 。

示例 1：

输入：[5,5,5,10,20]
输出：true
解释：
前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
由于所有客户都得到了正确的找零，所以我们输出 true。


示例 2：

输入：[5,5,10]
输出：true


示例 3：

输入：[10,10]
输出：false


示例 4：

输入：[5,5,10,10,20]
输出：false
解释：
前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。
对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。
对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。
由于不是每位顾客都得到了正确的找零，所以答案是 false。




提示：


	0 <= bills.length <= 10000
	bills[i] 不是 5 就是 10 或是 20 

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/lemonade-change
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



### 附加答案

```java
public class MoneyChange
{
	public boolean lemonadeChange(int[] bills) 
    {
        int i = 0,cnt_5 = 0,cnt_10 = 0;
        while(i<bills.length)
        {
        	if(bills[i] == 5)
        	{
        		cnt_5++;
        	}
        	else if(bills[i] == 10)
        	{
				if(cnt_5 > 0)
				{
					cnt_5--;
					cnt_10++;
				}
				else
				{
					return false;
				}
        	}
        	else
        	{
        		if(cnt_5 > 0 && cnt_10 > 0)
        		{
        			cnt_5--;
        			cnt_10--;
        		}
        		else if(cnt_5 >= 3 && cnt_10 == 0)
        		{
        			cnt_5-=3;
        		}
        		else
        		{
        			return false;
        		}
        	}
        	i++;
        }
		return true;
    }
}
```

