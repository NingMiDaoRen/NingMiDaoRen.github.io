---
title: x86汇编语言
declare: true
date: 2020-04-08 09:31:48
toc: true
tags: 汇编语言
categories: [计算机基础,汇编]
---



<meta name="referrer" content="no-referrer" />  

<!--more-->



# x86汇编语言



注意： 学习前置条件，熟悉2，10，16进制之间的各种换算.



[TOC]



# Part 1 引子



## 1.1 如何用电表示数字

电子计算机，基于电，所以学会用电来表示数字，才能让计算机进行计算。在初中物理的电学中，我们知道，开关有**闭合**和**断开**两种情况。我们用 **0** 表示断开，没有电流通过，**1**表示闭合，有电流通过。

![](https://images.gitee.com/uploads/images/2020/0408/094839_2dc2c5bb_5550632.png)

上图，记录的导线状态，就是一个二进制数，从上向下看，表示了 01000100 

我偷个懒，给它转换一下就变成了

![](https://images.gitee.com/uploads/images/2020/0408/095222_7e141fa3_5550632.png)



从上到下，依次是 16进制，10 进制，8 进制，2 进制。当然了，要是正常算的话就是
$$
1*2^{2} + 1 * 2^{6} = 68 (十进制)
$$

现实中，我们不可能看到所有导线的状况，所以我们给它装个灯泡，亮了就是**1**，灭了就是**0**

![](https://images.gitee.com/uploads/images/2020/0408/095927_dc5d254a_5550632.png)



## 1.2 加法和四则运算器



![](https://images.gitee.com/uploads/images/2020/0408/100529_0196255d_5550632.png)

左侧输入 **01000100** = 68 (十进制) 

下端输入 **01100001** = 97 (十进制) 

右侧输出 **10100101** = 165 (十进制)



加法器的内部原理，在这里我们不关心，我们只需知道它的功能，但是你要是真的对内部原理感到好奇

[点这里满足你的好奇心](https://blog.csdn.net/qq_35732147/article/details/83997747?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2#%E4%B8%80%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E5%8A%A0%E6%B3%95%E8%A1%A8)





## 1.3 寄存器 - 一个有记忆功能的器件

![](https://images.gitee.com/uploads/images/2020/0408/103152_2366cd68_5550632.png)



我相信，前两部分大家都看的懂，我们着重讲解触发器的知识。

> 触发器结构特点：
>
> > 只有**一个输入端**和**一个输出端**
> >
> > > 触发器相关术语：
> > >
> > > > 触发器的输入叫做：**锁存**

其它概念：按键开关，是一个物理元器件，原理像按弹簧，摁下有电流通过，松手后立刻谈起，断开电路。

现在我们来看一下触发过程。

首先，我们轻触按键开关，发出**锁存命令**，此时，按键开关的那条线路有输入

![](https://images.gitee.com/uploads/images/2020/0408/104317_44a86f83_5550632.png)



然后，松手，按键开关弹开。按键开关的那条线路没有输入

![](https://images.gitee.com/uploads/images/2020/0408/104436_5df7fb15_5550632.png)

输出的内容是**锁存器之前的内容**【输入端的**1**】，在触发锁存命令之前，无论输入端如何变化，最终只会输出锁存的内容。

简单点说，**无论输入怎么变，按了开关，触发器就记录该锁存，之后触发器输出锁存内容**



![](https://images.gitee.com/uploads/images/2020/0408/105729_83e10a82_5550632.png)

![](https://images.gitee.com/uploads/images/2020/0408/105959_47377391_5550632.png)

所以，寄存器(Register)就是一个**能暂时存储若干个比特位的器件**

### 1.3.1 带寄存器的加法机

![](https://images.gitee.com/uploads/images/2020/0408/110712_10119b80_5550632.png)

装置说明：寄存器的输出端，就是加法电路的输出端，下方有两个开关**预置**和**相加**，左侧只有一组输入。

计算流程：

1. 首先左侧输入端，改成二进制的 5，按下**预置**

   > 寄存器保存当前输入 5 

2. 左侧输入端，改成二进制的 7 ，按下**相加**

   > 加法器运行，5 + 7，结果 12 保存在寄存器中，之前的结果被覆盖 

3. 左侧输入端，改成二进制 25，按下**相加**

   > 加法器运行，12 + 25 结果 37 保存在寄存器中，之前的结果被覆盖 



### 1.3.2 四则运算机

![](https://images.gitee.com/uploads/images/2020/0408/111747_9d2c0579_5550632.png)

> 预置 1 ---> *1*
>
> 加 9 ----> *10*
>
> 乘 2 ---> *20*
>
> 除以 5 ---> *4*

参照着之前的加法运算，现在想想如何操作这台机器 (长得像不像计算器...) 。



## 1.4 指令

![](https://images.gitee.com/uploads/images/2020/0411/191758_d7b851e2_5550632.png)

由于是带括号的运算，当运算到 (207 + 9) 和 (56 - 48) 时，需要腾出寄存器，需要把它们誊到纸上。为了解决这种问题，我们可以放置很多寄存器。

![](https://images.gitee.com/uploads/images/2020/0411/192044_17b36cb0_5550632.png)

咱们先只看有**2**个寄存器的情况，此时的操作，包括但不限于：

> 对寄存器 R 我们可以最其进行，加减乘除，预置操作
>
> 对寄存器 Z 我们同样可以对它进行，加减乘除，预置操作
>
> 寄存器 R 对 寄存器 Z 可以进行，加减乘除，预置操作
>
> 寄存器 Z 对 寄存器 R 可以进行，加减乘除，预置操作

共计 20+ 的操作，要是通过开关控制，就意味着要有20多个开关。所以我们进行了如下这样的设计。

![](https://images.gitee.com/uploads/images/2020/0411/193137_8882a957_5550632.png)

通过拨动开关组合指令，执行。不同的**指令**进行不同的机器动作。



## 1.5 内存和内存访问

随着寄存器数目的增加，指令的数量只会越来越多。如何让电脑自动执行预设好的指令，成为了很重要的问题。就此，内存孕育而生了。

![](https://images.gitee.com/uploads/images/2020/0411/195522_f798dd89_5550632.png)

聚焦于内存，它长这样

![](https://images.gitee.com/uploads/images/2020/0411/195706_4a8fdb22_5550632.png)

**一个不能进行读写的内存**的组成成分：

> **内存单元** + **地址线**

主流的内存单元是一个能存 8 bits 的元器件，而整个内存由若干个内存单元堆叠而成。为了唯一地访问内存单元，我们给每个单元都标注一个唯一的**内存地址**，(通常是个16进制数)，而表示内存地址的方法就是通过**地址线**的不同表示状态。

比如上图内存，只有两根地址线，那它们能组合出的结果就是：

```
00
01
10
11
```

所以一共最多表示 4 块内存单元

![](https://images.gitee.com/uploads/images/2020/0411/200302_5834b703_5550632.png)

8 根地址线可以表示256个内存单元。


$$
n 根地址线，能表示 2^n个内存单元
$$
习惯上使用**字节(Byte)**作为描述二进制序列长度的单位，**1 Byte = 8 bits**，所以一个内存单元就是 1 个字节。

> 1 KB  = 1024 B
>
> 1 MB = 1024 KB
>
> 1 GB = 1024 MB
>
> 1 TB = 1024 GB



**一个能读写的内存**长这样：

> **内存单元** + **地址线** + **数据线** + **读写控制**

![](https://images.gitee.com/uploads/images/2020/0411/201655_893c126d_5550632.png)



![](https://images.gitee.com/uploads/images/2020/0411/202439_100dbad2_5550632.png)





## 1.6 处理器



## 汇编语言的出现



## 汇编语言程序设计过程