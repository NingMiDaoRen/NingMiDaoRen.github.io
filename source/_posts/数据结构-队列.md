---
title: 数据结构-队列
date: 2020-02-26 13:23:16
tags: [数据结构,队列]
categories: [数据结构,计算机基础]
copyright: true
description:
---

<meta name="referrer" content="no-referrer" />  
<!--more-->

[TOC]



# 队列(Queue)

## Part 1 队列是什么

宏观定义：队列是一种操作受限的线性表。【逻辑结构为线性结构】

特性定义：队列是先进先出表 [First In First Out List]

举例：生活中排队买奶茶，在不插队的情况下，我们要求在**队头**的人先买，后来的人排在**队尾**。



**队列的结构解剖**

队头(head/front)：队列元素出队的位置

队尾(rear)：队列元素添加的位置



将这种模式映射到电脑，如何存储？



## Part 2 队列的存储结构

由定义可知，队列是一种特殊的线性表，那么线性表最基本的两种存储结构就是**顺序存储**和**链式存储**。

由此，我们着重讨论一下这两种队列的操作算法，及其改良版本。

然而，不讨论需求就跟我提编码业务，这是耍流氓的行为，下面我们简单分析一下队列这种数据结构应该有哪些操作【粗略分析，先有个方向】。

由于不用泛型，假设以下所有讨论的队列内的数据元素类型为 int

1. 初始化 queue_init()：初始化出一个队列
2. 入队 enqueue()：队尾添加元素
3. 出队 dequeue()：对头删除元素
4. 获取对头元素 get_head()
5. 统计元素队列中元素个数 count_num()



## 2.1 顺序存储结构的队列

以顺序表为载体，进行操作

### 示意图

![](https://images.gitee.com/uploads/images/2020/0226/135526_429ee9d3_5550632.png)



对于顺序队列我是这样设计的：

```c
#include<malloc.h>
#include<stdio.h>

#define MAX_SIZE 100
struct Queue
{
	int head,rear;
	int count;
	int data[MAX_SIZE];
};
```

我们可以看到结构体中有4条属性，包括功能属性count，逻辑属性head,rear，以及存储属性data。

通过count我们可以快速的实现队列的计数功能，head,rear则是逻辑控件，用来实现队列的逻辑特性(**先进先出**)，data用来存放队列中的元素。

### 2.1.1 初始化队列

操作数据需要内存空间，就如同盖房子需要地基一样，我们的第一个函数自然是初始化一个队列，并通过引用的方式获得指向该队列的内存首地址**指针**

```c
void queue_init(struct Queue *&queue)
{
	queue = (struct Queue *)malloc(sizeof(struct Queue));
	queue->count = 0;
	queue->rear = -1;
	queue->head = 0;
}
```

代码第一行，申请内存空间，大小是上述结构体的大小。

第二步，初始化计数器为零

第三步，置rear为-1方便队尾插入，head为0方便队头操作



### 2.1.2 队列入队/出队

```c
bool enqueue(struct Queue *&queue,int data)
{
	if(queue->rear == MAX_SIZE) return false;
	queue->data[++queue->rear] = data;
	queue->count++;
	return true;
}

int dequeue(struct Queue *&queue)
{
    if(queue->rear = -1 && queue->head == 0) return 0;
	if(queue->head == queue->rear) return 0;
	int res = queue->data[queue->head++];
	queue->count--;
	return res;
}
```

无论入队还是出队，第一步都是合法性判断。即，**队满还能入队吗？**，**对空还能出队吗？**的问题，显而易见，都是不行。

然后我们就要考虑入队和出队的核心操作

1. 队尾插入，rear初值为-1，所以++queue->rear，同时计数器 +1。

2. 队头出队，head初值为0，所以queue->head++,同时计数器即 -1。



### 2.1.3 其他操作

```c
int count_elem(struct Queue *queue)
{
	return queue->count;
}

int get_head(struct Queue *queue)
{
    if(queue->rear = -1 && queue->head == 0) return 0;
	if(queue->head == queue->rear)
	{
		return 0;	
	}
	return queue->data[queue->head];	
}
```



## 顺序队列的天生缺陷

我们以时间为轴，随着使用次数的增加，尤其是出队次数的增加我们会发现，可用空间越来越少。

![](https://images.gitee.com/uploads/images/2020/0329/165658_9d16c20d_5550632.png)

由于我们出队采用的是**跳过**而不是**覆盖**，这就导致我们的的红字部分存在明明可以用却用不了，进而导致了**假溢出**，解决这种问题的手段也不难。



## 2.2 循环队列

既然，问题的根源在于空间不能复用的问题，那么我们改一下设计，让空间可以复用即可。

所谓“复用空间”其实就是**让下标在0到MAX_SIZE-1之间合法地动起来**,把原值覆盖掉不就算是利用了空间吗？

为了方便想象，我把它化成了下图这个样子：

![](https://images.gitee.com/uploads/images/2020/0329/170549_bbfff870_5550632.png)

看到这，可能会有些疑问

1. 如何让进行出队，入队操作
2. 怎么才能确定对列已满

基于数学的**模运算**我们可以知道，假设一个大于n的数对n取模，其结果的区间是[0,n-1],这是不是像极了下标。



### 2.2.1 初始化队列

```c
#include<malloc.h>
#include<stdio.h>

#define MAX_SIZE 100

struct Queue
{
	int head,rear;
	int count;
	int data[MAX_SIZE];
};

void queue_init(struct Queue *&queue)
{
	queue = (struct Queue *)malloc(sizeof(struct Queue));
	queue->count = 0;
	queue->rear = 0;
	queue->head = 0;
}
```

整个函数依据上图设计



### 2.2.2 出队入队和相关辅助函数

```c
bool is_full(struct Queue *&queue)
{
	if(queue->head == (queue->rear+1)%MAX_SIZE) return true;
	return false;
}

bool is_empty(struct Queue *&queue)
{
	if(queue->head == queue->rear) return true;
	return false;
}

bool enqueue(struct Queue *&queue,int data)
{
	if(is_full(queue)) return false;
	else
	{
		queue->data[queue->rear] = data;
		queue->rear = (queue->rear+1)%MAX_SIZE;
		queue->count++;
		return true;
	}
}

int dequeue(struct Queue *&queue)
{
	if(is_empty(queue)) return -1;
	int res = queue->data[queue->head];
	queue->head = (queue->head+1)%MAX_SIZE;
	queue->count--;
	return res;
}
```

和之前一样考虑空和满的问题。

采用循环队列什么是空？初始状态就是空

采用循环队列什么是满？**head = (rear+1)%MAX_SIZE**时满，即队尾即将超过对头时。

基于这两点写出判别空满的函数

入队还是队尾插入，为了解决假溢出问题，我们最后是这样处理rear的**queue->rear = (queue->rear+1)%MAX_SIZE** 让rear向后迭代1，而且由于模运算导致最终结果一定合法，如果假设最大长度为100，当前为rear = 99，那么在下标为99的位置合法插入元素之后，rear变为100对100取余，rear = 0，这样就又转回第一位，空间得以利用，假溢出得以解决。

出队还是对头出队，在判断不为空后，取出返回值，最后和插入一样**queue->head = (queue->head+1)%MAX_SIZE** 理由类似，不再赘述。



### 2.2.3 循环队列的其他算法

```c
int count_elem(struct Queue *queue)
{
	return queue->count;
}

int get_head(struct Queue *queue)
{
	if(is_empty(queue))
	{
		return 0;	
	}
	return queue->data[queue->head];	
}
```



## 代码总结

### 普通顺序队列

```c
#include<malloc.h>
#include<stdio.h>

#define MAX_SIZE 100
struct Queue
{
	int head,rear;
	int count;
	int data[MAX_SIZE];
};

void queue_init(struct Queue *&queue);
bool enqueue(struct Queue *&queue,int data);
int dequeue(struct Queue *&queue);
int count_elem(struct Queue *queue);
int get_head(struct Queue *queue);

int main()
{
	struct Queue *que = NULL;
	int *res;
	queue_init(que);
	
	for(int i = 1;i<=100;i++)
	{
		enqueue(que,i);
	}
	printf("count: = %d\n",count_elem(que));
	printf("head: = %d\n",get_head(que));
	
	for(int i = 1;i<= 100 ;i++)
	{
		
		printf("res = %d,",dequeue(que));
	}
	return 0;
}

void queue_init(struct Queue *&queue)
{
	queue = (struct Queue *)malloc(sizeof(struct Queue));
	queue->count = 0;
	queue->rear = -1;
	queue->head = 0;
}

bool enqueue(struct Queue *&queue,int data)
{
	if(queue->rear == MAX_SIZE) return false;
	queue->data[++queue->rear] = data;
	queue->count++;
	return true;
}

int dequeue(struct Queue *&queue)
{
	if(queue->head == queue->rear) return 0;
	int res = queue->data[queue->head++];
	queue->count--;
	return res;
}

int count_elem(struct Queue *queue)
{
	return queue->count;
}

int get_head(struct Queue *queue)
{
	if(queue->head == queue->rear)
	{
		return 0;	
	}
	return queue->data[queue->head];	
}
```



### 循环队列

```c
#include<malloc.h>
#include<stdio.h>

#define MAX_SIZE 100

struct Queue
{
	int head,rear;
	int count;
	int data[MAX_SIZE];
};

void queue_init(struct Queue *&queue);
bool is_empty(struct Queue *&queue);
bool is_full(struct Queue *&queue);
bool enqueue(struct Queue *&queue,int data);
int dequeue(struct Queue *&queue);
int count_elem(struct Queue *queue);
int get_head(struct Queue *queue);


int main()
{
	struct Queue *que = NULL;
	int *res;
	queue_init(que);
	
	for(int i = 1;i<=100;i++)
	{	
		enqueue(que,i);
	}
	
	
	printf("count: = %d\n",count_elem(que));
	printf("head: = %d\n",get_head(que));
	
	for(int i = 1;i<= 100 ;i++)
	{
		
		printf("res = %d\n",dequeue(que));
	}
	return 0;
}

void queue_init(struct Queue *&queue)
{
	queue = (struct Queue *)malloc(sizeof(struct Queue));
	queue->count = 0;
	queue->rear = 0;
	queue->head = 0;
}

bool is_full(struct Queue *&queue)
{
	if(queue->head == (queue->rear+1)%MAX_SIZE) return true;
	return false;
}

bool is_empty(struct Queue *&queue)
{
	if(queue->head == queue->rear) return true;
	return false;
}

bool enqueue(struct Queue *&queue,int data)
{
	if(is_full(queue)) return false;
	else
	{
		queue->data[queue->rear] = data;
		queue->rear = (queue->rear+1)%MAX_SIZE;
		queue->count++;
		return true;
	}
}

int dequeue(struct Queue *&queue)
{
	if(is_empty(queue)) return -1;
	int res = queue->data[queue->head];
	queue->head = (queue->head+1)%MAX_SIZE;
	queue->count--;
	return res;
}

int count_elem(struct Queue *queue)
{
	return queue->count;
}

int get_head(struct Queue *queue)
{
	if(is_empty(queue))
	{
		return 0;	
	}
	return queue->data[queue->head];	
}
```



## 链式存储结构的队列



尚未开始









