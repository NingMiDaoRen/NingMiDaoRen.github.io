---
title: 编辑距离
declare: true
date: 2020-04-06 15:33:08
tags: [算法,动态规划]
categories: [计算机基础]
toc: true
---

<meta name="referrer" content="no-referrer" />  

<!--more-->

# 编辑距离



## 题目描述

给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：


	插入一个字符
	删除一个字符
	替换一个字符




示例 1：

输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')


示例 2：

输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/edit-distance
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



## 题目分析



> 已知条件:两个字符串数组，word1，word2
>
> > 目的:通过三种操作，使得word1和word2相等，且操作次数最少
> >
> > > 突破口：着重理解三种操作的实际含义!!!



**插入一个字符**

假设:

```c++
string word1 = "cat";
string word2 = "cate";
```

显而易见，在word1的“cat”后添加一个"e",它们相同，编辑距离为1



**删除一个字符**

```c++
string word1 = "cat";
string word2 = "cate";
```

两个字符串不变，现在，把word2的“cate”的“e”删掉，发现它们同样是相同的，编辑距离为1

到此为止我们可以发现，在一个串中的**插入**操作，和另一个串的**删除**操作是等价的。无外乎就是长的变短，短的补起，是一码回事。



**替换一个字符**

```c++
string word1 = "cat";
string word2 = "car";
```

解决了删除和插入的问题，现在来让我们看看替换，嗯，没啥可看的，替换就是替换，无论是t->r还是r->t都是替换，那就统一替换word1吧。

至此，我们将原来的问题就可以换成另外一种表达方式。



## 问题转化

> 已知:两个字符串word1,word2
>
> > 目的：找出最短操作数

操作方式：

> 1. 在单词word1串末尾添加字母
> 2. 在单词word2串末尾添加字母
> 3. 替换单词word1中的某个字母

而且上述三种操作关系是等价的

```c++
string word1 = "horse";
string word2 = "bors";
```

看，上述代码块中(以word2->word1为例)，无论是先把“b”替换成"h"再添加“e”,还是先添加再替换，这两种过程，最终都会得到同样的操作数**2**，所以我们认为这三种操作的权重是一样的，先后顺序无所谓。

## 解题思路



假设:

```
string A = "horse";
string B = "ros";
```

**在单词A中插入一个字母**

假设，我们已知，**“horse”**到**“ro”**的编辑距离为 a【把horse变成ro需要a次操作】 ,那么很容易得出**“horse”**到**“ros”**的编辑距离不会大于 a + 1,因为只需要在A的末尾添加一个**"s"**就能在 a + 1次操作后，使 **horse**和**ros**就能变成相同的单词。



**在单词B中插入一个字母**

已知**"hors"**到**“ros”**的编辑距离为 b ，那么**“horse”**到**“ros”**的编辑距离不会大于 b + 1，道理和之前相同。



**修改A中的字母**

已知**“hors”**到**“ro”**的编辑距离为 c ，那么同样的，**“horse”**到**“ros”**的编辑距离不会大于 c + 1【把e->s】

至此我们可以知道，把“horse” 变成“ros”的编辑距离应该是：

$$
min(a+1,b+1,c+1)
$$

举个最简单的例子

```c++
string word1 = "";
string word2 = "a";
```

基于上面的理论，我们只需要在word1后添加“a”即可，操作数为 **1**

```c++
string word1 = "ab";
string word2 = "";
```

同理，操作数为 2

```c++
string word1 = "";
string word2 = "abcdefghijklmnopqrstuvwxyz";
```

不多说了，26个字母和空串的的编辑距离为 26

虽说生搬硬套，形式主义不好，但是你品，你细品
$$
optimization = min(a+1,b+1,c+1)
$$
这玩意长得像不像状态转移方程，三种操作像不像决策，最终是不是在求一个最小值的最优解？

整个过程是不是可以通过时空进行划分成阶段？

没毛病了，都符合，这玩意就是动态规划，动态规划的数学相关概念我的博客里都有，感兴趣的小伙伴可以去看看，不感兴趣的我们接着向下看。

[动态规划](https://daoqi.github.io/2019/12/18/动态规划/)

我们假设，dp\[i\]\[j\] ，i 代表字母A的前 i 个字母，j 代表字母B前 j 个字母

![](https://images.gitee.com/uploads/images/2020/0406/171859_dd63b335_5550632.png)

所以，当A[i-1] = B[j-1]时:
$$
dp[i][j] = min(dp[i][j-1]+1,dp[i-1][j]+1,dp[i-1][j-1])
$$
当A[i-1] != B[j-1]时:
$$
dp[i][j] = min(dp[i][j-1]+1,dp[i-1][j]+1,dp[i-1][j-1]+1)
$$


## 代码

```c++
#include<string>
#include<iostream>

using namespace std;

int minDistance(string word1, string word2) 
{
	int n = word1.length(),m = word2.length();
	
	/*如果两个字符串中有一个为空，那么编辑距离就是长度非零的那个*/
	if(n*m == 0) return n+m;
	/*Dp数组,i代表word1前i个字符，j代表word2前j个字符*/
	int dp[n+1][m+1]; 
	
	/*初始化Dp数组边界,把其中一个看做空串，推导出操作数*/
	for(int i = 0;i<n+1;i++)
	{
		dp[i][0] = i;	
	}
	
	for(int j = 0;j<m+1;j++)
	{
		dp[0][j] = j;	
	}
	
	/*开始Dp,状态转移方程有两个
		当word1[i-1] = word2[j-1]时：
		dp[i][j] = min(dp[i][j-1]+1,dp[i-1][j]+1,dp[i-1][j-1]+1)
		当word1[i-1] != word2[j-1]时:
		dp[i][j] = min(dp[i][j-1]+1,dp[i-1][j]+1,dp[i-1][j-1])
	*/
	
	for(int i = 1;i<n+1;i++)
	{
		for(int j = 1;j<m+1;j++ )
		{
			int left = dp[i-1][j]+1;
			int down = dp[i][j-1]+1;
			int left_down = dp[i-1][j-1];
			if(word1[i-1] != word2[j-1]) left_down++;
			dp[i][j] = min(left,min(down,left_down));	
		}
	}
	
	return dp[n][m];
} 

int main()
{
	cout << minDistance("horse", "ros") << endl;
	return 0;
}
```

如果注释看不懂，下面我还精心给你准备了一张图：

![](https://images.gitee.com/uploads/images/2020/0406/180606_f42ceaaf_5550632.png)



## 总结

动态规划不好想，这道题刷个7，8遍都不足为过，有时不要拘泥于什么思想，说实话，这题我的第一想法是把两个字符串排字典序用贪心玩缺啥补啥，要啥改啥的套路，操作一次就加一，然后你把这例子往纸上一画，就发现自己想的太天真了【采用局部最优最后肯定大于正确答案，毕竟贪心和动态规划天生不对路子】。接着我就想暴力枚举出所有的操作结果，最后找一个次数最小的，但是这也就想想，不现实。一切都要以题目为实际出发，功夫下够了，自然就会了。不要生搬硬套数学概念，概念是从实际抽象总结出来的，只有从实际出发，才能看懂数学语言所描述的动态规划。

