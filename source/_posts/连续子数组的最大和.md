---
title: 连续子数组的最大和
declare: true
date: 2020-05-20 16:53:10
tags: [算法,动态规划]
categories: [计算机基础]
---

<meta name="referrer" content="no-referrer" />  

<!--more-->



# 连续子数组的最大和

## 问题描述

输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

 ## 测试用例

示例1:

输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

## 数据规模

提示：

1 <= arr.length <= 10^5
-100 <= arr[i] <= 100

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



## 题目翻译

> 输入：一个整型数组
>
> > 目的：找出**最大**连续子数组的和
>
> 坑：当连续子数组中的值到 x 为止之前全是负数就 x 是整数，那这个和，是多少？就是 x 自己



## 解题思路

### 暴力枚举

找出所有的连续子数组的加和情况，再找出最大的那个。

```c++
#include <iostream>
#include<vector>
#include<algorithm>
using namespace std;

int maxSubArrayEnum(vector<int>& nums)
{
    int ans = 0;
    int sum = 0;
    int len = 1;
    while (len < nums.size())//子数组长度
    {
        for (int i = 0; i < nums.size()-len; i++)//以不同位置起始
        {
            sum = 0;
            for (int j = i; j < i+len; j++)
            {
                sum += nums[j];
            }
            ans = max(sum, ans);
        }
        len++;
    }
    return ans;
}

int main()
{
    int len;
    ios::sync_with_stdio(false);
    cin >> len;
    vector<int> nums(len);
    for (int i = 0; i < len; i++)
    {
        cin >> nums[i];
    }
    cout << maxSubArrayEnum(nums) << endl;
}
```

时间复杂度：O(n³)

### 动态规划

通过这道题，原本的目的就是要入坑动态规划。

首先假设动态规划数组 dp[i] , dp[i] 的意义：

> dp[i] 是以 nums[i] 为结尾的连续子数组的最大和

例如，

nums = [-2,1,-3,4,-1,2,1,-5,4]

dp[0] :以 **-2** 为结尾的连续子数组的最大和，因为就它自己，所以
$$
dp[0] = -2
$$
**如果发现，dp[i-1]为负值，那么dp[i] = nums[i]**

原因：

> 无论nums[i]为何值，只要前 i-1 项连续子数组的最大和为**负数**，那么最大的“和” 只能是nums[i]

于是乎，我们就可以分成两种情况：

dp[i-1] < 0：

**dp[i] = nums[i]**

dp[i-1] >= 0：

**dp[i] = nums[i] + dp[i-1]**

即，最终我们的dp[i]为：
$$
max(nums[i]+dp[i-1],nums[i])
$$

```c++
#include <iostream>
#include<vector>
#include<algorithm>
using namespace std;

int maxSubArray(vector<int>& nums) 
{
    //动态规划
    //设dp[i]为当以nums[i]为结尾时的连续子数组最大和
    /*
        初始状态，dp[0] = nums[0],以num[0](只有一个数)结尾时，没得选，最大子数组和就是它自己
        dp[i-1] < 0 时，求dp[i],由于前i-1项的最大子数组和为负数，无论num[i]取正数还是负数，
            由于是负数项，总归是 < num[i]的，所以，此时dp[i] = num[i]
        dp[i-1] >= 0 时，求dp[i], dp[i] = max(dp[i-1]+num[i],num[i])
    */
    int ans = nums[0];
    vector<int> dp(nums.size());
    dp[0] = nums[0];
    for (int i = 1; i < nums.size(); i++)
    {
        dp[i] = max(dp[i-1]+nums[i],nums[i]);
        ans = max(dp[i], ans);
    }
    return ans;
}

int main()
{
    int len;
    ios::sync_with_stdio(false);
    cin >> len;
    vector<int> nums(len);
    for (int i = 0; i < len; i++)
    {
        cin >> nums[i];
    }
    cout << maxSubArray(nums) << endl;
}


```

时间复杂度：O(n)

归根到底，要抓住动态规划的两大命脉：

1. 发生改变的状态是什么？**求最大连续子数组的和，从初始状态只有一个元素的连续子数组开始推导。**
2. 状态转移方程是什么？或者说怎么选？当最小规模的子问题想要递推时，我们可以怎么选择？要选择什么样的结果？我们可以选择加和，也可以选择只选该数本身，**一切取决于题目的要求，本题求最大，那状态转移方程就是max(,)**



### 题目变形

叙述不变，试求**连续子数组的最小和**

```c++
int minSubArray(vector<int>& nums)
{
    int ans = 0;
    vector<int> dp(nums.size());
    dp[0] = nums[0];
    for (int i = 1; i < nums.size(); i++)
    {
        dp[i] = min(dp[i - 1] + nums[i],nums[i]);
        ans = min(ans, dp[i]);
    }
    return ans;
}
```

