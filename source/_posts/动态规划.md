---
title: 动态规划
date: 2019-12-18 18:39:14
tags: [算法,动态规划]
categories: [计算机基础]
copyright: true
description:
---

<meta name="referrer" content="no-referrer" />  
<!--more-->



# 动态规划(Dynamic Programming)

## Part 1 动态规划的概述

&emsp;动态规划来自于**运筹学**，其本质是一种数学思想，其目的在于找到**问题最优解(optimization)**。所以,我将以学习数学的方式来学习动态规划这一算法思想，用编程的手段来实现，在数学和工程学上两种角度对其进行阐述。

## Part 2 动态规划的相关概念

1. 【阶段】（局部性概念）:将所给问题的过程按照**时间或空间**特征，分解成若干个相互联系的阶段，以便按次序求个阶段的解。常用字母k表示。

   最短路径问题图例

   ![](https://images.gitee.com/uploads/images/2019/1223/180631_85f700f1_5550632.png)

2. 【状态】（局部性概念）:各个阶段开始时的客观条件，用 Sk 表示。如S1 = {A},S2 = {B1,B2},S3 = {C1,C2,C3}...

3. 【无后效性(马尔可夫性)】:当前阶段状态给定后，在这阶段之后的过程发展不受之前各个阶段的影响，比如，在第二状态(S2)选择了B1，在第三状态(S3)选择了C1，保证了之前选择的是最优解，这些选择对后面的选择是没有影响的。

4. 【决策】（局部性概念）：我们已知了当前阶段和状态，那么**确定下一阶段的选择**就是决策，例如，在B2点下一步走到C1去，这就是决策。表示决策的变量叫做**决策变量**。Uk(Sk)表示在第k阶段的状态为Sk时的决策变量，决策变量的取值一般都是有范围限制的，将次范围称为**允许决策集合**常用Dk(Sk)表示。例如：对于第二状态的B1的允许决策集合为D2(B1) = {C1,C2}。**决策变量**U2(B1) = C1，表示了C1是B1状态下通过U2(B1)的决策产生的新的状态。

5. 【策略】（整体性概念）:当各段决策确定之后，整个问题的决策序列就构成了一个决策序列，例:(A,B1,C1,D2,E)。这个决策序列就是我们所选择的一个策略。

   P1,n(s1) = {u1(s1),u2(s3),…,un(sn)}
   
   
   
   ![策略](https://images.gitee.com/uploads/images/2019/1223/180542_59ae3693_5550632.png)
   
   可供选择的策略是有一定范围的，这个范围叫做**允许策略集合**，例如，下列三个策略(A,B1,C2,D1,E),(A,B1,C2,D2,E),(A,B2,C1,D2,E)就是该集合的一部分。
   
   P1,n(A) = {B1,C1,D1,E},P1,n(A) = {B2,C1,D1,E}。
   
   让问题**达到最优效果**的策略就是**最优策略**。
   
   如何判断策略是最优的呢？
   
6. 【状态转移方程】（确定演变方法）：确定由一个状态到另外一个状态的演变过程。给定的k阶段的Sk状态，决策变量Uk(Sk)一旦确定，k+1阶段的状态变量Sk+1也就确定了。抽象化：

   ![状态转移方程](https://images.gitee.com/uploads/images/2019/1223/180622_81c86da1_5550632.png)

7. 【指标函数】（判定依据）：衡量所选策略优劣的数量指标。分为**阶段指标函数（局部性，点，离散的，独立的）**和**过程指标函数（整体性，线，连续的，完整的）**，那什么是阶段，什么是过程呢？对于一个n段决策过程，从阶段1到n是问题的**原过程**，对于任意k(1<= k<=n)从第k阶段开始到第n阶段结束，称为原过程的一个**后部子过程**。而阶段是从某状态Sk出发,采取决策Uk（在一点上做决策）它带来的效益Vk(Sk，Uk)称之为**阶段指标函数**。

   &emsp;V 1,n(S1,P 1,n):从阶段S1开始采取策略P1,n时所带来**原过程**的指标值（**过程指标函数值**），而V k,n(Sk,P k,n)是初始状态从Sk开始，采用策略P k,n时**后部子过程的指标函数值**。指标值具体化之后是什么呢？举个例子：

   本题是在求最短路径，那么指标值就是距离(图的权重)，若是投资问题，指标值就是收益，若是背包问题，那就是最大价值。

   所以由此可知，采用不同的策略，会导致产生不同的指标值，当该指标值为最优时，那个指标函数叫做**最优指标函数**(距离最短)。 称，fk(Sk):从第k阶段Sk状态开始，采取最优策略p*k,n到过程终止的**最优指标函数值**。

   哲学告诉我们，整体是由部分组成的，那么通过一个个阶段指标函数的组合(加和，乘积)就可以得到一个过程指标函数。V k,n(Sk,p k,n) = V k(Sk,uk)+V k+1,n(Sk+1,p k+1,n) //k到n阶段的指标函数 是由 **k这一点的决策**加上**k+1到n后部子过程的指标函数**构成的。乘法同理(依据题意)

   思考：若每个状态下都做最优的决策，其最终的策略会不会是最优策略？从而使整个过程达到最优解呢？
   
   &emsp;**理论基础**:无论过去的状态和决策如何，对前面决策所形成的状态而言，余下的决策必须构成最优策略。**将全过程优化问题分解成子过程的优化问题，从后向前逐步推导，最优化的子过程逐渐形成全过程最优**--美国运筹学家贝尔曼提出

基本概念已经通过最短路径问题阐述完毕，接下来就是实战应用了。

## Part 3 问题背景

&emsp;现在有一个奇葩国家的钞票面额分别是1、5、11，现在我们想要凑出15，那么**最少使用多少张钞票呢？**



## Part 4 数学分析和工程分析

&emsp;很明显，用多少张钞票和当前面额有直接关系，不妨设cost = f(x),x为当前面额，cost为所需张数。求解**使用最少张数**的问题就转化成了f(15)的最小值问题，f(15)与谁有关呢？由于，一共就有3种面额的钞票，所以为了求最小值我们可以把问题**分解**成f(14),f(10),f(4)【f(14)代表选择面值为1的纸币，f(10)代表选择了面值为5的纸币】，然后选择cost最小的那种 即， f(15) = min{ f(15-1)  ,  f(15-5)  ,  f(15-11) } + 1,长得是不是特别像递归？

![钞票示意图](https://images.gitee.com/uploads/images/2019/1223/180602_5ea81c8a_5550632.png)

&emsp;仔细分析一下，如果是递归的话什么时候结束呢？当x=0时，证明问题达到了最小，即凑出面值为0的方法有几种？f(0) = 0,若x＜0，就证明，这种凑法是不可能的，不妨将其cost设为无穷大。这样我们就拿到了一个Demo版的解决方案：

```c++
#include<iostream>

using namespace std;
int my_min(int num1,int num2,int num3);
int min_paper(int num);

#define INF 1000000
int main()
{
	cout << min_paper(15)<<endl;
	
	return 0;
}


int min_paper(int num)
{
	if(num == 0)
	{
		return 0;
	}
	else if(num < 0)
	{
		return INF;
	}
	else
	{
		return my_min(min_paper(num-11),min_paper(num-5),min_paper(num-1))+1;
	}
}

int my_min(int num1,int num2,int num3)
{
	int t_m = min(num1,num2);
	return min(t_m,num3);
}
```

&emsp;然而，我们发现上图的那棵三叉树，有重复的子树，比如在值为9的结点上，它们的子问题其实都是一样的【称之为重叠子问题】                    f(9) = min{ f(8),f (4) } + 1,但是，递归是不会重复利用这种信息的，这就导致了递归算法的时间代价会很大。正是由于递归**缩减问题规模**的特性，使它无法重复利用已知信息。那么我们为什么不考虑一下直接从**最小的问题开始**递推到当前问题呢？【PS:由动态规划的两种解法解题中得到的启发，顺推法和逆推法】

&emsp;f (0) = 0 ,f(1) = min{f(0),INF,INF}+1 = 1,f(2) = min{f(1),INF,INF}+1 = 2...f(5) = min{f(4),f(0),INF}+1 = 1

f(0) = 0,f(1) = 1,f(2) = 2,f(3) = 3,f(4) = 4,f(5) = 1,f(6) = 2,f(7) = 3,...,f(11) = 1,f(12) = 2...





##  Part 5 代码实现

```c++
void min_paper_dp(int num)
{
	int i,cost = INF;
	int f[1000];
	f[0] = 0;
	for(i = 1;i<=num;i++)
	{
        /*每一次循环都相当于在做最优决策*/
		cost = INF;
		if(i-1>=0)
		{
			cost = min(f[i-1]+1,cost);
		}
		if(i-5>=0)
		{
			cost = min(f[i-5]+1,cost);
		}
		if(i-11>=0)
		{
			cost = min(f[i-11]+1,cost);
		}
		f[i] = cost;
		cout << "f[" << i<<"]" << " = " << f[i]<< endl;
	}	
}
```

、

## 总结

&emsp;设计DP算法要从数学和工程学两方面考虑

数学方面

1. 要明确一个问题的阶段和状态(把一个大过程拆分成若干个子问题)
2. 决策方式(选什么样的钞票面额)
3. 确定最优指标函数和状态转移方程(f(15) = min{ f(15-1)  ,  f(15-5)  ,  f(15-11) } + 1)

工程方面

1. 考虑这个问题可以用哪种数据结构来描述(结构决定性质，比如树形结构就有递归，递推的性质，那是不是所有的DP都可以看成图的最短路径问题？)
2. 使用重叠子问题的技巧，通俗的说，叫“花费空间来节省时间”
3. 分治，递归，递推只是实现动态规划的方法，而不是动态规划它本身！！！