---

title: 数据结构与算法(1)-顺序表
date: 2019-12-15 13:56:34
tags: [数据结构与算法,顺序表]
categories: [计算机基础,线性表]
copyright: true
description:
---

<meta name="referrer" content="no-referrer" />  
<!--more-->

# 1 线性表

# Part 1线性表

## 1.1 线性表的定义

&emsp;**线性表**是由n(n≥0)个属于同种数据对象的数据元素 a1,a2,a3,...,an 组成的有限序列。换句话说就是某一序列中元素的数据类型要一致。

&emsp;此外，除了首元素a1没有前驱元素，尾元素an没有后继元素之外，其余的元素都会有一个直接前驱元素和一个直接后继元素，n为线性表中元素的个数，同时也是线性表的长度。

![](https://images.gitee.com/uploads/images/2019/1215/144421_354da353_5550632.png)

由此可以看出，线性表有着明显的**“一对一”**逻辑关系。通常把具有这种特点的数据结构称为线性结构。

可将一个线性表记作&emsp;A = (a1,a2,a3,...,an)

例如:数学中的数列就是一种线性表(1,1,2,3,5,8,...),英文字母表('A','B','C',...)一样也是。 

## 1.2 线性表的相关操作

&ensp;对于任何一类数据结构无外乎就4种基本操作，*增，删，改，查*，线性表也不例外。

&emsp;基本操作算法如下:

1. 初始化一个线性表
2. 判断是否为空
3. 求线性表长度
4. 插入(首端插入，中间插入，尾端插入)
5. 删除(首端删除，中间删除，尾端删除)
6. 遍历线性表
7. ...



# Part 2 顺序表(线性表的顺序存储结构)

## 2.1 逻辑结构

&emsp;毋庸置疑，顺序表的逻辑结构是**线性结构**。但是，在计算机内部可以采用不同的方式来存储线性表，其中最简单的方式就是使用**一组地址连续的存储单元**来依次存储线性表中的元素。这种存储结构称之为线性表的**顺序存储结构**。并称此时的线性表为**顺序表(Sequence List)**。

## 2.2 存储结构

&emsp;由于线性表中所有元素属性相同，即在内存中占的大小是一样的，我们可以通过**寻址函数LOC()**轻松地找到元素的位置。不妨设a0 为顺序表首元素，表中数据元素大小为 size,现在相求第 i 个元素的位置，易知:

&emsp;&emsp;LOC(ai) = LOC(a0) + ( i - 1 )*size

&emsp;由此可知，只要确定了首地址，顺序表中的任何一个元素都可以进行随机存取，因此也可以称线性表的顺序存储结构是一种**随机存储的存储结构**。

## 2.3 相关操作算法(代码实现)

```c++
#include<iostream>
#include<malloc.h>

#define MAX_SIZE 100//顺序表最大长度

using namespace std;

typedef struct SequenceList
{
    /*定义顺序表结构体*/
	int data[MAX_SIZE];
	int length; 
}SeqList;

```

&emsp;以上是结构体和宏的定义

```c++

void list_init(SeqList * &list)
{
	/*初始化顺序表*/
	list = (SeqList *)malloc(sizeof(SeqList));
	list->length = 0;
}

bool is_empty(SeqList * list)
{
    /*判断顺序表是否为空*/
	if(list->length == 0)
	{
		return true;
	}
	return false;
}

bool is_full(SeqList *list)
{
    /*判断顺序表是否已满*/
	if(list->length == MAX_SIZE-1)//顺序表长度为MAX_SIZE，即下标值最大到MAX_SIZE-1
	{
		return true;
	}
	return false;
}

```

&emsp;使用一个指向SeqList类型的指针list，就像是拿到了一间房子的钥匙(顺序表首地址)

```c++
void insert_list(SeqList * &list,int index,int elem)
{
    /*插入算法，第一步就要判断顺序表是否为满*/
	if(is_full(list))
	{
		return;
	}
	if(index < 1 || index > MAX_SIZE)
	{
        /*合法的插入位置应该在[1,MAX_SIZE],即下标在[0,MAX_SIZE-1]*/
		return;
	}
	for(int i = list->length-1;i>=index;i--)
	{
		list->data[i+1] = list->data[i];
	}
	list->data[index-1] = elem;
	list->length++;
}
```

&emsp;位置合法性说明：一个长度最大值为3 的数组，合法插入位置为 1，2，3。其合法下标为 0，1，2

&emsp;算法实现机制说明:

![](https://images.gitee.com/uploads/images/2019/1215/161302_8834ad7a_5550632.png)

```c++
void del_list(SeqList * &list,int index,int &elem)
{
    /*删除算法和插入算法相似，不再赘述*/
	if(is_empty(list))
	{
		return;
	}
	if(index < 1 || index > MAX_SIZE)
	{
		return;
	}
	elem = list->data[index-1];
	for(int i = index;i<list->length;i++)
	{
		list->data[i-1] = list->data[i];
	}
	list->length--;
}
```

&emsp;附上遍历算法和查找算法

```c++
int location(SeqList *list,int elem)
{
	/*如果没找到返回-1*/
	for(int i = 0;i<list->length;i++)
	{
		if(elem == list->data[i])
		{
			return i+1;
		}
	}
	return -1;
}

void print_list(SeqList * list)
{
	for(int i = 0;i<list->length;i++)
	{
		cout << list->data[i] << ",";
	}
	cout << endl;
}
```



# Part 3 顺序存储结构总结

## 3.1 特点

&emsp;线性表的顺序存储结构最大的逻辑特点就是**逻辑上相邻的两个元素，在计算机的物理位置中也是相邻的**，由于这一特点造就了线性表在顺序存储结构下有着很明显的优点和缺点。

## 3.2 优点

1. 原理简单直观
2. 已知每个数据元素的大小，只要知道首元素存储位置，很容易推算任意位置元素的地址
3. 对于表中的所有数据元素都可以，顺序访问或随机访问
4. 由于用下标隐式地表明了数据间的逻辑关系，使得它不用使用额外内存来存放数据间关系

## 3.3 缺点

1. 需要一块连续的存储单元进行存放
2. 存储空间需要提前分配，这也就导致的顺序存储的线性表扩容会很困难
3. 进行插入和删除操作时，要对待插入或删除元素后面的所有元素进行移动，操作时间效率低



