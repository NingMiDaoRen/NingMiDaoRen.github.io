---
title: 黄金分割数
date: 2020-02-28 11:22:12
tags: [竞赛,大数运算]
categories: [计算机基础]
copyright: true
description:
---

<meta name="referrer" content="no-referrer" />  

<!--more-->

# 黄金分割数(结果填空)



## 题目描述

黄金连分数
 黄金分割数0.61803... 是个无理数，这个常数十分重要，在许多工程问题中会出现。有时需要把这个数字求得很精确。
 对于某些精密工程，常数的精度很重要。也许你听说过哈勃太空望远镜，它首次升空后就发现了一处人工加工错误，对那样一个庞然大物，其实只是镜面加工时有比头发丝还细许多倍的一处错误而已，却使它成了“近视眼”!!
 言归正传，我们如何求得黄金分割数的尽可能精确的值呢？有许多方法。
 比较简单的一种是用连分数：

![](https://images.gitee.com/uploads/images/2020/0228/113127_821bd438_5550632.png)
 这个连分数计算的“层数”越多，它的值越接近黄金分割数。
 请你利用这一特性，求出黄金分割数的足够精确值，要求四舍五入到小数点后100位。
   小数点后3位的值为：0.618
   小数点后4位的值为：0.6180
   小数点后5位的值为：0.61803
   小数点后7位的值为：0.6180340
   （注意尾部的0，不能忽略）
 你的任务是：写出精确到小数点后100位精度的黄金分割值。
 注意：尾数的四舍五入！ 尾数是0也要保留！
 显然答案是一个小数，其小数点后有100位数字



## 题目翻译

> 已知条件：一个暂且意义不明的连分数
>
> > 目的：算数
> >
> > > 数据含义：连分数层数越多，最后的黄金分割数越精确
>
> 坑(注意事项): 小数点后100位精度，尾数的四舍五入，尾数是0也要保留
>
> 读懂连分数的表示形式，是本题的突破口



## 连分数解析

以分号为界，稍微分析一下：

第 1 项：

![](https://images.gitee.com/uploads/images/2020/0228/114854_540b836e_5550632.png)
$$
a_1 = 1
$$
第 2 项:

![](https://images.gitee.com/uploads/images/2020/0228/115108_1257d38e_5550632.png)
$$
a_2 = \frac{1}{2}
$$


第 3 项：

![](https://images.gitee.com/uploads/images/2020/0228/115224_f3c521c2_5550632.png)
$$
a_3 = \frac{1}{1+\frac{1}{2}} = \frac{1}{\frac{3}{2}} = \frac{2}{3}
$$
第 4 项:

![](https://images.gitee.com/uploads/images/2020/0228/115853_c1dac79f_5550632.png)
$$
a_4 = \frac{1}{1 + {a_3}} = \frac{1}{\frac{5}{3}} = \frac{3}{5}
$$
第 n 项:
$$
a_n = \frac{1}{1 + {a_{n-1}}}
$$
1 1 2 3 5 8 13...这些数长的是不是特别像斐波那契数列里的数啊,看不出来的话，通过这次就看出来了。



## 问题转型

> 原来求黄金分割数的问题转换为:
>
> 1. 求出第 n - 1 和第 n 项斐波那契数
> 2. 二者做除法 
>
> $$
> answer = \frac{f_{n-1}}{f_n}
> $$
>
> 3. 找到最精确的100位，意味着要算出101位小数【大数除法】

流程：

1. 求出两个项数比较大的斐波那契数
2. 两个数做除法，拿到小数点后101位
3. 再取两个项数比较大的斐波那契数
4. 再做除法，取小数点后101位
5. 比较两个小数，四舍五入后，是否相同，相同则结束。否则，接着取，直到“最精准”为止



## 编码思路(C++硬核实现版)

1. 先求斐波那契数列

> 注意，由于要算的项数很大，递归绝对会导致栈溢出，因此使用【大数加法】

   2.做除法【大数除法】

> 大数除法 = 大数减法



### 大数加法

虽然之前写过相关的博客，但是总感觉写的太粗糙，这次我们从头分析一下。

1. 加法都是从个位开始的，所以为了方便，我们**取出非零子串，进行反转【数组下标0代表个位】**
2. 找出两个字符串长度最长者，将其当作结果串的长度最小值【考虑到最后可能进位的问题】
3. 进位模拟

> 设字符串 a,b
>
> 对于长度，一共就三种情况
>
> 1. 一样长
> 2. length_A > length_B
> 3. length_A < length_B

那么我们这三个串的关系，无论a，b谁长，都是这样的：

![](https://images.gitee.com/uploads/images/2020/0228/181924_99862181_5550632.png)

即：
$$
LengthAnswer > max(Length A,LengthB)
$$
所以，抛开本题而言，进位加的时候是有限制的，待会看代码的注释就明白了【题目的输入b的长度永远>=a(如8，13)】

```c++
#include<iostream>
#include<algorithm>
#include<string>

using namespace std;

string add(string a,string b)
{
	a = a.substr(a.find_first_not_of('0'));
	b = b.substr(b.find_first_not_of('0'));
	long lenA = a.length();
	long lenB = b.length();
	long maxLen = max(lenA,lenB) + 10;//多预留10位，保证进位时不会溢出
	
	reverse(a.begin(),a.end());//反转字符串
	reverse(b.begin(),b.end());
	
	string ans(maxLen,'0');
	for(int i = 0;i<lenA;i++)//复制副本
	{
		ans[i] = a[i];	
	}
	int jinwei = 0;
	for(int i = 0;i<maxLen;i++)
	{
		
		if(i < min(lenA,lenB))//在i到达两个字符串最小长度之前，两个串在下标 i 处都有值
		{
			jinwei += (ans[i]-'0') + (b[i] - '0');
		}
		else//i >= min_length，此时要分a,b串哪个更长分类讨论
		{
			if(lenA > lenB && i<lenA)//a 比 b长，i所在位置<lenA
			{
				jinwei += (ans[i] - '0');	
			}
			else if(lenB > lenA && i<lenB)//同理分析
			{
				jinwei += (b[i] - '0');	
			}	
		}
		
		ans[i] = (jinwei%10) + '0';//注意转回字符，取个位
		jinwei /= 10;//算进位
	}
	reverse(ans.begin(),ans.end());//别忘了反转回来，去零
	return ans.substr(ans.find_first_not_of('0'));
}
```



### 大数除法

大数除法就是大数减法，看下图:

![](https://images.gitee.com/uploads/images/2020/0228/184957_35fce611_5550632.png)

通过上图，我们知道了一些规律

> 小数位就是减的次数
>
> 在 a/b 时，一旦a < b就补零
>
> > 减法的注意事项：
> >
> > 1.不够减借位的情况
> >
> > 2.够减不用借位的情况
> >
> > 3.负数的情况【本题不用考虑】
> >
> > 4.在本题中 a < b,所以上来就要补零，或者让其强行符合计算定义

```python
"伪代码"
ans = “0.”
def divide(a,b):
    for i in range(0,101):#除101次
        a+="0"
        t = 0
        while cmp(a,b) == 1:# a > b cmp返回 1
        	a = subtract(a,b)#做减法
            t++#计次数
        ans.append(str(t))
        
```

#### 开始正式编码

```c++
//大数除法
string divide(string a, string b)//a < b
{
	string ans = "0.";

	for (int i = 0; i < 101; i++)//算到第101位方便四舍五入
	{
		int t = 0;
		a.append("0");
		while (cmp(a, b) >= 0)//a >= b && 比较函数
		{
			a = subtract(a, b);//大数减法
			t++;
		}

		ans.append(to_string(t));
	}
	return ans;
}

```



```c++
//大数减法
string subtract(string a, string b)//a > b这是调用条件 
{

	int lenA = a.length(), lenB = b.length();
	int minLen = lenA > lenB ? lenB : lenA;
	//翻转 
	reverse(a.begin(), a.end());
	reverse(b.begin(), b.end());
	//按位减法：1.借位，2.够不够借 
	for (int i = 0; i < minLen; i++)
	{
		if (a[i] >= b[i])//够减 
		{
			a[i] = a[i] - b[i] + '0';
		}
		else//不够减就要借位 
		{

			int k = 1;
			while (a[i + k] == '0')
			{
				a[i + k] = '9';
				k++;
			}
			//保证i+k这位上下标[i+k-1]一定>0
			a[i + k] = a[i + k] - '1' + '0';
			a[i] = (a[i] - '0' + 10) - (b[i] - '0') + '0';
		}
	}
	reverse(a.begin(), a.end());
	if (a.find_first_not_of('0') == string::npos) return "0";
	return a.substr(a.find_first_not_of('0'));
}
```



```c++
//比较函数
int cmp(string a, string b)
{
	//如果整个字符串都是零，找第一个非零位置时会返回string::npos
	if (a.find_first_not_of('0')== string::npos) a = '0';
	else a = a.substr(a.find_first_not_of('0'));

	
	if (b.find_first_not_of('0') == string::npos) b = '0';
	else b = b.substr(b.find_first_not_of('0'));
	
	if (a.length() > b.length()) return 1;
	else if (a.length() < b.length()) return -1;
	else
	{
		if (a > b) return 1;
		if (a < b) return -1;
		else return 0;
	}
}
```



## 代码汇总

```c++
#include<iostream>
#include<algorithm>
#include<string>
#include<sstream>

using namespace std;

string divide(string a, string b);
string subtract(string a, string b);
int cmp(string a, string b);
string add(string a, string b); 


int main()
{
	string a = "1";
	string b = "1";
	
	for(int i = 3;i<=50;i++)//第 50 项
	{
		string tmp = b;
		b = add(a,b);
		//cout << b << endl;
		a = tmp;
	}
	cout << "a:" << a << endl;
	cout << "b:" <<b << endl;
	cout << divide(a,b) << endl;
	return 0;
}



string add(string a, string b)
{
	a = a.substr(a.find_first_not_of('0'));
	b = b.substr(b.find_first_not_of('0'));
	long lenA = a.length();
	long lenB = b.length();
	long maxLen = max(lenA, lenB) + 10;


	reverse(a.begin(), a.end());
	reverse(b.begin(), b.end());

	string ans(maxLen, '0');
	for (int i = 0; i < lenA; i++)
	{
		ans[i] = a[i];
	}
	int jinwei = 0;
	for (int i = 0; i < maxLen; i++)
	{

		if (i < min(lenA, lenB))
		{
			jinwei += (ans[i] - '0') + (b[i] - '0');
		}
		else
		{
			if (lenA > lenB&& i < lenA)
			{
				jinwei += (ans[i] - '0');
			}
			else if (lenB > lenA&& i < lenB)
			{
				jinwei += (b[i] - '0');
			}
		}

		ans[i] = (jinwei % 10) + '0';
		jinwei /= 10;
	}

	reverse(ans.begin(), ans.end());
	return ans.substr(ans.find_first_not_of('0'));
}

int cmp(string a, string b)
{
	
	if (a.find_first_not_of('0')== string::npos) a = '0';
	else a = a.substr(a.find_first_not_of('0'));

	
	if (b.find_first_not_of('0') == string::npos) b = '0';
	else b = b.substr(b.find_first_not_of('0'));
	
	if (a.length() > b.length()) return 1;
	else if (a.length() < b.length()) return -1;
	else
	{
		if (a > b) return 1;
		if (a < b) return -1;
		else return 0;
	}
}

string subtract(string a, string b)//a > b这是调用条件 
{

	int lenA = a.length(), lenB = b.length();
	int minLen = lenA > lenB ? lenB : lenA;
	//翻转 
	reverse(a.begin(), a.end());
	reverse(b.begin(), b.end());
	//按位减法：1.借位，2.够不够借 
	for (int i = 0; i < minLen; i++)
	{
		if (a[i] >= b[i])//够减 
		{
			a[i] = a[i] - b[i] + '0';
		}
		else//不够减就要借位 
		{

			int k = 1;
			while (a[i + k] == '0')
			{
				a[i + k] = '9';
				k++;
			}
			//保证i+k这位上下标[i+k-1]一定>0
			a[i + k] = a[i + k] - '1' + '0';
			a[i] = (a[i] - '0' + 10) - (b[i] - '0') + '0';
		}
	}
	reverse(a.begin(), a.end());
	if (a.find_first_not_of('0') == string::npos) return "0";
	return a.substr(a.find_first_not_of('0'));
}

string divide(string a, string b)
{
	string ans = "0.";
	if(a == b) ans = "1.";
	if(a < b) ans = "0.";
	for (int i = 0; i < 101; i++)
	{
		int t = 0;
		a.append("0");
		while (cmp(a, b) >= 0)//a >= b
		{
			a = subtract(a, b);
			t++;
		}

		ans.append(to_string(t));

	}
	return ans;
}

```



## 最后一坑

我们来看看第50项斐波那契数和第49项相除的结果

![](https://images.gitee.com/uploads/images/2020/0309/105221_0122a9f9_5550632.png)

0.61803398874989484820740990001204904326284254042472288566070913139408284656461170787663185198760678802

光看这一项不能确保结果稳定，咱们在向下看看

第100项

![](https://images.gitee.com/uploads/images/2020/0309/105358_89763856_5550632.png )

差距还挺大，再看看

![](https://images.gitee.com/uploads/images/2020/0309/105521_508b554c_5550632.png)



还是不够“精确”，再来

![](https://images.gitee.com/uploads/images/2020/0309/105733_39f0b30c_5550632.png)

![](https://images.gitee.com/uploads/images/2020/0309/105804_3e1dd03f_5550632.png)

哦吼，在第300和第400项的时候，后一百位趋近于稳定，**此时提交才是正确的**

最终答案是：

0.6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911375

此时，回头看，发现至少要求到300项斐波那契数，这么大的数早就超出所有数值范围了。

这数长成这样：

222232244629420445529739893461909967206666939096499764990979600

况且啊，这份代码我修修补补得有1个多小时，DeBug的次数都记不清了，这就证明手写可以，性价比太低，就算有解题思路也很可能做不对题，所以引出 Java语言的大数运算工具。



## 编码思路(Java粗暴版)

思路没啥可说的，主要采用的方法：

1. 大数加法
2. 大数除法
3. 大数减法

Java 的大数运算模块在 java.math下

```java
package first;
import java.math.*;


public class GoldenNumber {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		BigInteger a = new BigInteger("1",10);
		BigInteger b = new BigInteger("3",10);
		
		for(int i = 3;i<=400;i++)
		{
			BigInteger tmp = b;
			b = a.add(b);
			a = tmp;
		}
		System.out.println(divide(a,b));
	}
	
	public static String divide(BigInteger a,BigInteger b) {//a<b
		
		String ans = "0.";
		for(int i = 1;i<=101;i++) {
			a = a.multiply(BigInteger.TEN);//常量大数10
			int cnt = 0;
			while(a.compareTo(b) >= 0) {
				a = a.subtract(b);
				cnt++;
			}
			ans += cnt;
		}
		return ans;
	}
}

```

运行答案(101位)：

0.61803398874989484820458683436563811772030917980576286213544862270526046281890244970720720418939113748

用时 20 分钟，因为我只知道有这么个类，不知道具体方法，上网查了一下耗时就长了。

那么这篇文章就到此结束吧！

