---
title: 岛屿的最大面积
date: 2020-03-15 15:57:48
tags: [算法,深度优先,广度优先]
categories: [计算机基础]
declare: true
description:
---

<meta name="referrer" content="no-referrer" />  

<!--more-->

# 岛屿的最大面积



## 题目描述

给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。

找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/max-area-of-island
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 测试用例

示例 1:

[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]


对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。

示例 2:

[[0,0,0,0,0,0,0,0]]

对于上面这个给定的矩阵, 返回 0。



## 数据规模

注意: 给定的矩阵grid 的长度和宽度都不超过 50。



## 题目翻译

> 已知：一个二维数组
>
> > 数据含义：数组中只存在0和1，0代表水，1代表土地
> >
> > > 目的：在**上下左右**四个方向中，找出最大的土地面积(按条件数出1的最大数量)
> >
> > 坑：就四个方向，别多算



## 解题思路

本题的突破口在于，**数数的策略上**，用张图来教教咱们如何让电脑学会数数。

![让电脑学会如何数数](https://images.gitee.com/uploads/images/2020/0315/162210_f34bb0a2_5550632.png)

上图，是一个4*6的图(二维数组)，为了方便理解我们把土地和海水上色。众所周知，没有最傻的电脑，只有更傻的程序员。电脑不会数，其实就是人的能力不行，废话不多说，直接进入正题。

类比人数，一般人有两种数法，一种是**刨根问底型**，还有**全面开花型**，中文中括号内的内容可以忽略不管。

**刨根问底型**

以上面那一块岛屿为例，如果刨根问底地数就会产生如下效果 (方向优先级：下>左>右>上)

> 在（0，2）处发现土地，以它为起点开始数数，依照方向优先级向下
>
> 【(0,2)入栈，置(0,2)值从1变成0】
>
> 到达(1，2)，再向下发现是海，向左，并标记该点已经数过
>
> 【(0,2)出栈，(1,2)入栈，置(1,2)值从1变成0】
>
> 到达(1，1),向下，并标记该点已经数过
>
> 【(1,1)入栈，置(1,1)值从1变成0】
>
> 到达(2，1)，向下，发现是海，向左，是海，向右还是海，标记该点已经数过
>
> 【(1,1)出栈，(2,1)入栈，置(2,1)值从1变成0】
>
> **回溯至(1，2)**，标记该点已经数过，向右
>
> 【(2,1)出栈，此时栈顶为(1,2)，(1,2)出栈，栈顶为空】
>
> 到达(1，3)，向下，是海，向左，走过，向右，边界，**结束**
>
> 共计：5 块土地

这样的策略，我们管它叫**深度优先搜索**

**全面开花型**

以下面那块岛屿为例，我们来看看全面开花型怎么数 (方向优先级：下>左>右>上)

>在(4，1)处发现土地，以它为起点开始数数，依照方向优先级向下
>
>【(4,1)入队，置(4,1)值为0】
>
>看(5，1)不行，看(4，2)可以
>
>【取队头(4,1)，(4,1)出队，以下左(4,2)右上依次入队】
>
>到达(4，2)，标记该点已经数过,向下
>
>【取队头(4,2)，(4,2)出队，以下(5,2)左右(4,3)上依次入队】
>
>到达(5，2)，标记该点已经数过
>
>【取队头(5,2)，(5,2)出队，以下左右上依次入队，发现没有合法的，再取队头(4,3)】
>
>到达(4，3)，标记该点已经数过，发现其周围没有合法的，**结束**
>
>【取队头(4,3)，(4,3)出队，以下左右上依次入队，发现没有合法的，再取队头,为空，结束】
>
>共计：4 块土地

这样的策略，我们称之为**广度优先搜索**

在看解法之前我们还需要明确什么时候数是正确的，换言之：

1. 4个边界不算数
2. 已经数过的不算数



## 解法一：深度优先算法 (Depth First Search)

分析下编码思路：

> 1.将二维数组中的所有元素都扔进一个函数里，去深度优先遍历
>
> 2.拿到返回值，取最大的那个



```python
"伪代码"
def maxAreaOfIsland(int grid[][]):
    ans = 0
    for(i = 0;i<grid.length();i++)
    {
        for(j = 0;j<grad[0].length();j++)
        {
            ans = max(ans,dfs(grid,i,j))
        }
    }
    return ans

def dfs(int grid[][],cur_i,cur_j):
    if cur_i < 0 || cur_j < 0 || cur_i == grid.length() || 
    cur_j == grid[0].length() || grid[cur_i][cur_j] != 1:
        return 0
    grid[cur_i][cur_j] = 0"置0"
    ans = 1
    pos_i = [1,0,0,-1]
    pos_j = [0,1,-1,0]
    for(index = 0;index!=4;index++):
    	next_i = cur_i+pos_i[index]
        next_j = cur_j+pos_j[index]
    	ans +=dfs(grid,next_i,next_j)
    return ans
    
```

### 正式编码

```cpp
#include<iostream>
#include<vector>
#include<stack>
#include<queue>

using namespace std;

int maxAreaOfIsland(vector<vector<int>>& grid);
int dfs(vector< vector<int>>& grid,int cur_i,int cur_j);

int main()
{
	vector< vector<int>>grid = {{0,0,1,0,0,0,0,1,0,0,0,0,0},
								 {0,0,0,0,0,0,0,1,1,1,0,0,0},
								 {0,1,1,0,1,0,0,0,0,0,0,0,0},
								 {0,1,0,0,1,1,0,0,1,0,1,0,0},
								 {0,1,0,0,1,1,0,0,1,1,1,0,0},
								 {0,0,0,0,0,0,0,0,0,0,1,0,0},
								 {0,0,0,0,0,0,0,1,1,1,0,0,0},
								 {0,0,0,0,0,0,0,1,1,0,0,0,0}};
 
 	cout << maxAreaOfIsland(grid) << endl;
	return 0;
}


int maxAreaOfIsland(vector<vector<int>>& grid) 
{
	int ans = 0;
	for(int i = 0;i<grid.size();i++)
	{
		for(int j = 0;j<grid[0].size();j++)
		{
			ans = max(ans,dfs(grid,i,j));
		}
	}
	return ans;
}

int dfs(vector< vector<int>>& grid,int cur_i,int cur_j)
{
	if(cur_i<0 || cur_j<0 || cur_i == grid.size() || cur_j == grid[0].size() || grid[cur_i][cur_j] != 1)
	{
		return 0;
	}
	int ans = 1;
	grid[cur_i][cur_j] = 0;
	int pos_i[4] = {1,0,0,-1};
	int pos_j[4] = {0,1,-1,0};
	for(int i  = 0;i!=4;i++)
	{
		int next_i = cur_i + pos_i[i];
		int next_j = cur_j + pos_j[i];
		ans += dfs(grid,next_i,next_j);
	}
	return ans;
}

```

### 栈模拟法

这回再回头去看那个中文中括号里的内容就理解了。

```c++
int maxAreaOfIsland2(vector<vector<int>>& grid)
{
	int ans = 0;
	for(int i = 0;i<grid.size();i++)
	{
		for(int j = 0;j<grid[0].size();j++)
		{
			stack<int> stacki;
			stack<int> stackj;
			int cnt = 0;
			stacki.push(i);
			stackj.push(j);
			while(!stacki.empty())
			{
				int cur_i = stacki.top();
				int cur_j = stackj.top();
				
				stacki.pop();
				stackj.pop();
				if(cur_i < 0 || cur_j < 0 || cur_i == grid.size() || cur_j == grid[0].size() || grid[cur_i][cur_j] != 1)
				{
					continue;
				}
				cnt++;
				grid[cur_i][cur_j] = 0;
				int pos_i[4] = {1,0,0,-1};
				int pos_j[4] = {0,1,-1,0};
				for(int index  = 0;index!=4;index++)
				{
					int next_i = cur_i + pos_i[index];
					int next_j = cur_j + pos_j[index];
					stacki.push(next_i);
					stackj.push(next_j);
				}
			}
			ans = max(ans,cnt);
		}
	}
	return ans;
}
```



## 解法二：广度优先算法 (Breadth  First Search)

广度优先就是把栈换成队列，其余都一样。因为栈不注重当前的坐标，它会将之前的坐标先存起来，等到没有实在没有选择时，再回溯出来。

而队列特性就是先进先出，放到本题里就是，**来一个点处理一个点**，直到队列空为止。

```cpp
int maxAreaOfIsland3(vector<vector<int>>& grid)
{
	int ans = 0;
	for (int i = 0; i < grid.size(); i++)
	{
		for (int j = 0; j < grid[0].size(); j++)
		{
			queue<int> queuei;
			queue<int> queuej;
			int cnt = 0;
			queuei.push(i);
			queuej.push(j);
			while (!queuei.empty())
			{
				int cur_i = queuei.front();
				int cur_j = queuej.front();
				queuei.pop();
				queuej.pop();
				if (cur_i < 0 || cur_j < 0 || cur_i == grid.size() || cur_j == grid[0].size() || grid[cur_i][cur_j] != 1)
				{
					continue;
				}
				cnt++;
				grid[cur_i][cur_j] = 0;
				int pos_i[4] = { 1,0,0,-1 };
				int pos_j[4] = { 0,1,-1,0 };
				for (int index = 0; index != 4; index++)
				{
					int next_i = cur_i + pos_i[index];
					int next_j = cur_j + pos_j[index];
					queuei.push(next_i);
					queuej.push(next_j);
				}
			}
			ans = max(ans, cnt);
		}
	}
	return ans;
}
```



## 总结

深度优先搜索用栈【或者利用递归栈的特性】

广度优先搜索用队列